<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>tronpytool.transactionbuilder API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tronpytool.transactionbuilder</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# --------------------------------------------------------------------
# Copyright (c) iEXBase. All rights reserved.
# Licensed under the MIT License.
# See License.txt in the project root for license information.
# --------------------------------------------------------------------

from datetime import datetime
from typing import (
    Any,
    Tuple,
    List
)

from eth_abi import encode_abi
from trx_utils import (
    is_string,
    is_integer,
    is_boolean,
    is_hex,
    encode_hex
)

from tronpytool.common.validation import is_valid_url
from tronpytool.exceptions import (
    InvalidTronError,
    TronError,
    InvalidAddress
)

DEFAULT_TIME = datetime.now()
START_DATE = int(DEFAULT_TIME.timestamp() * 1000)


class TransactionBuilder(object):
    debug = True

    def __init__(self, tron):
        self.tron = tron

    def setDebug(self, b: bool) -&gt; None:
        self.debug = b

    def send_transaction(self, to, amount, account=None):
        &#34;&#34;&#34;Creates a transaction of transfer.
        If the recipient address does not exist, a corresponding account will be created.

        Args:
            to (str): to address
            amount (float): amount
            account (str): from address

        Returns:
            Transaction contract data

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if not self.tron.isAddress(to):
            raise InvalidTronError(&#39;Invalid recipient address provided&#39;)

        if not isinstance(amount, float) or amount &lt;= 0:
            raise InvalidTronError(&#39;Invalid amount provided&#39;)

        _to = self.tron.address.to_hex(to)
        _from = self.tron.address.to_hex(account)

        if _to == _from:
            raise TronError(&#39;Cannot transfer TRX to the same account&#39;)

        response = self.tron.manager.request(&#39;/wallet/createtransaction&#39;, {
            &#39;to_address&#39;: _to,
            &#39;owner_address&#39;: _from,
            &#39;amount&#39;: self.tron.toSun(amount)
        })

        return response

    def send_token(self, to, amount, token_id, account=None):
        &#34;&#34;&#34;Transfer Token

        Args:
            to (str): is the recipient address
            amount (int): is the amount of token to transfer. must be integer instead of float
            token_id (any): Token Name and id
            account: (str): is the address of the withdrawal account

        Returns:
            Token transfer Transaction raw data

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if not self.tron.isAddress(to):
            raise InvalidTronError(&#39;Invalid recipient address provided&#39;)

        if not isinstance(amount, int) or amount &lt;= 0:
            raise InvalidTronError(&#39;Invalid amount provided&#39;)

        if not token_id:
            raise InvalidTronError(&#39;Invalid token ID provided&#39;)

        if not self.tron.isAddress(account):
            raise InvalidTronError(&#39;Invalid origin address provided&#39;)

        _to = self.tron.address.to_hex(to)
        _from = self.tron.address.to_hex(account)
        _token_id = self.tron.toHex(text=str(token_id))

        if _to == _from:
            raise TronError(&#39;Cannot transfer TRX to the same account&#39;)

        # In case if &#34;TRX&#34; is specified, we redirect to another method.
        if is_string(token_id) and token_id.upper() == &#39;TRX&#39;:
            return self.send_transaction(_to, amount, _from)

        return self.tron.manager.request(&#39;/wallet/transferasset&#39;, {
            &#39;to_address&#39;: _to,
            &#39;owner_address&#39;: _from,
            &#39;asset_name&#39;: _token_id,
            &#39;amount&#39;: amount
        })

    def freeze_balance(self, amount, duration, resource, account=None):
        &#34;&#34;&#34;
        Freezes an amount of TRX.
        Will give bandwidth OR Energy and TRON Power(voting rights)
        to the owner of the frozen tokens.

        Args:
            amount (int): number of frozen trx
            duration (int): duration in days to be frozen
            resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
            account (str): address that is freezing trx account

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if resource not in (&#39;BANDWIDTH&#39;, &#39;ENERGY&#39;,):
            raise InvalidTronError(&#39;Invalid resource provided: Expected &#34;BANDWIDTH&#34; or &#34;ENERGY&#34;&#39;)

        if not is_integer(amount) or amount &lt;= 0:
            raise InvalidTronError(&#39;Invalid amount provided&#39;)

        if not is_integer(duration) or duration &lt; 3:
            raise InvalidTronError(&#39;Invalid duration provided, minimum of 3 days&#39;)

        if not self.tron.isAddress(account):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/freezebalance&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(account),
            &#39;frozen_balance&#39;: self.tron.toSun(amount),
            &#39;frozen_duration&#39;: int(duration),
            &#39;resource&#39;: resource
        })

        if &#39;Error&#39; in response:
            raise TronError(response[&#39;Error&#39;])

        return response

    def unfreeze_balance(self, resource=&#39;BANDWIDTH&#39;, account=None):
        &#34;&#34;&#34;
        Unfreeze TRX that has passed the minimum freeze duration.
        Unfreezing will remove bandwidth and TRON Power.

        Args:
            resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
            account (str): address that is freezing trx account

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if resource not in (&#39;BANDWIDTH&#39;, &#39;ENERGY&#39;,):
            raise InvalidTronError(&#39;Invalid resource provided: Expected &#34;BANDWIDTH&#34; or &#34;ENERGY&#34;&#39;)

        if not self.tron.isAddress(account):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/unfreezebalance&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(account),
            &#39;resource&#39;: resource
        })

        if &#39;Error&#39; in response:
            raise ValueError(response[&#39;Error&#39;])

        return response

    def purchase_token(self, to: str, token_id: str, amount: int, buyer=None):
        &#34;&#34;&#34;Purchase a Token
        Creates an unsigned ICO token purchase transaction.

        Args:
            to (str): is the address of the Token issuer
            token_id (str): is the name of the token
            amount (int): is the number of tokens created
            buyer (str): is the address of the Token owner

        &#34;&#34;&#34;

        if buyer is None:
            buyer = self.tron.default_address.hex

        if not self.tron.isAddress(to):
            raise InvalidAddress(&#39;Invalid to address provided&#39;)

        if not len(token_id):
            raise ValueError(&#39;Invalid token ID provided&#39;)

        if amount &lt;= 0:
            raise ValueError(&#39;Invalid amount provided&#39;)

        _to = self.tron.address.to_hex(to)
        _from = self.tron.address.to_hex(buyer)

        return self.tron.manager.request(&#39;/wallet/participateassetissue&#39;, {
            &#39;to_address&#39;: _to,
            &#39;owner_address&#39;: _from,
            &#39;asset_name&#39;: self.tron.toHex(text=token_id),
            &#39;amount&#39;: int(amount)
        })

    def withdraw_block_rewards(self, address: str = None):
        &#34;&#34;&#34;Withdraw block rewards
        Creates an unsigned Super Representative award balance withdraw transaction.

        Args:
            address (str): Optional address to withdraw from.

        &#34;&#34;&#34;
        if not address:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise InvalidAddress(&#39;Invalid address provided&#39;)

        return self.tron.manager.request(&#39;/wallet/withdrawbalance&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(address)
        })

    def apply_for_sr(self, url, address=None):
        &#34;&#34;&#34;Apply to become a super representative

        Args:
            url (str): official website address
            address (str): address

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if address is None:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise TronError(&#39;Invalid address provided&#39;)

        if not is_valid_url(url):
            raise TronError(&#39;Invalid url provided&#39;)

        return self.tron.manager.request(&#39;/wallet/createwitness&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(address),
            &#39;url&#39;: self.tron.toHex(text=url)
        })

    def vote(self, votes: List[Tuple[str, int]], voter_address: str = None):
        &#34;&#34;&#34;Vote
        Vote on the super representative

        Args:
            votes (dict): dictionary of SR address : vote count key-value pair
            voter_address: voter address

        Examples:
            &gt;&gt;&gt; from tronpytool import Tron
            &gt;&gt;&gt; data = [
            &gt;&gt;&gt;     (&#39;TRJpw2uqohP7FUmAEJgt57wakRn6aGQU6Z&#39;, 1)
            &gt;&gt;&gt; ]
            &gt;&gt;&gt; tron = Tron()
            &gt;&gt;&gt; tron.transaction.vote(data)

        &#34;&#34;&#34;
        if voter_address is None:
            voter_address = self.tron.default_address.hex

        _view_vote = []

        # We create a cycle to check all the received data for voting.
        for sr_address, vote_count in votes:
            if not self.tron.isAddress(sr_address):
                raise InvalidAddress(
                    &#39;Invalid SR address provided: &#39; + sr_address
                )

            if not is_integer(vote_count) or vote_count &lt;= 0:
                raise ValueError(
                    &#39;Invalid vote count provided for SR: &#39; + sr_address
                )

            _view_vote.append({
                &#39;vote_address&#39;: self.tron.address.to_hex(sr_address),
                &#39;vote_count&#39;: int(vote_count)
            })

        return self.tron.manager.request(&#39;/wallet/votewitnessaccount&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(voter_address),
            &#39;votes&#39;: _view_vote
        })

    def create_proposal(self, parameters: Any, issuer_address=None):
        &#34;&#34;&#34;Creates a proposal to modify the network.
        Can only be created by a current Super Representative.

        Args:
            parameters (Any): proposal parameters
            issuer_address: owner address

        Examples:
            &gt;&gt;&gt; from tronpytool import Tron
            &gt;&gt;&gt; data = [
            &gt;&gt;&gt;     {&#39;key&#39;: 1, &#39;value&#39;: 2},
            &gt;&gt;&gt;     {&#39;key&#39;: 1, &#39;value&#39;: 2}
            &gt;&gt;&gt; ]
            &gt;&gt;&gt; tron = Tron()
            &gt;&gt;&gt; tron.transaction.create_proposal(data)


        &#34;&#34;&#34;
        if issuer_address is None:
            issuer_address = self.tron.default_address.hex

        if not self.tron.isAddress(issuer_address):
            raise InvalidAddress(&#39;Invalid issuerAddress provided&#39;)

        return self.tron.manager.request(&#39;/wallet/proposalcreate&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(issuer_address),
            &#39;parameters&#39;: parameters
        })

    def vote_proposal(self, proposal_id, has_approval, voter_address=None):
        &#34;&#34;&#34;Proposal approval

        Args:
            proposal_id (int): proposal id
            has_approval (bool): Approved
            voter_address (str): Approve address

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if voter_address is None:
            voter_address = self.tron.default_address.hex

        if not self.tron.isAddress(voter_address):
            raise TronError(&#39;Invalid voter_address address provided&#39;)

        if not is_integer(proposal_id) or proposal_id &lt; 0:
            raise TronError(&#39;Invalid proposal_id provided&#39;)

        if not is_boolean(has_approval):
            raise TronError(&#39;Invalid has_approval provided&#39;)

        return self.tron.manager.request(&#39;/wallet/proposalapprove&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(voter_address),
            &#39;proposal_id&#39;: int(proposal_id),
            &#39;is_add_approval&#39;: bool(has_approval)
        })

    def delete_proposal(self, proposal_id: int, issuer_address: str = None):
        &#34;&#34;&#34;Delete proposal

        Args:
            proposal_id (int): proposal id
            issuer_address (str): delete the person&#39;s address

        Results:
            Delete the proposal&#39;s transaction

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if issuer_address is None:
            issuer_address = self.tron.default_address.hex

        if not self.tron.isAddress(issuer_address):
            raise InvalidTronError(&#39;Invalid issuer_address provided&#39;)

        if not isinstance(proposal_id, int) or proposal_id &lt; 0:
            raise InvalidTronError(&#39;Invalid proposal_id provided&#39;)

        return self.tron.manager.request(&#39;/wallet/proposaldelete&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(issuer_address),
            &#39;proposal_id&#39;: int(proposal_id)
        })

    def update_account(self, account_name, account: str = None):
        &#34;&#34;&#34;Modify account name

        Note: Username is allowed to edit only once.

        Args:
            account_name (str): name of the account
            account (str): address

        Returns:
            modified Transaction Object

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if not is_string(account_name):
            raise ValueError(&#39;Name must be a string&#39;)

        if not self.tron.isAddress(account):
            raise TronError(&#39;Invalid origin address provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/updateaccount&#39;, {
            &#39;account_name&#39;: self.tron.toHex(text=account_name),
            &#39;owner_address&#39;: self.tron.address.to_hex(account)
        })

        return response

    def create_smart_contract(self, **kwargs):
        &#34;&#34;&#34;Deploy Contract

        Deploys a contract.
        Returns TransactionExtention, which contains an unsigned transaction.

        Example:
        .. code-block:: python
            &gt;&gt;&gt; from tronpytool import Tron
            &gt;&gt;&gt;
            &gt;&gt;&gt; tron = Tron()
            &gt;&gt;&gt; tron.transaction_builder.create_smart_contract(
            &gt;&gt;&gt;    fee_limit=10**9,
            &gt;&gt;&gt;    call_value=0,
            &gt;&gt;&gt;    consume_user_resource_percent=10
            &gt;&gt;&gt; )

        Args:
            **kwargs: Transaction parameters for the deployment
            transaction as a dict

        &#34;&#34;&#34;

        if &#39;bytecode&#39; not in kwargs:
            raise ValueError(
                &#34;Cannot deploy a contract that does not have &#39;bytecode&#39; associated &#34;
                &#34;with it&#34;
            )

        # Maximum TRX consumption, measured in SUN (1 TRX = 1,000,000 SUN).
        fee_limit = kwargs.setdefault(&#39;fee_limit&#39;, 0)
        # The same as User Pay Ratio.
        # The percentage of resources specified for users who use this contract.
        # This field accepts integers between [0, 100].
        user_fee_percentage = kwargs.setdefault(&#39;consume_user_resource_percent&#39;, 0)
        # Amount of TRX transferred with this transaction, measured in SUN (1TRX = 1,000,000 SUN)
        call_value = kwargs.setdefault(&#39;call_value&#39;, 0)
        # Contract owner address, converted to a hex string
        owner_address = kwargs.setdefault(&#39;owner_address&#39;, self.tron.default_address.hex)
        # The max energy which will be consumed by the owner
        # in the process of excution or creation of the contract,
        # is an integer which should be greater than 0.
        origin_energy_limit = kwargs.setdefault(&#39;origin_energy_limit&#39;, 10000000)

        # parameters = kwargs.setdefault(&#39;parameters&#39;, []).append()
        # parameters = kwargs.setdefault(&#39;visible&#39;, []).append()
        # parameters = kwargs.setdefault(&#39;permission_id&#39;, []).append()

        if not is_integer(user_fee_percentage) and not user_fee_percentage:
            user_fee_percentage = 100

        if not is_hex(kwargs.get(&#39;bytecode&#39;)):
            raise ValueError(&#39;Invalid bytecode provided&#39;)

        if not is_integer(fee_limit) or fee_limit &lt;= 0 or \
                fee_limit &gt; 1000000000:
            raise ValueError(&#39;Invalid fee limit provided&#39;)

        if not is_integer(call_value) or call_value &lt; 0:
            raise ValueError(&#39;Invalid call value provided&#39;)

        if not is_integer(user_fee_percentage) or user_fee_percentage &lt; 0 or \
                user_fee_percentage &gt; 100:
            raise ValueError(&#39;Invalid user fee percentage provided&#39;)

        if not is_integer(origin_energy_limit) or origin_energy_limit &lt; 0:
            return ValueError(&#39;Invalid origin_energy_limit provided&#39;)

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid issuer address provided&#39;)

        # We write all the results in one object
        transaction = dict(**kwargs)
        transaction.setdefault(&#39;owner_address&#39;, self.tron.address.to_hex(owner_address))

        return self.tron.manager.request(&#39;/wallet/deploycontract&#39;, transaction)

    def trigger_smart_contract_constant(self, kv: dict):

        contract_address = kv.setdefault(&#39;contract_address&#39;, None)
        function_selector = kv.setdefault(&#39;function_selector&#39;, None)

        issuer_address = kv.setdefault(&#39;issuer_address&#39;, self.tron.default_address.hex)
        call_value = kv.setdefault(&#39;call_value&#39;, 0)
        fee_limit = kv.setdefault(&#39;fee_limit&#39;, 1000000000)
        token_value = kv.setdefault(&#39;token_value&#39;, 0)
        token_id = kv.setdefault(&#39;token_id&#39;, 0)

        if not is_integer(token_value) or token_value &lt; 0:
            raise ValueError(&#39;Invalid options.tokenValue provided&#39;)

        if not is_integer(token_id) or token_id &lt; 0:
            raise ValueError(&#39;Invalid options.tokenId provided&#39;)

        if not self.tron.isAddress(contract_address):
            raise InvalidAddress(&#39;Invalid contract address provided&#39;)

        if not is_string(function_selector):
            raise ValueError(&#39;Invalid function selector provided&#39;)

        if not is_integer(call_value) or call_value &lt; 0:
            raise ValueError(&#39;Invalid call value provided&#39;)

        if not is_integer(fee_limit) or fee_limit &lt;= 0 or fee_limit &gt; 1000000000:
            raise ValueError(&#39;Invalid fee limit provided&#39;)

        &#34;&#34;&#34;remove all the spaces&#34;&#34;&#34;
        function_selector = function_selector.replace(&#39;/\s*/g&#39;, &#39;&#39;)

        if hasattr(kv, &#34;parameters&#34;) and len(kv[&#39;parameters&#39;]) &gt; 0:
            types = []
            values = []
            parameters = kv[&#39;parameters&#39;]
            for abi in parameters:
                if &#39;type&#39; not in abi or not is_string(abi[&#39;type&#39;]):
                    raise ValueError(&#39;Invalid parameter type provided: &#39; + abi[&#39;type&#39;])

                if abi[&#39;type&#39;] == &#39;address&#39;:
                    abi[&#39;value&#39;] = self.tron.address.to_hex(abi[&#39;value&#39;]).replace(&#39;41&#39;, &#39;0x&#39;, 1)

                types.append(abi[&#39;type&#39;])
                values.append(abi[&#39;value&#39;])

            try:
                parameters = encode_hex(encode_abi(types, values)).replace(&#39;0x&#39;, &#39;&#39;, 2)
            except ValueError as ex:
                print(ex)

        else:
            parameters = []

        self.debug_input_kv(kv)

        data = {
            &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
            &#39;owner_address&#39;: issuer_address.hex,
            &#39;function_selector&#39;: function_selector,
            &#39;fee_limit&#39;: int(fee_limit),
            &#39;call_value&#39;: int(call_value),
            &#39;parameter&#39;: parameters
        }

        if token_value:
            data[&#39;call_token_value&#39;] = int(token_value)

        if token_id:
            data[&#39;token_id&#39;] = int(token_id)

        self.debug_url_req(data)

        return self.tron.manager.request(&#39;/wallet/triggerconstantcontract&#39;, kv)

    def trigger_smart_contract(self, kv: dict):

        &#34;&#34;&#34;Trigger Smart Contract
        Calls a function on a contract

        Args:
            **kv: Fill in the required parameters

        Examples:
            &gt;&gt;&gt; tron = Tron()
            &gt;&gt;&gt; tron.transaction_builder.trigger_smart_contract(
            &gt;&gt;&gt;     contract_address=&#39;413c8143e98b3e2fe1b1a8fb82b34557505a752390&#39;,
            &gt;&gt;&gt;     function_selector=&#39;set(uint256,uint256)&#39;,
            &gt;&gt;&gt;     fee_limit=30000,
            &gt;&gt;&gt;     call_value=0,
            &gt;&gt;&gt;     parameters=[
            &gt;&gt;&gt;        {&#39;type&#39;: &#39;int256&#39;, &#39;value&#39;: 1},
            &gt;&gt;&gt;        {&#39;type&#39;: &#39;int256&#39;, &#39;value&#39;: 1}])

        Returns:
            TransactionExtention, TransactionExtention contains unsigned Transaction
        &#34;&#34;&#34;

        contract_address = kv.setdefault(&#39;contract_address&#39;, None)
        function_selector = kv.setdefault(&#39;function_selector&#39;, None)

        issuer_address = kv.setdefault(&#39;issuer_address&#39;, self.tron.default_address.hex)
        call_value = kv.setdefault(&#39;call_value&#39;, 0)
        fee_limit = kv.setdefault(&#39;fee_limit&#39;, 1000000000)
        token_value = kv.setdefault(&#39;token_value&#39;, 0)
        token_id = kv.setdefault(&#39;token_id&#39;, 0)
        parameters = kv.setdefault(&#39;parameters&#39;, [])

        if not is_integer(token_value) or token_value &lt; 0:
            raise ValueError(&#39;Invalid options.tokenValue provided&#39;)

        if not is_integer(token_id) or token_id &lt; 0:
            raise ValueError(&#39;Invalid options.tokenId provided&#39;)

        if not self.tron.isAddress(contract_address):
            raise InvalidAddress(&#39;Invalid contract address provided&#39;)

        if not is_string(function_selector):
            raise ValueError(&#39;Invalid function selector provided&#39;)

        if not is_integer(call_value) or call_value &lt; 0:
            raise ValueError(&#39;Invalid call value provided&#39;)

        if not is_integer(fee_limit) or fee_limit &lt;= 0 or fee_limit &gt; 1000000000:
            raise ValueError(&#39;Invalid fee limit provided&#39;)

        &#34;&#34;&#34;remove all the spaces&#34;&#34;&#34;
        function_selector = function_selector.replace(&#39;/\s*/g&#39;, &#39;&#39;)
        print(parameters)
        print(&#34;-------------- this is the last parameters.. &#34;)
        if len(parameters) &gt; 0:
            types = []
            values = []
            for abi in parameters:
                if &#39;type&#39; not in abi or not is_string(abi[&#39;type&#39;]):
                    raise ValueError(&#39;Invalid parameter type provided: &#39; + abi[&#39;type&#39;])
                if abi[&#39;type&#39;] == &#39;address&#39;:
                    abi[&#39;value&#39;] = self.tron.address.to_hex(abi[&#39;value&#39;]).replace(&#39;41&#39;, &#39;0x&#39;, 1)
                types.append(abi[&#39;type&#39;])
                values.append(abi[&#39;value&#39;])

            try:
                parameters = encode_hex(encode_abi(types, values)).replace(&#39;0x&#39;, &#39;&#39;, 2)
            except ValueError as ex:
                print(ex)

        else:
            parameters = &#39;&#39;

        data = {
            &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
            &#39;owner_address&#39;: issuer_address.hex,
            &#39;function_selector&#39;: function_selector,
            &#39;fee_limit&#39;: int(fee_limit),
            &#39;call_value&#39;: int(call_value),
            &#39;parameter&#39;: parameters
        }

        # if parameters is &#39;&#39;:
        #    data.pop(&#39;parameter&#39;)
        self.debug_input_kv(kv)
        if token_value:
            data[&#39;call_token_value&#39;] = int(token_value)

        if token_id:
            data[&#39;token_id&#39;] = int(token_id)
        self.debug_url_req(data)
        return self.tron.manager.request(&#39;/wallet/triggersmartcontract&#39;, data)

    def debug_url_req(self, data):
        if self.debug:
            print(&#34;==data load on request url&#34;)
            print(data)
            print(&#34;==end&#34;)

    def debug_input_kv(self, data):
        if self.debug:
            print(&#34;==checking input data&#34;)
            print(data)
            print(&#34;==end&#34;)

    def create_trx_exchange(self,
                            token_name: str,
                            token_balance: int,
                            trx_balance: int,
                            account: str = None):
        &#34;&#34;&#34;Create an exchange between a token and TRX.
        Token Name should be a CASE SENSITIVE string.
        Note: PLEASE VERIFY THIS ON TRONSCAN.

        Args:
            token_name (str): Token Name
            token_balance (int): balance of the first token
            trx_balance (int): balance of the second token
            account (str): Owner Address
        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if not self.tron.isAddress(account):
            raise TronError(&#39;Invalid address provided&#39;)

        if token_balance &lt;= 0 or trx_balance &lt;= 0:
            raise TronError(&#39;Invalid amount provided&#39;)

        return self.tron.manager.request(&#39;/wallet/exchangecreate&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(account),
            &#39;first_token_id&#39;: self.tron.toHex(text=token_name),
            &#39;first_token_balance&#39;: token_balance,
            &#39;second_token_id&#39;: &#39;5f&#39;,
            &#39;second_token_balance&#39;: trx_balance
        })

    def create_token_exchange(self,
                              first_token_name: str,
                              first_token_balance: int,
                              second_token_name: str,
                              second_token_balance: int,
                              owner_address: str = None):
        &#34;&#34;&#34;Create an exchange between a token and another token.
        DO NOT USE THIS FOR TRX.
        Token Names should be a CASE SENSITIVE string.

        Args:
            first_token_name (str): the id of the first token
            first_token_balance (int): balance of the first token
            second_token_name (str): the id of the second token
            second_token_balance (int): balance of the second token
            owner_address: owner address

        &#34;&#34;&#34;
        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid address provided&#39;)

        if second_token_balance &lt;= 0 or first_token_balance &lt;= 0:
            raise ValueError(&#39;Invalid amount provided&#39;)

        return self.tron.manager.request(&#39;/wallet/exchangecreate&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;first_token_id&#39;: self.tron.toHex(text=first_token_name),
            &#39;first_token_balance&#39;: first_token_balance,
            &#39;second_token_id&#39;: self.tron.toHex(text=second_token_name),
            &#39;second_token_balance&#39;: second_token_balance
        })

    def inject_exchange_tokens(self,
                               exchange_id: int,
                               token_name: str,
                               token_amount: int = 0,
                               owner_address: str = None):
        &#34;&#34;&#34;Adds tokens into a bancor style exchange.
        Will add both tokens at market rate.

        Args:
            exchange_id (int): non-negative integer exchange id
            token_name (str): token name
            token_amount (int): amount of token
            owner_address (str): token owner address in hex

        &#34;&#34;&#34;
        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

        if exchange_id &lt; 0:
            raise ValueError(&#39;Invalid exchange_id provided&#39;)

        if token_amount &lt; 1:
            raise ValueError(&#39;Invalid token_amount provided&#39;)

        return self.tron.manager.request(&#39;/wallet/exchangeinject&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;exchange_id&#39;: exchange_id,
            &#39;token_id&#39;: self.tron.toHex(text=token_name),
            &#39;quant&#39;: token_amount
        })

    def create_token(self, **kwargs):
        &#34;&#34;&#34;Issue Token

        Issuing a token on the TRON Protocol can be done by anyone
        who has at least 1024 TRX in their account.
        When a token is issued it will be shown on the token overview page.
        Users can then participate within the issuing time and exchange their
        TRX for tokens.After issuing the token your account will
        receive the amount of tokens equal to the total supply.
        When other users exchange their TRX for tokens then the tokens
        will be withdrawn from your account and you will receive
        TRX equal to the specified exchange rate.


        Args:
            **kwargs: Fill in the required parameters

        Examples:

            &gt;&gt;&gt; start_func = datetime.now()
            &gt;&gt;&gt; start = int(start_func.timestamp() * 1000)
            &gt;&gt;&gt;
            &gt;&gt;&gt; end_func = datetime.now() + timedelta(days=2)
            &gt;&gt;&gt; end = int(end_func.timestamp() * 1000)
            &gt;&gt;&gt;
            &gt;&gt;&gt; opt = {
            &gt;&gt;&gt;     &#39;name&#39;: &#39;Tron&#39;,
            &gt;&gt;&gt;     &#39;abbreviation&#39;: &#39;TRX&#39;,
            &gt;&gt;&gt;     &#39;description&#39;: &#39;Hello World&#39;,
            &gt;&gt;&gt;     &#39;url&#39;: &#39;https://github.com&#39;,
            &gt;&gt;&gt;     &#39;totalSupply&#39;: 25000000,
            &gt;&gt;&gt;     &#39;frozenAmount&#39;: 1,
            &gt;&gt;&gt;     &#39;frozenDuration&#39;: 2,
            &gt;&gt;&gt;     &#39;freeBandwidth&#39;: 10000,
            &gt;&gt;&gt;     &#39;freeBandwidthLimit&#39;: 10000,
            &gt;&gt;&gt;     &#39;saleStart&#39;: start,
            &gt;&gt;&gt;     &#39;saleEnd&#39;: end,
            &gt;&gt;&gt;     &#39;voteScore&#39;: 1
            &gt;&gt;&gt; }

        &#34;&#34;&#34;
        issuer_address = kwargs.setdefault(
            &#39;issuer_address&#39;, self.tron.default_address.hex
        )

        if not self.tron.isAddress(issuer_address):
            raise TronError(&#39;Invalid issuer address provided&#39;)

        total_supply = kwargs.setdefault(&#39;totalSupply&#39;, 0)
        trx_ratio = kwargs.setdefault(&#39;trxRatio&#39;, 1)
        token_ratio = kwargs.setdefault(&#39;tokenRatio&#39;, 1)
        sale_start = kwargs.setdefault(
            &#39;saleStart&#39;, START_DATE
        )
        free_bandwidth = kwargs.setdefault(&#39;freeBandwidth&#39;, 0)
        free_bandwidth_limit = kwargs.setdefault(&#39;freeBandwidthLimit&#39;, 0)
        frozen_amount = kwargs.setdefault(&#39;frozenAmount&#39;, 0)
        frozen_duration = kwargs.setdefault(&#39;frozenDuration&#39;, 0)
        vote_score = kwargs.setdefault(&#39;voteScore&#39;, 0)
        precision = kwargs.setdefault(&#39;precision&#39;, 0)

        if not is_string(kwargs.get(&#39;name&#39;)):
            raise ValueError(&#39;Invalid token name provided&#39;)

        if not is_string(kwargs.get(&#39;abbreviation&#39;)):
            raise ValueError(&#39;Invalid token abbreviation provided&#39;)

        if not is_integer(total_supply) or total_supply &lt;= 0:
            raise ValueError(&#39;Invalid supply amount provided&#39;)

        if not is_integer(trx_ratio) or trx_ratio &lt;= 0:
            raise ValueError(&#39;TRX ratio must be a positive integer&#39;)

        if not is_integer(token_ratio) or token_ratio &lt;= 0:
            raise ValueError(&#39;Token ratio must be a positive integer&#39;)

        if not is_integer(vote_score) or vote_score &lt;= 0:
            raise ValueError(&#39;voteScore must be a positive integer greater than 0&#39;)

        if not is_integer(precision) or precision &lt;= 0 or precision &gt; 6:
            raise ValueError(&#39;precision must be a positive integer &gt; 0 and &lt;= 6&#39;)

        if not is_integer(sale_start) or sale_start &lt; START_DATE:
            raise ValueError(&#39;Invalid sale start timestamp provided&#39;)

        if not is_integer(kwargs.get(&#39;saleEnd&#39;)) or \
                kwargs.get(&#39;saleEnd&#39;) &lt;= sale_start:
            raise ValueError(&#39;Invalid sale end timestamp provided&#39;)

        if not is_string(kwargs.get(&#39;description&#39;)):
            raise ValueError(&#39;Invalid token description provided&#39;)

        if not is_valid_url(kwargs.get(&#39;url&#39;)):
            raise ValueError(&#39;Invalid token url provided&#39;)

        if not is_integer(free_bandwidth) or free_bandwidth &lt; 0:
            raise ValueError(&#39;Invalid free bandwidth amount provided&#39;)

        if not is_integer(free_bandwidth_limit) or free_bandwidth_limit &lt; 0 \
                or (free_bandwidth and not free_bandwidth_limit):
            raise ValueError(&#39;Invalid free bandwidth limit provided&#39;)

        if not is_integer(frozen_amount) or frozen_amount &lt; 0 \
                or (not frozen_duration and frozen_amount):
            raise ValueError(&#39;Invalid frozen supply provided&#39;)

        if not is_integer(frozen_duration) or frozen_duration &lt; 0 \
                or (frozen_duration and not frozen_amount):
            raise ValueError(&#39;Invalid frozen duration provided&#39;)

        frozen_supply = {
            &#39;frozen_amount&#39;: int(frozen_amount),
            &#39;frozen_days&#39;: int(frozen_duration)
        }

        response = self.tron.manager.request(&#39;/wallet/createassetissue&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(issuer_address),
            &#39;name&#39;: self.tron.toHex(text=kwargs.get(&#39;name&#39;)),
            &#39;abbr&#39;: self.tron.toHex(text=kwargs.get(&#39;abbreviation&#39;)),
            &#39;description&#39;: self.tron.toHex(text=kwargs.get(&#39;description&#39;)),
            &#39;url&#39;: self.tron.toHex(text=kwargs.get(&#39;url&#39;)),
            &#39;total_supply&#39;: int(total_supply),
            &#39;trx_num&#39;: int(trx_ratio),
            &#39;num&#39;: int(token_ratio),
            &#39;start_time&#39;: int(sale_start),
            &#39;end_time&#39;: int(kwargs.get(&#39;saleEnd&#39;)),
            &#39;free_asset_net_limit&#39;: int(free_bandwidth),
            &#39;public_free_asset_net_limit&#39;: int(free_bandwidth_limit),
            &#39;frozen_supply&#39;: frozen_supply,
            &#39;vote_score&#39;: vote_score,
            &#39;precision&#39;: precision
        })

        return response

    def withdraw_exchange_tokens(self,
                                 exchange_id: int,
                                 token_name: str,
                                 token_amount: int = 0,
                                 owner_address: str = None):
        &#34;&#34;&#34;Withdraws tokens from a bancor style exchange.
        Will withdraw at market rate both tokens.

        Args:
            exchange_id (int): non-negative integer exchange id
            token_name (str): token name
            token_amount (int): number of tokens withdraw
            owner_address (str): owner address in hex

        &#34;&#34;&#34;
        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

        if exchange_id &lt; 0:
            raise ValueError(&#39;Invalid exchange_id provided&#39;)

        if token_amount &lt; 1:
            raise ValueError(&#39;Invalid token_amount provided&#39;)

        return self.tron.manager.request(&#39;/wallet/exchangewithdraw&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;exchange_id&#39;: exchange_id,
            &#39;token_id&#39;: self.tron.toHex(text=token_name),
            &#39;quant&#39;: token_amount
        })

    def trade_exchange_tokens(self,
                              exchange_id: int,
                              token_name: str,
                              token_amount_sold: int = 0,
                              token_amount_expected: int = 0,
                              owner_address: str = None):
        &#34;&#34;&#34;Trade tokens on a bancor style exchange.
        Expected value is a validation and used to cap the total amt of token 2 spent.

        Args:
            exchange_id (int): non-negative integer exchange id
            token_name (str): token name
            token_amount_sold (int): amount f token actually sold
            token_amount_expected (int): amount of token expected
            owner_address (str): token owner address in hex

        &#34;&#34;&#34;

        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

        if exchange_id &lt; 0:
            raise ValueError(&#39;Invalid exchange_id provided&#39;)

        if token_amount_sold &lt; 1:
            raise ValueError(&#39;Invalid token_amount_sold provided&#39;)

        if token_amount_expected &lt; 1:
            raise ValueError(&#39;Invalid token_amount_expected provided&#39;)

        return self.tron.manager.request(&#39;/wallet/exchangewithdraw&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;exchange_id&#39;: exchange_id,
            &#39;token_id&#39;: self.tron.toHex(text=token_name),
            &#39;quant&#39;: token_amount_sold,
            &#39;expected&#39;: token_amount_expected
        })

    def update_setting(self,
                       contract_address,
                       user_fee_percentage,
                       owner_address: str = None):
        &#34;&#34;&#34;Update userFeePercentage.

        Args:
            contract_address (str): the address of the contract to be modified
            user_fee_percentage (int): the percentage of resources specified for users using this contract
            owner_address (str): is the address of the creator

        Returns:
            Contains unsigned transaction Transaction
        &#34;&#34;&#34;

        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

        if not self.tron.isAddress(contract_address):
            raise InvalidAddress(&#39;Invalid contract_address provided&#39;)

        if not is_integer(user_fee_percentage) or user_fee_percentage &lt; 0 or \
                user_fee_percentage &gt; 100:
            raise ValueError(&#39;Invalid user_fee_percentage provided&#39;)

        return self.tron.manager.request(&#39;wallet/updatesetting&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
            &#39;consume_user_resource_percent&#39;: user_fee_percentage
        })

    def update_energy_limit(self,
                            contract_address,
                            origin_energy_limit,
                            owner_address: str = None):
        &#34;&#34;&#34;Update energy limit.

        Args:
            contract_address (str): The address of the contract to be modified
            origin_energy_limit (int): The maximum energy set by the creator that is created
            owner_address (str): Is the address of the creator

        Returns:
            Contains unsigned transaction Transaction
        &#34;&#34;&#34;

        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

        if not self.tron.isAddress(contract_address):
            raise InvalidAddress(&#39;Invalid contractAddress provided&#39;)

        if not is_integer(origin_energy_limit) or origin_energy_limit &lt; 0 or \
                origin_energy_limit &gt; 10000000:
            raise ValueError(&#39;Invalid originEnergyLimit  provided&#39;)

        return self.tron.manager.request(&#39;wallet/updateenergylimit&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
            &#39;origin_energy_limit&#39;: origin_energy_limit
        })

    def check_permissions(self, permissions, _type):
        if permissions is not None:
            if permissions[&#39;type&#39;] != _type or \
                    not permissions[&#39;permission_name&#39;] or \
                    not is_string(permissions[&#39;permission_name&#39;]) or \
                    not is_integer(permissions[&#39;threshold&#39;]) or \
                    permissions[&#39;threshold&#39;] &lt; 1 or not permissions[&#39;keys&#39;]:
                return False

        for key in permissions[&#39;key&#39;]:
            if not self.tron.isAddress(key[&#39;address&#39;]) or \
                    not is_integer(key[&#39;weight&#39;]) or \
                    key[&#39;weight&#39;] &gt; permissions[&#39;threshold&#39;] or \
                    key[&#39;weight&#39;] &lt; 1 or _type == 2 and not permissions[&#39;operations&#39;]:
                return False

        return True

    def update_account_permissions(self, owner_address=None,
                                   owner_permissions=None,
                                   witness_permissions=None,
                                   actives_permissions=None
                                   ):
        &#34;&#34;&#34;Role: update user permissions (for multi-signature)

        Args:
            owner_address (str): The address of the account whose permissions are to be modified
            owner_permissions: Modified owner permission
            witness_permissions: Modified witness permission (if it is a witness)
            actives_permissions: Modified actives permission
        &#34;&#34;&#34;

        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.check_permissions(owner_permissions, 0):
            raise InvalidTronError(&#39;Invalid ownerPermissions provided&#39;)

        if not self.check_permissions(witness_permissions, 1):
            raise InvalidTronError(&#39;Invalid witnessPermissions provided&#39;)

        for actives_permission in actives_permissions:
            if not self.check_permissions(actives_permission, 2):
                raise InvalidTronError(&#39;Invalid activesPermissions provided&#39;)

        data = {
            owner_address: owner_address
        }

        if owner_permissions:
            data[&#39;owner&#39;] = owner_permissions

        if witness_permissions:
            data[&#39;witness&#39;] = witness_permissions

        if actives_permissions:
            if len(actives_permissions) == 1:
                data[&#39;actives&#39;] = actives_permissions[0]
            else:
                data[&#39;actives&#39;] = actives_permissions

        return self.tron.manager.request(&#39;wallet/accountpermissionupdate&#39;, data)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tronpytool.transactionbuilder.TransactionBuilder"><code class="flex name class">
<span>class <span class="ident">TransactionBuilder</span></span>
<span>(</span><span>tron)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TransactionBuilder(object):
    debug = True

    def __init__(self, tron):
        self.tron = tron

    def setDebug(self, b: bool) -&gt; None:
        self.debug = b

    def send_transaction(self, to, amount, account=None):
        &#34;&#34;&#34;Creates a transaction of transfer.
        If the recipient address does not exist, a corresponding account will be created.

        Args:
            to (str): to address
            amount (float): amount
            account (str): from address

        Returns:
            Transaction contract data

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if not self.tron.isAddress(to):
            raise InvalidTronError(&#39;Invalid recipient address provided&#39;)

        if not isinstance(amount, float) or amount &lt;= 0:
            raise InvalidTronError(&#39;Invalid amount provided&#39;)

        _to = self.tron.address.to_hex(to)
        _from = self.tron.address.to_hex(account)

        if _to == _from:
            raise TronError(&#39;Cannot transfer TRX to the same account&#39;)

        response = self.tron.manager.request(&#39;/wallet/createtransaction&#39;, {
            &#39;to_address&#39;: _to,
            &#39;owner_address&#39;: _from,
            &#39;amount&#39;: self.tron.toSun(amount)
        })

        return response

    def send_token(self, to, amount, token_id, account=None):
        &#34;&#34;&#34;Transfer Token

        Args:
            to (str): is the recipient address
            amount (int): is the amount of token to transfer. must be integer instead of float
            token_id (any): Token Name and id
            account: (str): is the address of the withdrawal account

        Returns:
            Token transfer Transaction raw data

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if not self.tron.isAddress(to):
            raise InvalidTronError(&#39;Invalid recipient address provided&#39;)

        if not isinstance(amount, int) or amount &lt;= 0:
            raise InvalidTronError(&#39;Invalid amount provided&#39;)

        if not token_id:
            raise InvalidTronError(&#39;Invalid token ID provided&#39;)

        if not self.tron.isAddress(account):
            raise InvalidTronError(&#39;Invalid origin address provided&#39;)

        _to = self.tron.address.to_hex(to)
        _from = self.tron.address.to_hex(account)
        _token_id = self.tron.toHex(text=str(token_id))

        if _to == _from:
            raise TronError(&#39;Cannot transfer TRX to the same account&#39;)

        # In case if &#34;TRX&#34; is specified, we redirect to another method.
        if is_string(token_id) and token_id.upper() == &#39;TRX&#39;:
            return self.send_transaction(_to, amount, _from)

        return self.tron.manager.request(&#39;/wallet/transferasset&#39;, {
            &#39;to_address&#39;: _to,
            &#39;owner_address&#39;: _from,
            &#39;asset_name&#39;: _token_id,
            &#39;amount&#39;: amount
        })

    def freeze_balance(self, amount, duration, resource, account=None):
        &#34;&#34;&#34;
        Freezes an amount of TRX.
        Will give bandwidth OR Energy and TRON Power(voting rights)
        to the owner of the frozen tokens.

        Args:
            amount (int): number of frozen trx
            duration (int): duration in days to be frozen
            resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
            account (str): address that is freezing trx account

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if resource not in (&#39;BANDWIDTH&#39;, &#39;ENERGY&#39;,):
            raise InvalidTronError(&#39;Invalid resource provided: Expected &#34;BANDWIDTH&#34; or &#34;ENERGY&#34;&#39;)

        if not is_integer(amount) or amount &lt;= 0:
            raise InvalidTronError(&#39;Invalid amount provided&#39;)

        if not is_integer(duration) or duration &lt; 3:
            raise InvalidTronError(&#39;Invalid duration provided, minimum of 3 days&#39;)

        if not self.tron.isAddress(account):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/freezebalance&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(account),
            &#39;frozen_balance&#39;: self.tron.toSun(amount),
            &#39;frozen_duration&#39;: int(duration),
            &#39;resource&#39;: resource
        })

        if &#39;Error&#39; in response:
            raise TronError(response[&#39;Error&#39;])

        return response

    def unfreeze_balance(self, resource=&#39;BANDWIDTH&#39;, account=None):
        &#34;&#34;&#34;
        Unfreeze TRX that has passed the minimum freeze duration.
        Unfreezing will remove bandwidth and TRON Power.

        Args:
            resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
            account (str): address that is freezing trx account

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if resource not in (&#39;BANDWIDTH&#39;, &#39;ENERGY&#39;,):
            raise InvalidTronError(&#39;Invalid resource provided: Expected &#34;BANDWIDTH&#34; or &#34;ENERGY&#34;&#39;)

        if not self.tron.isAddress(account):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/unfreezebalance&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(account),
            &#39;resource&#39;: resource
        })

        if &#39;Error&#39; in response:
            raise ValueError(response[&#39;Error&#39;])

        return response

    def purchase_token(self, to: str, token_id: str, amount: int, buyer=None):
        &#34;&#34;&#34;Purchase a Token
        Creates an unsigned ICO token purchase transaction.

        Args:
            to (str): is the address of the Token issuer
            token_id (str): is the name of the token
            amount (int): is the number of tokens created
            buyer (str): is the address of the Token owner

        &#34;&#34;&#34;

        if buyer is None:
            buyer = self.tron.default_address.hex

        if not self.tron.isAddress(to):
            raise InvalidAddress(&#39;Invalid to address provided&#39;)

        if not len(token_id):
            raise ValueError(&#39;Invalid token ID provided&#39;)

        if amount &lt;= 0:
            raise ValueError(&#39;Invalid amount provided&#39;)

        _to = self.tron.address.to_hex(to)
        _from = self.tron.address.to_hex(buyer)

        return self.tron.manager.request(&#39;/wallet/participateassetissue&#39;, {
            &#39;to_address&#39;: _to,
            &#39;owner_address&#39;: _from,
            &#39;asset_name&#39;: self.tron.toHex(text=token_id),
            &#39;amount&#39;: int(amount)
        })

    def withdraw_block_rewards(self, address: str = None):
        &#34;&#34;&#34;Withdraw block rewards
        Creates an unsigned Super Representative award balance withdraw transaction.

        Args:
            address (str): Optional address to withdraw from.

        &#34;&#34;&#34;
        if not address:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise InvalidAddress(&#39;Invalid address provided&#39;)

        return self.tron.manager.request(&#39;/wallet/withdrawbalance&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(address)
        })

    def apply_for_sr(self, url, address=None):
        &#34;&#34;&#34;Apply to become a super representative

        Args:
            url (str): official website address
            address (str): address

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if address is None:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise TronError(&#39;Invalid address provided&#39;)

        if not is_valid_url(url):
            raise TronError(&#39;Invalid url provided&#39;)

        return self.tron.manager.request(&#39;/wallet/createwitness&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(address),
            &#39;url&#39;: self.tron.toHex(text=url)
        })

    def vote(self, votes: List[Tuple[str, int]], voter_address: str = None):
        &#34;&#34;&#34;Vote
        Vote on the super representative

        Args:
            votes (dict): dictionary of SR address : vote count key-value pair
            voter_address: voter address

        Examples:
            &gt;&gt;&gt; from tronpytool import Tron
            &gt;&gt;&gt; data = [
            &gt;&gt;&gt;     (&#39;TRJpw2uqohP7FUmAEJgt57wakRn6aGQU6Z&#39;, 1)
            &gt;&gt;&gt; ]
            &gt;&gt;&gt; tron = Tron()
            &gt;&gt;&gt; tron.transaction.vote(data)

        &#34;&#34;&#34;
        if voter_address is None:
            voter_address = self.tron.default_address.hex

        _view_vote = []

        # We create a cycle to check all the received data for voting.
        for sr_address, vote_count in votes:
            if not self.tron.isAddress(sr_address):
                raise InvalidAddress(
                    &#39;Invalid SR address provided: &#39; + sr_address
                )

            if not is_integer(vote_count) or vote_count &lt;= 0:
                raise ValueError(
                    &#39;Invalid vote count provided for SR: &#39; + sr_address
                )

            _view_vote.append({
                &#39;vote_address&#39;: self.tron.address.to_hex(sr_address),
                &#39;vote_count&#39;: int(vote_count)
            })

        return self.tron.manager.request(&#39;/wallet/votewitnessaccount&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(voter_address),
            &#39;votes&#39;: _view_vote
        })

    def create_proposal(self, parameters: Any, issuer_address=None):
        &#34;&#34;&#34;Creates a proposal to modify the network.
        Can only be created by a current Super Representative.

        Args:
            parameters (Any): proposal parameters
            issuer_address: owner address

        Examples:
            &gt;&gt;&gt; from tronpytool import Tron
            &gt;&gt;&gt; data = [
            &gt;&gt;&gt;     {&#39;key&#39;: 1, &#39;value&#39;: 2},
            &gt;&gt;&gt;     {&#39;key&#39;: 1, &#39;value&#39;: 2}
            &gt;&gt;&gt; ]
            &gt;&gt;&gt; tron = Tron()
            &gt;&gt;&gt; tron.transaction.create_proposal(data)


        &#34;&#34;&#34;
        if issuer_address is None:
            issuer_address = self.tron.default_address.hex

        if not self.tron.isAddress(issuer_address):
            raise InvalidAddress(&#39;Invalid issuerAddress provided&#39;)

        return self.tron.manager.request(&#39;/wallet/proposalcreate&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(issuer_address),
            &#39;parameters&#39;: parameters
        })

    def vote_proposal(self, proposal_id, has_approval, voter_address=None):
        &#34;&#34;&#34;Proposal approval

        Args:
            proposal_id (int): proposal id
            has_approval (bool): Approved
            voter_address (str): Approve address

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if voter_address is None:
            voter_address = self.tron.default_address.hex

        if not self.tron.isAddress(voter_address):
            raise TronError(&#39;Invalid voter_address address provided&#39;)

        if not is_integer(proposal_id) or proposal_id &lt; 0:
            raise TronError(&#39;Invalid proposal_id provided&#39;)

        if not is_boolean(has_approval):
            raise TronError(&#39;Invalid has_approval provided&#39;)

        return self.tron.manager.request(&#39;/wallet/proposalapprove&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(voter_address),
            &#39;proposal_id&#39;: int(proposal_id),
            &#39;is_add_approval&#39;: bool(has_approval)
        })

    def delete_proposal(self, proposal_id: int, issuer_address: str = None):
        &#34;&#34;&#34;Delete proposal

        Args:
            proposal_id (int): proposal id
            issuer_address (str): delete the person&#39;s address

        Results:
            Delete the proposal&#39;s transaction

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if issuer_address is None:
            issuer_address = self.tron.default_address.hex

        if not self.tron.isAddress(issuer_address):
            raise InvalidTronError(&#39;Invalid issuer_address provided&#39;)

        if not isinstance(proposal_id, int) or proposal_id &lt; 0:
            raise InvalidTronError(&#39;Invalid proposal_id provided&#39;)

        return self.tron.manager.request(&#39;/wallet/proposaldelete&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(issuer_address),
            &#39;proposal_id&#39;: int(proposal_id)
        })

    def update_account(self, account_name, account: str = None):
        &#34;&#34;&#34;Modify account name

        Note: Username is allowed to edit only once.

        Args:
            account_name (str): name of the account
            account (str): address

        Returns:
            modified Transaction Object

        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if not is_string(account_name):
            raise ValueError(&#39;Name must be a string&#39;)

        if not self.tron.isAddress(account):
            raise TronError(&#39;Invalid origin address provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/updateaccount&#39;, {
            &#39;account_name&#39;: self.tron.toHex(text=account_name),
            &#39;owner_address&#39;: self.tron.address.to_hex(account)
        })

        return response

    def create_smart_contract(self, **kwargs):
        &#34;&#34;&#34;Deploy Contract

        Deploys a contract.
        Returns TransactionExtention, which contains an unsigned transaction.

        Example:
        .. code-block:: python
            &gt;&gt;&gt; from tronpytool import Tron
            &gt;&gt;&gt;
            &gt;&gt;&gt; tron = Tron()
            &gt;&gt;&gt; tron.transaction_builder.create_smart_contract(
            &gt;&gt;&gt;    fee_limit=10**9,
            &gt;&gt;&gt;    call_value=0,
            &gt;&gt;&gt;    consume_user_resource_percent=10
            &gt;&gt;&gt; )

        Args:
            **kwargs: Transaction parameters for the deployment
            transaction as a dict

        &#34;&#34;&#34;

        if &#39;bytecode&#39; not in kwargs:
            raise ValueError(
                &#34;Cannot deploy a contract that does not have &#39;bytecode&#39; associated &#34;
                &#34;with it&#34;
            )

        # Maximum TRX consumption, measured in SUN (1 TRX = 1,000,000 SUN).
        fee_limit = kwargs.setdefault(&#39;fee_limit&#39;, 0)
        # The same as User Pay Ratio.
        # The percentage of resources specified for users who use this contract.
        # This field accepts integers between [0, 100].
        user_fee_percentage = kwargs.setdefault(&#39;consume_user_resource_percent&#39;, 0)
        # Amount of TRX transferred with this transaction, measured in SUN (1TRX = 1,000,000 SUN)
        call_value = kwargs.setdefault(&#39;call_value&#39;, 0)
        # Contract owner address, converted to a hex string
        owner_address = kwargs.setdefault(&#39;owner_address&#39;, self.tron.default_address.hex)
        # The max energy which will be consumed by the owner
        # in the process of excution or creation of the contract,
        # is an integer which should be greater than 0.
        origin_energy_limit = kwargs.setdefault(&#39;origin_energy_limit&#39;, 10000000)

        # parameters = kwargs.setdefault(&#39;parameters&#39;, []).append()
        # parameters = kwargs.setdefault(&#39;visible&#39;, []).append()
        # parameters = kwargs.setdefault(&#39;permission_id&#39;, []).append()

        if not is_integer(user_fee_percentage) and not user_fee_percentage:
            user_fee_percentage = 100

        if not is_hex(kwargs.get(&#39;bytecode&#39;)):
            raise ValueError(&#39;Invalid bytecode provided&#39;)

        if not is_integer(fee_limit) or fee_limit &lt;= 0 or \
                fee_limit &gt; 1000000000:
            raise ValueError(&#39;Invalid fee limit provided&#39;)

        if not is_integer(call_value) or call_value &lt; 0:
            raise ValueError(&#39;Invalid call value provided&#39;)

        if not is_integer(user_fee_percentage) or user_fee_percentage &lt; 0 or \
                user_fee_percentage &gt; 100:
            raise ValueError(&#39;Invalid user fee percentage provided&#39;)

        if not is_integer(origin_energy_limit) or origin_energy_limit &lt; 0:
            return ValueError(&#39;Invalid origin_energy_limit provided&#39;)

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid issuer address provided&#39;)

        # We write all the results in one object
        transaction = dict(**kwargs)
        transaction.setdefault(&#39;owner_address&#39;, self.tron.address.to_hex(owner_address))

        return self.tron.manager.request(&#39;/wallet/deploycontract&#39;, transaction)

    def trigger_smart_contract_constant(self, kv: dict):

        contract_address = kv.setdefault(&#39;contract_address&#39;, None)
        function_selector = kv.setdefault(&#39;function_selector&#39;, None)

        issuer_address = kv.setdefault(&#39;issuer_address&#39;, self.tron.default_address.hex)
        call_value = kv.setdefault(&#39;call_value&#39;, 0)
        fee_limit = kv.setdefault(&#39;fee_limit&#39;, 1000000000)
        token_value = kv.setdefault(&#39;token_value&#39;, 0)
        token_id = kv.setdefault(&#39;token_id&#39;, 0)

        if not is_integer(token_value) or token_value &lt; 0:
            raise ValueError(&#39;Invalid options.tokenValue provided&#39;)

        if not is_integer(token_id) or token_id &lt; 0:
            raise ValueError(&#39;Invalid options.tokenId provided&#39;)

        if not self.tron.isAddress(contract_address):
            raise InvalidAddress(&#39;Invalid contract address provided&#39;)

        if not is_string(function_selector):
            raise ValueError(&#39;Invalid function selector provided&#39;)

        if not is_integer(call_value) or call_value &lt; 0:
            raise ValueError(&#39;Invalid call value provided&#39;)

        if not is_integer(fee_limit) or fee_limit &lt;= 0 or fee_limit &gt; 1000000000:
            raise ValueError(&#39;Invalid fee limit provided&#39;)

        &#34;&#34;&#34;remove all the spaces&#34;&#34;&#34;
        function_selector = function_selector.replace(&#39;/\s*/g&#39;, &#39;&#39;)

        if hasattr(kv, &#34;parameters&#34;) and len(kv[&#39;parameters&#39;]) &gt; 0:
            types = []
            values = []
            parameters = kv[&#39;parameters&#39;]
            for abi in parameters:
                if &#39;type&#39; not in abi or not is_string(abi[&#39;type&#39;]):
                    raise ValueError(&#39;Invalid parameter type provided: &#39; + abi[&#39;type&#39;])

                if abi[&#39;type&#39;] == &#39;address&#39;:
                    abi[&#39;value&#39;] = self.tron.address.to_hex(abi[&#39;value&#39;]).replace(&#39;41&#39;, &#39;0x&#39;, 1)

                types.append(abi[&#39;type&#39;])
                values.append(abi[&#39;value&#39;])

            try:
                parameters = encode_hex(encode_abi(types, values)).replace(&#39;0x&#39;, &#39;&#39;, 2)
            except ValueError as ex:
                print(ex)

        else:
            parameters = []

        self.debug_input_kv(kv)

        data = {
            &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
            &#39;owner_address&#39;: issuer_address.hex,
            &#39;function_selector&#39;: function_selector,
            &#39;fee_limit&#39;: int(fee_limit),
            &#39;call_value&#39;: int(call_value),
            &#39;parameter&#39;: parameters
        }

        if token_value:
            data[&#39;call_token_value&#39;] = int(token_value)

        if token_id:
            data[&#39;token_id&#39;] = int(token_id)

        self.debug_url_req(data)

        return self.tron.manager.request(&#39;/wallet/triggerconstantcontract&#39;, kv)

    def trigger_smart_contract(self, kv: dict):

        &#34;&#34;&#34;Trigger Smart Contract
        Calls a function on a contract

        Args:
            **kv: Fill in the required parameters

        Examples:
            &gt;&gt;&gt; tron = Tron()
            &gt;&gt;&gt; tron.transaction_builder.trigger_smart_contract(
            &gt;&gt;&gt;     contract_address=&#39;413c8143e98b3e2fe1b1a8fb82b34557505a752390&#39;,
            &gt;&gt;&gt;     function_selector=&#39;set(uint256,uint256)&#39;,
            &gt;&gt;&gt;     fee_limit=30000,
            &gt;&gt;&gt;     call_value=0,
            &gt;&gt;&gt;     parameters=[
            &gt;&gt;&gt;        {&#39;type&#39;: &#39;int256&#39;, &#39;value&#39;: 1},
            &gt;&gt;&gt;        {&#39;type&#39;: &#39;int256&#39;, &#39;value&#39;: 1}])

        Returns:
            TransactionExtention, TransactionExtention contains unsigned Transaction
        &#34;&#34;&#34;

        contract_address = kv.setdefault(&#39;contract_address&#39;, None)
        function_selector = kv.setdefault(&#39;function_selector&#39;, None)

        issuer_address = kv.setdefault(&#39;issuer_address&#39;, self.tron.default_address.hex)
        call_value = kv.setdefault(&#39;call_value&#39;, 0)
        fee_limit = kv.setdefault(&#39;fee_limit&#39;, 1000000000)
        token_value = kv.setdefault(&#39;token_value&#39;, 0)
        token_id = kv.setdefault(&#39;token_id&#39;, 0)
        parameters = kv.setdefault(&#39;parameters&#39;, [])

        if not is_integer(token_value) or token_value &lt; 0:
            raise ValueError(&#39;Invalid options.tokenValue provided&#39;)

        if not is_integer(token_id) or token_id &lt; 0:
            raise ValueError(&#39;Invalid options.tokenId provided&#39;)

        if not self.tron.isAddress(contract_address):
            raise InvalidAddress(&#39;Invalid contract address provided&#39;)

        if not is_string(function_selector):
            raise ValueError(&#39;Invalid function selector provided&#39;)

        if not is_integer(call_value) or call_value &lt; 0:
            raise ValueError(&#39;Invalid call value provided&#39;)

        if not is_integer(fee_limit) or fee_limit &lt;= 0 or fee_limit &gt; 1000000000:
            raise ValueError(&#39;Invalid fee limit provided&#39;)

        &#34;&#34;&#34;remove all the spaces&#34;&#34;&#34;
        function_selector = function_selector.replace(&#39;/\s*/g&#39;, &#39;&#39;)
        print(parameters)
        print(&#34;-------------- this is the last parameters.. &#34;)
        if len(parameters) &gt; 0:
            types = []
            values = []
            for abi in parameters:
                if &#39;type&#39; not in abi or not is_string(abi[&#39;type&#39;]):
                    raise ValueError(&#39;Invalid parameter type provided: &#39; + abi[&#39;type&#39;])
                if abi[&#39;type&#39;] == &#39;address&#39;:
                    abi[&#39;value&#39;] = self.tron.address.to_hex(abi[&#39;value&#39;]).replace(&#39;41&#39;, &#39;0x&#39;, 1)
                types.append(abi[&#39;type&#39;])
                values.append(abi[&#39;value&#39;])

            try:
                parameters = encode_hex(encode_abi(types, values)).replace(&#39;0x&#39;, &#39;&#39;, 2)
            except ValueError as ex:
                print(ex)

        else:
            parameters = &#39;&#39;

        data = {
            &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
            &#39;owner_address&#39;: issuer_address.hex,
            &#39;function_selector&#39;: function_selector,
            &#39;fee_limit&#39;: int(fee_limit),
            &#39;call_value&#39;: int(call_value),
            &#39;parameter&#39;: parameters
        }

        # if parameters is &#39;&#39;:
        #    data.pop(&#39;parameter&#39;)
        self.debug_input_kv(kv)
        if token_value:
            data[&#39;call_token_value&#39;] = int(token_value)

        if token_id:
            data[&#39;token_id&#39;] = int(token_id)
        self.debug_url_req(data)
        return self.tron.manager.request(&#39;/wallet/triggersmartcontract&#39;, data)

    def debug_url_req(self, data):
        if self.debug:
            print(&#34;==data load on request url&#34;)
            print(data)
            print(&#34;==end&#34;)

    def debug_input_kv(self, data):
        if self.debug:
            print(&#34;==checking input data&#34;)
            print(data)
            print(&#34;==end&#34;)

    def create_trx_exchange(self,
                            token_name: str,
                            token_balance: int,
                            trx_balance: int,
                            account: str = None):
        &#34;&#34;&#34;Create an exchange between a token and TRX.
        Token Name should be a CASE SENSITIVE string.
        Note: PLEASE VERIFY THIS ON TRONSCAN.

        Args:
            token_name (str): Token Name
            token_balance (int): balance of the first token
            trx_balance (int): balance of the second token
            account (str): Owner Address
        &#34;&#34;&#34;

        # If the address of the sender is not specified, we prescribe the default
        if account is None:
            account = self.tron.default_address.hex

        if not self.tron.isAddress(account):
            raise TronError(&#39;Invalid address provided&#39;)

        if token_balance &lt;= 0 or trx_balance &lt;= 0:
            raise TronError(&#39;Invalid amount provided&#39;)

        return self.tron.manager.request(&#39;/wallet/exchangecreate&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(account),
            &#39;first_token_id&#39;: self.tron.toHex(text=token_name),
            &#39;first_token_balance&#39;: token_balance,
            &#39;second_token_id&#39;: &#39;5f&#39;,
            &#39;second_token_balance&#39;: trx_balance
        })

    def create_token_exchange(self,
                              first_token_name: str,
                              first_token_balance: int,
                              second_token_name: str,
                              second_token_balance: int,
                              owner_address: str = None):
        &#34;&#34;&#34;Create an exchange between a token and another token.
        DO NOT USE THIS FOR TRX.
        Token Names should be a CASE SENSITIVE string.

        Args:
            first_token_name (str): the id of the first token
            first_token_balance (int): balance of the first token
            second_token_name (str): the id of the second token
            second_token_balance (int): balance of the second token
            owner_address: owner address

        &#34;&#34;&#34;
        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid address provided&#39;)

        if second_token_balance &lt;= 0 or first_token_balance &lt;= 0:
            raise ValueError(&#39;Invalid amount provided&#39;)

        return self.tron.manager.request(&#39;/wallet/exchangecreate&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;first_token_id&#39;: self.tron.toHex(text=first_token_name),
            &#39;first_token_balance&#39;: first_token_balance,
            &#39;second_token_id&#39;: self.tron.toHex(text=second_token_name),
            &#39;second_token_balance&#39;: second_token_balance
        })

    def inject_exchange_tokens(self,
                               exchange_id: int,
                               token_name: str,
                               token_amount: int = 0,
                               owner_address: str = None):
        &#34;&#34;&#34;Adds tokens into a bancor style exchange.
        Will add both tokens at market rate.

        Args:
            exchange_id (int): non-negative integer exchange id
            token_name (str): token name
            token_amount (int): amount of token
            owner_address (str): token owner address in hex

        &#34;&#34;&#34;
        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

        if exchange_id &lt; 0:
            raise ValueError(&#39;Invalid exchange_id provided&#39;)

        if token_amount &lt; 1:
            raise ValueError(&#39;Invalid token_amount provided&#39;)

        return self.tron.manager.request(&#39;/wallet/exchangeinject&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;exchange_id&#39;: exchange_id,
            &#39;token_id&#39;: self.tron.toHex(text=token_name),
            &#39;quant&#39;: token_amount
        })

    def create_token(self, **kwargs):
        &#34;&#34;&#34;Issue Token

        Issuing a token on the TRON Protocol can be done by anyone
        who has at least 1024 TRX in their account.
        When a token is issued it will be shown on the token overview page.
        Users can then participate within the issuing time and exchange their
        TRX for tokens.After issuing the token your account will
        receive the amount of tokens equal to the total supply.
        When other users exchange their TRX for tokens then the tokens
        will be withdrawn from your account and you will receive
        TRX equal to the specified exchange rate.


        Args:
            **kwargs: Fill in the required parameters

        Examples:

            &gt;&gt;&gt; start_func = datetime.now()
            &gt;&gt;&gt; start = int(start_func.timestamp() * 1000)
            &gt;&gt;&gt;
            &gt;&gt;&gt; end_func = datetime.now() + timedelta(days=2)
            &gt;&gt;&gt; end = int(end_func.timestamp() * 1000)
            &gt;&gt;&gt;
            &gt;&gt;&gt; opt = {
            &gt;&gt;&gt;     &#39;name&#39;: &#39;Tron&#39;,
            &gt;&gt;&gt;     &#39;abbreviation&#39;: &#39;TRX&#39;,
            &gt;&gt;&gt;     &#39;description&#39;: &#39;Hello World&#39;,
            &gt;&gt;&gt;     &#39;url&#39;: &#39;https://github.com&#39;,
            &gt;&gt;&gt;     &#39;totalSupply&#39;: 25000000,
            &gt;&gt;&gt;     &#39;frozenAmount&#39;: 1,
            &gt;&gt;&gt;     &#39;frozenDuration&#39;: 2,
            &gt;&gt;&gt;     &#39;freeBandwidth&#39;: 10000,
            &gt;&gt;&gt;     &#39;freeBandwidthLimit&#39;: 10000,
            &gt;&gt;&gt;     &#39;saleStart&#39;: start,
            &gt;&gt;&gt;     &#39;saleEnd&#39;: end,
            &gt;&gt;&gt;     &#39;voteScore&#39;: 1
            &gt;&gt;&gt; }

        &#34;&#34;&#34;
        issuer_address = kwargs.setdefault(
            &#39;issuer_address&#39;, self.tron.default_address.hex
        )

        if not self.tron.isAddress(issuer_address):
            raise TronError(&#39;Invalid issuer address provided&#39;)

        total_supply = kwargs.setdefault(&#39;totalSupply&#39;, 0)
        trx_ratio = kwargs.setdefault(&#39;trxRatio&#39;, 1)
        token_ratio = kwargs.setdefault(&#39;tokenRatio&#39;, 1)
        sale_start = kwargs.setdefault(
            &#39;saleStart&#39;, START_DATE
        )
        free_bandwidth = kwargs.setdefault(&#39;freeBandwidth&#39;, 0)
        free_bandwidth_limit = kwargs.setdefault(&#39;freeBandwidthLimit&#39;, 0)
        frozen_amount = kwargs.setdefault(&#39;frozenAmount&#39;, 0)
        frozen_duration = kwargs.setdefault(&#39;frozenDuration&#39;, 0)
        vote_score = kwargs.setdefault(&#39;voteScore&#39;, 0)
        precision = kwargs.setdefault(&#39;precision&#39;, 0)

        if not is_string(kwargs.get(&#39;name&#39;)):
            raise ValueError(&#39;Invalid token name provided&#39;)

        if not is_string(kwargs.get(&#39;abbreviation&#39;)):
            raise ValueError(&#39;Invalid token abbreviation provided&#39;)

        if not is_integer(total_supply) or total_supply &lt;= 0:
            raise ValueError(&#39;Invalid supply amount provided&#39;)

        if not is_integer(trx_ratio) or trx_ratio &lt;= 0:
            raise ValueError(&#39;TRX ratio must be a positive integer&#39;)

        if not is_integer(token_ratio) or token_ratio &lt;= 0:
            raise ValueError(&#39;Token ratio must be a positive integer&#39;)

        if not is_integer(vote_score) or vote_score &lt;= 0:
            raise ValueError(&#39;voteScore must be a positive integer greater than 0&#39;)

        if not is_integer(precision) or precision &lt;= 0 or precision &gt; 6:
            raise ValueError(&#39;precision must be a positive integer &gt; 0 and &lt;= 6&#39;)

        if not is_integer(sale_start) or sale_start &lt; START_DATE:
            raise ValueError(&#39;Invalid sale start timestamp provided&#39;)

        if not is_integer(kwargs.get(&#39;saleEnd&#39;)) or \
                kwargs.get(&#39;saleEnd&#39;) &lt;= sale_start:
            raise ValueError(&#39;Invalid sale end timestamp provided&#39;)

        if not is_string(kwargs.get(&#39;description&#39;)):
            raise ValueError(&#39;Invalid token description provided&#39;)

        if not is_valid_url(kwargs.get(&#39;url&#39;)):
            raise ValueError(&#39;Invalid token url provided&#39;)

        if not is_integer(free_bandwidth) or free_bandwidth &lt; 0:
            raise ValueError(&#39;Invalid free bandwidth amount provided&#39;)

        if not is_integer(free_bandwidth_limit) or free_bandwidth_limit &lt; 0 \
                or (free_bandwidth and not free_bandwidth_limit):
            raise ValueError(&#39;Invalid free bandwidth limit provided&#39;)

        if not is_integer(frozen_amount) or frozen_amount &lt; 0 \
                or (not frozen_duration and frozen_amount):
            raise ValueError(&#39;Invalid frozen supply provided&#39;)

        if not is_integer(frozen_duration) or frozen_duration &lt; 0 \
                or (frozen_duration and not frozen_amount):
            raise ValueError(&#39;Invalid frozen duration provided&#39;)

        frozen_supply = {
            &#39;frozen_amount&#39;: int(frozen_amount),
            &#39;frozen_days&#39;: int(frozen_duration)
        }

        response = self.tron.manager.request(&#39;/wallet/createassetissue&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(issuer_address),
            &#39;name&#39;: self.tron.toHex(text=kwargs.get(&#39;name&#39;)),
            &#39;abbr&#39;: self.tron.toHex(text=kwargs.get(&#39;abbreviation&#39;)),
            &#39;description&#39;: self.tron.toHex(text=kwargs.get(&#39;description&#39;)),
            &#39;url&#39;: self.tron.toHex(text=kwargs.get(&#39;url&#39;)),
            &#39;total_supply&#39;: int(total_supply),
            &#39;trx_num&#39;: int(trx_ratio),
            &#39;num&#39;: int(token_ratio),
            &#39;start_time&#39;: int(sale_start),
            &#39;end_time&#39;: int(kwargs.get(&#39;saleEnd&#39;)),
            &#39;free_asset_net_limit&#39;: int(free_bandwidth),
            &#39;public_free_asset_net_limit&#39;: int(free_bandwidth_limit),
            &#39;frozen_supply&#39;: frozen_supply,
            &#39;vote_score&#39;: vote_score,
            &#39;precision&#39;: precision
        })

        return response

    def withdraw_exchange_tokens(self,
                                 exchange_id: int,
                                 token_name: str,
                                 token_amount: int = 0,
                                 owner_address: str = None):
        &#34;&#34;&#34;Withdraws tokens from a bancor style exchange.
        Will withdraw at market rate both tokens.

        Args:
            exchange_id (int): non-negative integer exchange id
            token_name (str): token name
            token_amount (int): number of tokens withdraw
            owner_address (str): owner address in hex

        &#34;&#34;&#34;
        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

        if exchange_id &lt; 0:
            raise ValueError(&#39;Invalid exchange_id provided&#39;)

        if token_amount &lt; 1:
            raise ValueError(&#39;Invalid token_amount provided&#39;)

        return self.tron.manager.request(&#39;/wallet/exchangewithdraw&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;exchange_id&#39;: exchange_id,
            &#39;token_id&#39;: self.tron.toHex(text=token_name),
            &#39;quant&#39;: token_amount
        })

    def trade_exchange_tokens(self,
                              exchange_id: int,
                              token_name: str,
                              token_amount_sold: int = 0,
                              token_amount_expected: int = 0,
                              owner_address: str = None):
        &#34;&#34;&#34;Trade tokens on a bancor style exchange.
        Expected value is a validation and used to cap the total amt of token 2 spent.

        Args:
            exchange_id (int): non-negative integer exchange id
            token_name (str): token name
            token_amount_sold (int): amount f token actually sold
            token_amount_expected (int): amount of token expected
            owner_address (str): token owner address in hex

        &#34;&#34;&#34;

        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

        if exchange_id &lt; 0:
            raise ValueError(&#39;Invalid exchange_id provided&#39;)

        if token_amount_sold &lt; 1:
            raise ValueError(&#39;Invalid token_amount_sold provided&#39;)

        if token_amount_expected &lt; 1:
            raise ValueError(&#39;Invalid token_amount_expected provided&#39;)

        return self.tron.manager.request(&#39;/wallet/exchangewithdraw&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;exchange_id&#39;: exchange_id,
            &#39;token_id&#39;: self.tron.toHex(text=token_name),
            &#39;quant&#39;: token_amount_sold,
            &#39;expected&#39;: token_amount_expected
        })

    def update_setting(self,
                       contract_address,
                       user_fee_percentage,
                       owner_address: str = None):
        &#34;&#34;&#34;Update userFeePercentage.

        Args:
            contract_address (str): the address of the contract to be modified
            user_fee_percentage (int): the percentage of resources specified for users using this contract
            owner_address (str): is the address of the creator

        Returns:
            Contains unsigned transaction Transaction
        &#34;&#34;&#34;

        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

        if not self.tron.isAddress(contract_address):
            raise InvalidAddress(&#39;Invalid contract_address provided&#39;)

        if not is_integer(user_fee_percentage) or user_fee_percentage &lt; 0 or \
                user_fee_percentage &gt; 100:
            raise ValueError(&#39;Invalid user_fee_percentage provided&#39;)

        return self.tron.manager.request(&#39;wallet/updatesetting&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
            &#39;consume_user_resource_percent&#39;: user_fee_percentage
        })

    def update_energy_limit(self,
                            contract_address,
                            origin_energy_limit,
                            owner_address: str = None):
        &#34;&#34;&#34;Update energy limit.

        Args:
            contract_address (str): The address of the contract to be modified
            origin_energy_limit (int): The maximum energy set by the creator that is created
            owner_address (str): Is the address of the creator

        Returns:
            Contains unsigned transaction Transaction
        &#34;&#34;&#34;

        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.tron.isAddress(owner_address):
            raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

        if not self.tron.isAddress(contract_address):
            raise InvalidAddress(&#39;Invalid contractAddress provided&#39;)

        if not is_integer(origin_energy_limit) or origin_energy_limit &lt; 0 or \
                origin_energy_limit &gt; 10000000:
            raise ValueError(&#39;Invalid originEnergyLimit  provided&#39;)

        return self.tron.manager.request(&#39;wallet/updateenergylimit&#39;, {
            &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
            &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
            &#39;origin_energy_limit&#39;: origin_energy_limit
        })

    def check_permissions(self, permissions, _type):
        if permissions is not None:
            if permissions[&#39;type&#39;] != _type or \
                    not permissions[&#39;permission_name&#39;] or \
                    not is_string(permissions[&#39;permission_name&#39;]) or \
                    not is_integer(permissions[&#39;threshold&#39;]) or \
                    permissions[&#39;threshold&#39;] &lt; 1 or not permissions[&#39;keys&#39;]:
                return False

        for key in permissions[&#39;key&#39;]:
            if not self.tron.isAddress(key[&#39;address&#39;]) or \
                    not is_integer(key[&#39;weight&#39;]) or \
                    key[&#39;weight&#39;] &gt; permissions[&#39;threshold&#39;] or \
                    key[&#39;weight&#39;] &lt; 1 or _type == 2 and not permissions[&#39;operations&#39;]:
                return False

        return True

    def update_account_permissions(self, owner_address=None,
                                   owner_permissions=None,
                                   witness_permissions=None,
                                   actives_permissions=None
                                   ):
        &#34;&#34;&#34;Role: update user permissions (for multi-signature)

        Args:
            owner_address (str): The address of the account whose permissions are to be modified
            owner_permissions: Modified owner permission
            witness_permissions: Modified witness permission (if it is a witness)
            actives_permissions: Modified actives permission
        &#34;&#34;&#34;

        if owner_address is None:
            owner_address = self.tron.default_address.hex

        if not self.check_permissions(owner_permissions, 0):
            raise InvalidTronError(&#39;Invalid ownerPermissions provided&#39;)

        if not self.check_permissions(witness_permissions, 1):
            raise InvalidTronError(&#39;Invalid witnessPermissions provided&#39;)

        for actives_permission in actives_permissions:
            if not self.check_permissions(actives_permission, 2):
                raise InvalidTronError(&#39;Invalid activesPermissions provided&#39;)

        data = {
            owner_address: owner_address
        }

        if owner_permissions:
            data[&#39;owner&#39;] = owner_permissions

        if witness_permissions:
            data[&#39;witness&#39;] = witness_permissions

        if actives_permissions:
            if len(actives_permissions) == 1:
                data[&#39;actives&#39;] = actives_permissions[0]
            else:
                data[&#39;actives&#39;] = actives_permissions

        return self.tron.manager.request(&#39;wallet/accountpermissionupdate&#39;, data)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.debug"><code class="name">var <span class="ident">debug</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.apply_for_sr"><code class="name flex">
<span>def <span class="ident">apply_for_sr</span></span>(<span>self, url, address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply to become a super representative</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>official website address</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>address</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_for_sr(self, url, address=None):
    &#34;&#34;&#34;Apply to become a super representative

    Args:
        url (str): official website address
        address (str): address

    &#34;&#34;&#34;

    # If the address of the sender is not specified, we prescribe the default
    if address is None:
        address = self.tron.default_address.hex

    if not self.tron.isAddress(address):
        raise TronError(&#39;Invalid address provided&#39;)

    if not is_valid_url(url):
        raise TronError(&#39;Invalid url provided&#39;)

    return self.tron.manager.request(&#39;/wallet/createwitness&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(address),
        &#39;url&#39;: self.tron.toHex(text=url)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.check_permissions"><code class="name flex">
<span>def <span class="ident">check_permissions</span></span>(<span>self, permissions, _type)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_permissions(self, permissions, _type):
    if permissions is not None:
        if permissions[&#39;type&#39;] != _type or \
                not permissions[&#39;permission_name&#39;] or \
                not is_string(permissions[&#39;permission_name&#39;]) or \
                not is_integer(permissions[&#39;threshold&#39;]) or \
                permissions[&#39;threshold&#39;] &lt; 1 or not permissions[&#39;keys&#39;]:
            return False

    for key in permissions[&#39;key&#39;]:
        if not self.tron.isAddress(key[&#39;address&#39;]) or \
                not is_integer(key[&#39;weight&#39;]) or \
                key[&#39;weight&#39;] &gt; permissions[&#39;threshold&#39;] or \
                key[&#39;weight&#39;] &lt; 1 or _type == 2 and not permissions[&#39;operations&#39;]:
            return False

    return True</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.create_proposal"><code class="name flex">
<span>def <span class="ident">create_proposal</span></span>(<span>self, parameters: Any, issuer_address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a proposal to modify the network.
Can only be created by a current Super Representative.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parameters</code></strong> :&ensp;<code>Any</code></dt>
<dd>proposal parameters</dd>
<dt><strong><code>issuer_address</code></strong></dt>
<dd>owner address</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; from tronpytool import Tron
&gt;&gt;&gt; data = [
&gt;&gt;&gt;     {'key': 1, 'value': 2},
&gt;&gt;&gt;     {'key': 1, 'value': 2}
&gt;&gt;&gt; ]
&gt;&gt;&gt; tron = Tron()
&gt;&gt;&gt; tron.transaction.create_proposal(data)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_proposal(self, parameters: Any, issuer_address=None):
    &#34;&#34;&#34;Creates a proposal to modify the network.
    Can only be created by a current Super Representative.

    Args:
        parameters (Any): proposal parameters
        issuer_address: owner address

    Examples:
        &gt;&gt;&gt; from tronpytool import Tron
        &gt;&gt;&gt; data = [
        &gt;&gt;&gt;     {&#39;key&#39;: 1, &#39;value&#39;: 2},
        &gt;&gt;&gt;     {&#39;key&#39;: 1, &#39;value&#39;: 2}
        &gt;&gt;&gt; ]
        &gt;&gt;&gt; tron = Tron()
        &gt;&gt;&gt; tron.transaction.create_proposal(data)


    &#34;&#34;&#34;
    if issuer_address is None:
        issuer_address = self.tron.default_address.hex

    if not self.tron.isAddress(issuer_address):
        raise InvalidAddress(&#39;Invalid issuerAddress provided&#39;)

    return self.tron.manager.request(&#39;/wallet/proposalcreate&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(issuer_address),
        &#39;parameters&#39;: parameters
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.create_smart_contract"><code class="name flex">
<span>def <span class="ident">create_smart_contract</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Deploy Contract</p>
<p>Deploys a contract.
Returns TransactionExtention, which contains an unsigned transaction.</p>
<p>Example:
.. code-block:: python
&gt;&gt;&gt; from tronpytool import Tron
&gt;&gt;&gt;
&gt;&gt;&gt; tron = Tron()
&gt;&gt;&gt; tron.transaction_builder.create_smart_contract(
&gt;&gt;&gt;
fee_limit=10**9,
&gt;&gt;&gt;
call_value=0,
&gt;&gt;&gt;
consume_user_resource_percent=10
&gt;&gt;&gt; )</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Transaction parameters for the deployment</dd>
</dl>
<p>transaction as a dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_smart_contract(self, **kwargs):
    &#34;&#34;&#34;Deploy Contract

    Deploys a contract.
    Returns TransactionExtention, which contains an unsigned transaction.

    Example:
    .. code-block:: python
        &gt;&gt;&gt; from tronpytool import Tron
        &gt;&gt;&gt;
        &gt;&gt;&gt; tron = Tron()
        &gt;&gt;&gt; tron.transaction_builder.create_smart_contract(
        &gt;&gt;&gt;    fee_limit=10**9,
        &gt;&gt;&gt;    call_value=0,
        &gt;&gt;&gt;    consume_user_resource_percent=10
        &gt;&gt;&gt; )

    Args:
        **kwargs: Transaction parameters for the deployment
        transaction as a dict

    &#34;&#34;&#34;

    if &#39;bytecode&#39; not in kwargs:
        raise ValueError(
            &#34;Cannot deploy a contract that does not have &#39;bytecode&#39; associated &#34;
            &#34;with it&#34;
        )

    # Maximum TRX consumption, measured in SUN (1 TRX = 1,000,000 SUN).
    fee_limit = kwargs.setdefault(&#39;fee_limit&#39;, 0)
    # The same as User Pay Ratio.
    # The percentage of resources specified for users who use this contract.
    # This field accepts integers between [0, 100].
    user_fee_percentage = kwargs.setdefault(&#39;consume_user_resource_percent&#39;, 0)
    # Amount of TRX transferred with this transaction, measured in SUN (1TRX = 1,000,000 SUN)
    call_value = kwargs.setdefault(&#39;call_value&#39;, 0)
    # Contract owner address, converted to a hex string
    owner_address = kwargs.setdefault(&#39;owner_address&#39;, self.tron.default_address.hex)
    # The max energy which will be consumed by the owner
    # in the process of excution or creation of the contract,
    # is an integer which should be greater than 0.
    origin_energy_limit = kwargs.setdefault(&#39;origin_energy_limit&#39;, 10000000)

    # parameters = kwargs.setdefault(&#39;parameters&#39;, []).append()
    # parameters = kwargs.setdefault(&#39;visible&#39;, []).append()
    # parameters = kwargs.setdefault(&#39;permission_id&#39;, []).append()

    if not is_integer(user_fee_percentage) and not user_fee_percentage:
        user_fee_percentage = 100

    if not is_hex(kwargs.get(&#39;bytecode&#39;)):
        raise ValueError(&#39;Invalid bytecode provided&#39;)

    if not is_integer(fee_limit) or fee_limit &lt;= 0 or \
            fee_limit &gt; 1000000000:
        raise ValueError(&#39;Invalid fee limit provided&#39;)

    if not is_integer(call_value) or call_value &lt; 0:
        raise ValueError(&#39;Invalid call value provided&#39;)

    if not is_integer(user_fee_percentage) or user_fee_percentage &lt; 0 or \
            user_fee_percentage &gt; 100:
        raise ValueError(&#39;Invalid user fee percentage provided&#39;)

    if not is_integer(origin_energy_limit) or origin_energy_limit &lt; 0:
        return ValueError(&#39;Invalid origin_energy_limit provided&#39;)

    if not self.tron.isAddress(owner_address):
        raise InvalidAddress(&#39;Invalid issuer address provided&#39;)

    # We write all the results in one object
    transaction = dict(**kwargs)
    transaction.setdefault(&#39;owner_address&#39;, self.tron.address.to_hex(owner_address))

    return self.tron.manager.request(&#39;/wallet/deploycontract&#39;, transaction)</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.create_token"><code class="name flex">
<span>def <span class="ident">create_token</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Issue Token</p>
<p>Issuing a token on the TRON Protocol can be done by anyone
who has at least 1024 TRX in their account.
When a token is issued it will be shown on the token overview page.
Users can then participate within the issuing time and exchange their
TRX for tokens.After issuing the token your account will
receive the amount of tokens equal to the total supply.
When other users exchange their TRX for tokens then the tokens
will be withdrawn from your account and you will receive
TRX equal to the specified exchange rate.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Fill in the required parameters</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; start_func = datetime.now()
&gt;&gt;&gt; start = int(start_func.timestamp() * 1000)
&gt;&gt;&gt;
&gt;&gt;&gt; end_func = datetime.now() + timedelta(days=2)
&gt;&gt;&gt; end = int(end_func.timestamp() * 1000)
&gt;&gt;&gt;
&gt;&gt;&gt; opt = {
&gt;&gt;&gt;     'name': 'Tron',
&gt;&gt;&gt;     'abbreviation': 'TRX',
&gt;&gt;&gt;     'description': 'Hello World',
&gt;&gt;&gt;     'url': 'https://github.com',
&gt;&gt;&gt;     'totalSupply': 25000000,
&gt;&gt;&gt;     'frozenAmount': 1,
&gt;&gt;&gt;     'frozenDuration': 2,
&gt;&gt;&gt;     'freeBandwidth': 10000,
&gt;&gt;&gt;     'freeBandwidthLimit': 10000,
&gt;&gt;&gt;     'saleStart': start,
&gt;&gt;&gt;     'saleEnd': end,
&gt;&gt;&gt;     'voteScore': 1
&gt;&gt;&gt; }
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_token(self, **kwargs):
    &#34;&#34;&#34;Issue Token

    Issuing a token on the TRON Protocol can be done by anyone
    who has at least 1024 TRX in their account.
    When a token is issued it will be shown on the token overview page.
    Users can then participate within the issuing time and exchange their
    TRX for tokens.After issuing the token your account will
    receive the amount of tokens equal to the total supply.
    When other users exchange their TRX for tokens then the tokens
    will be withdrawn from your account and you will receive
    TRX equal to the specified exchange rate.


    Args:
        **kwargs: Fill in the required parameters

    Examples:

        &gt;&gt;&gt; start_func = datetime.now()
        &gt;&gt;&gt; start = int(start_func.timestamp() * 1000)
        &gt;&gt;&gt;
        &gt;&gt;&gt; end_func = datetime.now() + timedelta(days=2)
        &gt;&gt;&gt; end = int(end_func.timestamp() * 1000)
        &gt;&gt;&gt;
        &gt;&gt;&gt; opt = {
        &gt;&gt;&gt;     &#39;name&#39;: &#39;Tron&#39;,
        &gt;&gt;&gt;     &#39;abbreviation&#39;: &#39;TRX&#39;,
        &gt;&gt;&gt;     &#39;description&#39;: &#39;Hello World&#39;,
        &gt;&gt;&gt;     &#39;url&#39;: &#39;https://github.com&#39;,
        &gt;&gt;&gt;     &#39;totalSupply&#39;: 25000000,
        &gt;&gt;&gt;     &#39;frozenAmount&#39;: 1,
        &gt;&gt;&gt;     &#39;frozenDuration&#39;: 2,
        &gt;&gt;&gt;     &#39;freeBandwidth&#39;: 10000,
        &gt;&gt;&gt;     &#39;freeBandwidthLimit&#39;: 10000,
        &gt;&gt;&gt;     &#39;saleStart&#39;: start,
        &gt;&gt;&gt;     &#39;saleEnd&#39;: end,
        &gt;&gt;&gt;     &#39;voteScore&#39;: 1
        &gt;&gt;&gt; }

    &#34;&#34;&#34;
    issuer_address = kwargs.setdefault(
        &#39;issuer_address&#39;, self.tron.default_address.hex
    )

    if not self.tron.isAddress(issuer_address):
        raise TronError(&#39;Invalid issuer address provided&#39;)

    total_supply = kwargs.setdefault(&#39;totalSupply&#39;, 0)
    trx_ratio = kwargs.setdefault(&#39;trxRatio&#39;, 1)
    token_ratio = kwargs.setdefault(&#39;tokenRatio&#39;, 1)
    sale_start = kwargs.setdefault(
        &#39;saleStart&#39;, START_DATE
    )
    free_bandwidth = kwargs.setdefault(&#39;freeBandwidth&#39;, 0)
    free_bandwidth_limit = kwargs.setdefault(&#39;freeBandwidthLimit&#39;, 0)
    frozen_amount = kwargs.setdefault(&#39;frozenAmount&#39;, 0)
    frozen_duration = kwargs.setdefault(&#39;frozenDuration&#39;, 0)
    vote_score = kwargs.setdefault(&#39;voteScore&#39;, 0)
    precision = kwargs.setdefault(&#39;precision&#39;, 0)

    if not is_string(kwargs.get(&#39;name&#39;)):
        raise ValueError(&#39;Invalid token name provided&#39;)

    if not is_string(kwargs.get(&#39;abbreviation&#39;)):
        raise ValueError(&#39;Invalid token abbreviation provided&#39;)

    if not is_integer(total_supply) or total_supply &lt;= 0:
        raise ValueError(&#39;Invalid supply amount provided&#39;)

    if not is_integer(trx_ratio) or trx_ratio &lt;= 0:
        raise ValueError(&#39;TRX ratio must be a positive integer&#39;)

    if not is_integer(token_ratio) or token_ratio &lt;= 0:
        raise ValueError(&#39;Token ratio must be a positive integer&#39;)

    if not is_integer(vote_score) or vote_score &lt;= 0:
        raise ValueError(&#39;voteScore must be a positive integer greater than 0&#39;)

    if not is_integer(precision) or precision &lt;= 0 or precision &gt; 6:
        raise ValueError(&#39;precision must be a positive integer &gt; 0 and &lt;= 6&#39;)

    if not is_integer(sale_start) or sale_start &lt; START_DATE:
        raise ValueError(&#39;Invalid sale start timestamp provided&#39;)

    if not is_integer(kwargs.get(&#39;saleEnd&#39;)) or \
            kwargs.get(&#39;saleEnd&#39;) &lt;= sale_start:
        raise ValueError(&#39;Invalid sale end timestamp provided&#39;)

    if not is_string(kwargs.get(&#39;description&#39;)):
        raise ValueError(&#39;Invalid token description provided&#39;)

    if not is_valid_url(kwargs.get(&#39;url&#39;)):
        raise ValueError(&#39;Invalid token url provided&#39;)

    if not is_integer(free_bandwidth) or free_bandwidth &lt; 0:
        raise ValueError(&#39;Invalid free bandwidth amount provided&#39;)

    if not is_integer(free_bandwidth_limit) or free_bandwidth_limit &lt; 0 \
            or (free_bandwidth and not free_bandwidth_limit):
        raise ValueError(&#39;Invalid free bandwidth limit provided&#39;)

    if not is_integer(frozen_amount) or frozen_amount &lt; 0 \
            or (not frozen_duration and frozen_amount):
        raise ValueError(&#39;Invalid frozen supply provided&#39;)

    if not is_integer(frozen_duration) or frozen_duration &lt; 0 \
            or (frozen_duration and not frozen_amount):
        raise ValueError(&#39;Invalid frozen duration provided&#39;)

    frozen_supply = {
        &#39;frozen_amount&#39;: int(frozen_amount),
        &#39;frozen_days&#39;: int(frozen_duration)
    }

    response = self.tron.manager.request(&#39;/wallet/createassetissue&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(issuer_address),
        &#39;name&#39;: self.tron.toHex(text=kwargs.get(&#39;name&#39;)),
        &#39;abbr&#39;: self.tron.toHex(text=kwargs.get(&#39;abbreviation&#39;)),
        &#39;description&#39;: self.tron.toHex(text=kwargs.get(&#39;description&#39;)),
        &#39;url&#39;: self.tron.toHex(text=kwargs.get(&#39;url&#39;)),
        &#39;total_supply&#39;: int(total_supply),
        &#39;trx_num&#39;: int(trx_ratio),
        &#39;num&#39;: int(token_ratio),
        &#39;start_time&#39;: int(sale_start),
        &#39;end_time&#39;: int(kwargs.get(&#39;saleEnd&#39;)),
        &#39;free_asset_net_limit&#39;: int(free_bandwidth),
        &#39;public_free_asset_net_limit&#39;: int(free_bandwidth_limit),
        &#39;frozen_supply&#39;: frozen_supply,
        &#39;vote_score&#39;: vote_score,
        &#39;precision&#39;: precision
    })

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.create_token_exchange"><code class="name flex">
<span>def <span class="ident">create_token_exchange</span></span>(<span>self, first_token_name: str, first_token_balance: int, second_token_name: str, second_token_balance: int, owner_address: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an exchange between a token and another token.
DO NOT USE THIS FOR TRX.
Token Names should be a CASE SENSITIVE string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>first_token_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the id of the first token</dd>
<dt><strong><code>first_token_balance</code></strong> :&ensp;<code>int</code></dt>
<dd>balance of the first token</dd>
<dt><strong><code>second_token_name</code></strong> :&ensp;<code>str</code></dt>
<dd>the id of the second token</dd>
<dt><strong><code>second_token_balance</code></strong> :&ensp;<code>int</code></dt>
<dd>balance of the second token</dd>
<dt><strong><code>owner_address</code></strong></dt>
<dd>owner address</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_token_exchange(self,
                          first_token_name: str,
                          first_token_balance: int,
                          second_token_name: str,
                          second_token_balance: int,
                          owner_address: str = None):
    &#34;&#34;&#34;Create an exchange between a token and another token.
    DO NOT USE THIS FOR TRX.
    Token Names should be a CASE SENSITIVE string.

    Args:
        first_token_name (str): the id of the first token
        first_token_balance (int): balance of the first token
        second_token_name (str): the id of the second token
        second_token_balance (int): balance of the second token
        owner_address: owner address

    &#34;&#34;&#34;
    if owner_address is None:
        owner_address = self.tron.default_address.hex

    if not self.tron.isAddress(owner_address):
        raise InvalidAddress(&#39;Invalid address provided&#39;)

    if second_token_balance &lt;= 0 or first_token_balance &lt;= 0:
        raise ValueError(&#39;Invalid amount provided&#39;)

    return self.tron.manager.request(&#39;/wallet/exchangecreate&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
        &#39;first_token_id&#39;: self.tron.toHex(text=first_token_name),
        &#39;first_token_balance&#39;: first_token_balance,
        &#39;second_token_id&#39;: self.tron.toHex(text=second_token_name),
        &#39;second_token_balance&#39;: second_token_balance
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.create_trx_exchange"><code class="name flex">
<span>def <span class="ident">create_trx_exchange</span></span>(<span>self, token_name: str, token_balance: int, trx_balance: int, account: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create an exchange between a token and TRX.
Token Name should be a CASE SENSITIVE string.
Note: PLEASE VERIFY THIS ON TRONSCAN.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Token Name</dd>
<dt><strong><code>token_balance</code></strong> :&ensp;<code>int</code></dt>
<dd>balance of the first token</dd>
<dt><strong><code>trx_balance</code></strong> :&ensp;<code>int</code></dt>
<dd>balance of the second token</dd>
<dt><strong><code>account</code></strong> :&ensp;<code>str</code></dt>
<dd>Owner Address</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_trx_exchange(self,
                        token_name: str,
                        token_balance: int,
                        trx_balance: int,
                        account: str = None):
    &#34;&#34;&#34;Create an exchange between a token and TRX.
    Token Name should be a CASE SENSITIVE string.
    Note: PLEASE VERIFY THIS ON TRONSCAN.

    Args:
        token_name (str): Token Name
        token_balance (int): balance of the first token
        trx_balance (int): balance of the second token
        account (str): Owner Address
    &#34;&#34;&#34;

    # If the address of the sender is not specified, we prescribe the default
    if account is None:
        account = self.tron.default_address.hex

    if not self.tron.isAddress(account):
        raise TronError(&#39;Invalid address provided&#39;)

    if token_balance &lt;= 0 or trx_balance &lt;= 0:
        raise TronError(&#39;Invalid amount provided&#39;)

    return self.tron.manager.request(&#39;/wallet/exchangecreate&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(account),
        &#39;first_token_id&#39;: self.tron.toHex(text=token_name),
        &#39;first_token_balance&#39;: token_balance,
        &#39;second_token_id&#39;: &#39;5f&#39;,
        &#39;second_token_balance&#39;: trx_balance
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.debug_input_kv"><code class="name flex">
<span>def <span class="ident">debug_input_kv</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_input_kv(self, data):
    if self.debug:
        print(&#34;==checking input data&#34;)
        print(data)
        print(&#34;==end&#34;)</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.debug_url_req"><code class="name flex">
<span>def <span class="ident">debug_url_req</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_url_req(self, data):
    if self.debug:
        print(&#34;==data load on request url&#34;)
        print(data)
        print(&#34;==end&#34;)</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.delete_proposal"><code class="name flex">
<span>def <span class="ident">delete_proposal</span></span>(<span>self, proposal_id: int, issuer_address: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete proposal</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proposal_id</code></strong> :&ensp;<code>int</code></dt>
<dd>proposal id</dd>
<dt><strong><code>issuer_address</code></strong> :&ensp;<code>str</code></dt>
<dd>delete the person's address</dd>
</dl>
<h2 id="results">Results</h2>
<p>Delete the proposal's transaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_proposal(self, proposal_id: int, issuer_address: str = None):
    &#34;&#34;&#34;Delete proposal

    Args:
        proposal_id (int): proposal id
        issuer_address (str): delete the person&#39;s address

    Results:
        Delete the proposal&#39;s transaction

    &#34;&#34;&#34;

    # If the address of the sender is not specified, we prescribe the default
    if issuer_address is None:
        issuer_address = self.tron.default_address.hex

    if not self.tron.isAddress(issuer_address):
        raise InvalidTronError(&#39;Invalid issuer_address provided&#39;)

    if not isinstance(proposal_id, int) or proposal_id &lt; 0:
        raise InvalidTronError(&#39;Invalid proposal_id provided&#39;)

    return self.tron.manager.request(&#39;/wallet/proposaldelete&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(issuer_address),
        &#39;proposal_id&#39;: int(proposal_id)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.freeze_balance"><code class="name flex">
<span>def <span class="ident">freeze_balance</span></span>(<span>self, amount, duration, resource, account=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Freezes an amount of TRX.
Will give bandwidth OR Energy and TRON Power(voting rights)
to the owner of the frozen tokens.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>number of frozen trx</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>int</code></dt>
<dd>duration in days to be frozen</dd>
<dt><strong><code>resource</code></strong> :&ensp;<code>str</code></dt>
<dd>type of resource, must be either "ENERGY" or "BANDWIDTH"</dd>
<dt><strong><code>account</code></strong> :&ensp;<code>str</code></dt>
<dd>address that is freezing trx account</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freeze_balance(self, amount, duration, resource, account=None):
    &#34;&#34;&#34;
    Freezes an amount of TRX.
    Will give bandwidth OR Energy and TRON Power(voting rights)
    to the owner of the frozen tokens.

    Args:
        amount (int): number of frozen trx
        duration (int): duration in days to be frozen
        resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
        account (str): address that is freezing trx account

    &#34;&#34;&#34;

    # If the address of the sender is not specified, we prescribe the default
    if account is None:
        account = self.tron.default_address.hex

    if resource not in (&#39;BANDWIDTH&#39;, &#39;ENERGY&#39;,):
        raise InvalidTronError(&#39;Invalid resource provided: Expected &#34;BANDWIDTH&#34; or &#34;ENERGY&#34;&#39;)

    if not is_integer(amount) or amount &lt;= 0:
        raise InvalidTronError(&#39;Invalid amount provided&#39;)

    if not is_integer(duration) or duration &lt; 3:
        raise InvalidTronError(&#39;Invalid duration provided, minimum of 3 days&#39;)

    if not self.tron.isAddress(account):
        raise InvalidTronError(&#39;Invalid address provided&#39;)

    response = self.tron.manager.request(&#39;/wallet/freezebalance&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(account),
        &#39;frozen_balance&#39;: self.tron.toSun(amount),
        &#39;frozen_duration&#39;: int(duration),
        &#39;resource&#39;: resource
    })

    if &#39;Error&#39; in response:
        raise TronError(response[&#39;Error&#39;])

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.inject_exchange_tokens"><code class="name flex">
<span>def <span class="ident">inject_exchange_tokens</span></span>(<span>self, exchange_id: int, token_name: str, token_amount: int = 0, owner_address: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds tokens into a bancor style exchange.
Will add both tokens at market rate.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exchange_id</code></strong> :&ensp;<code>int</code></dt>
<dd>non-negative integer exchange id</dd>
<dt><strong><code>token_name</code></strong> :&ensp;<code>str</code></dt>
<dd>token name</dd>
<dt><strong><code>token_amount</code></strong> :&ensp;<code>int</code></dt>
<dd>amount of token</dd>
<dt><strong><code>owner_address</code></strong> :&ensp;<code>str</code></dt>
<dd>token owner address in hex</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def inject_exchange_tokens(self,
                           exchange_id: int,
                           token_name: str,
                           token_amount: int = 0,
                           owner_address: str = None):
    &#34;&#34;&#34;Adds tokens into a bancor style exchange.
    Will add both tokens at market rate.

    Args:
        exchange_id (int): non-negative integer exchange id
        token_name (str): token name
        token_amount (int): amount of token
        owner_address (str): token owner address in hex

    &#34;&#34;&#34;
    if owner_address is None:
        owner_address = self.tron.default_address.hex

    if not self.tron.isAddress(owner_address):
        raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

    if exchange_id &lt; 0:
        raise ValueError(&#39;Invalid exchange_id provided&#39;)

    if token_amount &lt; 1:
        raise ValueError(&#39;Invalid token_amount provided&#39;)

    return self.tron.manager.request(&#39;/wallet/exchangeinject&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
        &#39;exchange_id&#39;: exchange_id,
        &#39;token_id&#39;: self.tron.toHex(text=token_name),
        &#39;quant&#39;: token_amount
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.purchase_token"><code class="name flex">
<span>def <span class="ident">purchase_token</span></span>(<span>self, to: str, token_id: str, amount: int, buyer=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Purchase a Token
Creates an unsigned ICO token purchase transaction.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>to</code></strong> :&ensp;<code>str</code></dt>
<dd>is the address of the Token issuer</dd>
<dt><strong><code>token_id</code></strong> :&ensp;<code>str</code></dt>
<dd>is the name of the token</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>is the number of tokens created</dd>
<dt><strong><code>buyer</code></strong> :&ensp;<code>str</code></dt>
<dd>is the address of the Token owner</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def purchase_token(self, to: str, token_id: str, amount: int, buyer=None):
    &#34;&#34;&#34;Purchase a Token
    Creates an unsigned ICO token purchase transaction.

    Args:
        to (str): is the address of the Token issuer
        token_id (str): is the name of the token
        amount (int): is the number of tokens created
        buyer (str): is the address of the Token owner

    &#34;&#34;&#34;

    if buyer is None:
        buyer = self.tron.default_address.hex

    if not self.tron.isAddress(to):
        raise InvalidAddress(&#39;Invalid to address provided&#39;)

    if not len(token_id):
        raise ValueError(&#39;Invalid token ID provided&#39;)

    if amount &lt;= 0:
        raise ValueError(&#39;Invalid amount provided&#39;)

    _to = self.tron.address.to_hex(to)
    _from = self.tron.address.to_hex(buyer)

    return self.tron.manager.request(&#39;/wallet/participateassetissue&#39;, {
        &#39;to_address&#39;: _to,
        &#39;owner_address&#39;: _from,
        &#39;asset_name&#39;: self.tron.toHex(text=token_id),
        &#39;amount&#39;: int(amount)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.send_token"><code class="name flex">
<span>def <span class="ident">send_token</span></span>(<span>self, to, amount, token_id, account=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Transfer Token</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>to</code></strong> :&ensp;<code>str</code></dt>
<dd>is the recipient address</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>is the amount of token to transfer. must be integer instead of float</dd>
<dt><strong><code>token_id</code></strong> :&ensp;<code>any</code></dt>
<dd>Token Name and id</dd>
<dt><strong><code>account</code></strong></dt>
<dd>(str): is the address of the withdrawal account</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Token transfer Transaction raw data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_token(self, to, amount, token_id, account=None):
    &#34;&#34;&#34;Transfer Token

    Args:
        to (str): is the recipient address
        amount (int): is the amount of token to transfer. must be integer instead of float
        token_id (any): Token Name and id
        account: (str): is the address of the withdrawal account

    Returns:
        Token transfer Transaction raw data

    &#34;&#34;&#34;

    # If the address of the sender is not specified, we prescribe the default
    if account is None:
        account = self.tron.default_address.hex

    if not self.tron.isAddress(to):
        raise InvalidTronError(&#39;Invalid recipient address provided&#39;)

    if not isinstance(amount, int) or amount &lt;= 0:
        raise InvalidTronError(&#39;Invalid amount provided&#39;)

    if not token_id:
        raise InvalidTronError(&#39;Invalid token ID provided&#39;)

    if not self.tron.isAddress(account):
        raise InvalidTronError(&#39;Invalid origin address provided&#39;)

    _to = self.tron.address.to_hex(to)
    _from = self.tron.address.to_hex(account)
    _token_id = self.tron.toHex(text=str(token_id))

    if _to == _from:
        raise TronError(&#39;Cannot transfer TRX to the same account&#39;)

    # In case if &#34;TRX&#34; is specified, we redirect to another method.
    if is_string(token_id) and token_id.upper() == &#39;TRX&#39;:
        return self.send_transaction(_to, amount, _from)

    return self.tron.manager.request(&#39;/wallet/transferasset&#39;, {
        &#39;to_address&#39;: _to,
        &#39;owner_address&#39;: _from,
        &#39;asset_name&#39;: _token_id,
        &#39;amount&#39;: amount
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, to, amount, account=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a transaction of transfer.
If the recipient address does not exist, a corresponding account will be created.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>to</code></strong> :&ensp;<code>str</code></dt>
<dd>to address</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>float</code></dt>
<dd>amount</dd>
<dt><strong><code>account</code></strong> :&ensp;<code>str</code></dt>
<dd>from address</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Transaction contract data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, to, amount, account=None):
    &#34;&#34;&#34;Creates a transaction of transfer.
    If the recipient address does not exist, a corresponding account will be created.

    Args:
        to (str): to address
        amount (float): amount
        account (str): from address

    Returns:
        Transaction contract data

    &#34;&#34;&#34;

    # If the address of the sender is not specified, we prescribe the default
    if account is None:
        account = self.tron.default_address.hex

    if not self.tron.isAddress(to):
        raise InvalidTronError(&#39;Invalid recipient address provided&#39;)

    if not isinstance(amount, float) or amount &lt;= 0:
        raise InvalidTronError(&#39;Invalid amount provided&#39;)

    _to = self.tron.address.to_hex(to)
    _from = self.tron.address.to_hex(account)

    if _to == _from:
        raise TronError(&#39;Cannot transfer TRX to the same account&#39;)

    response = self.tron.manager.request(&#39;/wallet/createtransaction&#39;, {
        &#39;to_address&#39;: _to,
        &#39;owner_address&#39;: _from,
        &#39;amount&#39;: self.tron.toSun(amount)
    })

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.setDebug"><code class="name flex">
<span>def <span class="ident">setDebug</span></span>(<span>self, b: bool) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDebug(self, b: bool) -&gt; None:
    self.debug = b</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.trade_exchange_tokens"><code class="name flex">
<span>def <span class="ident">trade_exchange_tokens</span></span>(<span>self, exchange_id: int, token_name: str, token_amount_sold: int = 0, token_amount_expected: int = 0, owner_address: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Trade tokens on a bancor style exchange.
Expected value is a validation and used to cap the total amt of token 2 spent.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exchange_id</code></strong> :&ensp;<code>int</code></dt>
<dd>non-negative integer exchange id</dd>
<dt><strong><code>token_name</code></strong> :&ensp;<code>str</code></dt>
<dd>token name</dd>
<dt><strong><code>token_amount_sold</code></strong> :&ensp;<code>int</code></dt>
<dd>amount f token actually sold</dd>
<dt><strong><code>token_amount_expected</code></strong> :&ensp;<code>int</code></dt>
<dd>amount of token expected</dd>
<dt><strong><code>owner_address</code></strong> :&ensp;<code>str</code></dt>
<dd>token owner address in hex</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trade_exchange_tokens(self,
                          exchange_id: int,
                          token_name: str,
                          token_amount_sold: int = 0,
                          token_amount_expected: int = 0,
                          owner_address: str = None):
    &#34;&#34;&#34;Trade tokens on a bancor style exchange.
    Expected value is a validation and used to cap the total amt of token 2 spent.

    Args:
        exchange_id (int): non-negative integer exchange id
        token_name (str): token name
        token_amount_sold (int): amount f token actually sold
        token_amount_expected (int): amount of token expected
        owner_address (str): token owner address in hex

    &#34;&#34;&#34;

    if owner_address is None:
        owner_address = self.tron.default_address.hex

    if not self.tron.isAddress(owner_address):
        raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

    if exchange_id &lt; 0:
        raise ValueError(&#39;Invalid exchange_id provided&#39;)

    if token_amount_sold &lt; 1:
        raise ValueError(&#39;Invalid token_amount_sold provided&#39;)

    if token_amount_expected &lt; 1:
        raise ValueError(&#39;Invalid token_amount_expected provided&#39;)

    return self.tron.manager.request(&#39;/wallet/exchangewithdraw&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
        &#39;exchange_id&#39;: exchange_id,
        &#39;token_id&#39;: self.tron.toHex(text=token_name),
        &#39;quant&#39;: token_amount_sold,
        &#39;expected&#39;: token_amount_expected
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.trigger_smart_contract"><code class="name flex">
<span>def <span class="ident">trigger_smart_contract</span></span>(<span>self, kv: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Trigger Smart Contract
Calls a function on a contract</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**kv</code></strong></dt>
<dd>Fill in the required parameters</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; tron = Tron()
&gt;&gt;&gt; tron.transaction_builder.trigger_smart_contract(
&gt;&gt;&gt;     contract_address='413c8143e98b3e2fe1b1a8fb82b34557505a752390',
&gt;&gt;&gt;     function_selector='set(uint256,uint256)',
&gt;&gt;&gt;     fee_limit=30000,
&gt;&gt;&gt;     call_value=0,
&gt;&gt;&gt;     parameters=[
&gt;&gt;&gt;        {'type': 'int256', 'value': 1},
&gt;&gt;&gt;        {'type': 'int256', 'value': 1}])
</code></pre>
<h2 id="returns">Returns</h2>
<p>TransactionExtention, TransactionExtention contains unsigned Transaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trigger_smart_contract(self, kv: dict):

    &#34;&#34;&#34;Trigger Smart Contract
    Calls a function on a contract

    Args:
        **kv: Fill in the required parameters

    Examples:
        &gt;&gt;&gt; tron = Tron()
        &gt;&gt;&gt; tron.transaction_builder.trigger_smart_contract(
        &gt;&gt;&gt;     contract_address=&#39;413c8143e98b3e2fe1b1a8fb82b34557505a752390&#39;,
        &gt;&gt;&gt;     function_selector=&#39;set(uint256,uint256)&#39;,
        &gt;&gt;&gt;     fee_limit=30000,
        &gt;&gt;&gt;     call_value=0,
        &gt;&gt;&gt;     parameters=[
        &gt;&gt;&gt;        {&#39;type&#39;: &#39;int256&#39;, &#39;value&#39;: 1},
        &gt;&gt;&gt;        {&#39;type&#39;: &#39;int256&#39;, &#39;value&#39;: 1}])

    Returns:
        TransactionExtention, TransactionExtention contains unsigned Transaction
    &#34;&#34;&#34;

    contract_address = kv.setdefault(&#39;contract_address&#39;, None)
    function_selector = kv.setdefault(&#39;function_selector&#39;, None)

    issuer_address = kv.setdefault(&#39;issuer_address&#39;, self.tron.default_address.hex)
    call_value = kv.setdefault(&#39;call_value&#39;, 0)
    fee_limit = kv.setdefault(&#39;fee_limit&#39;, 1000000000)
    token_value = kv.setdefault(&#39;token_value&#39;, 0)
    token_id = kv.setdefault(&#39;token_id&#39;, 0)
    parameters = kv.setdefault(&#39;parameters&#39;, [])

    if not is_integer(token_value) or token_value &lt; 0:
        raise ValueError(&#39;Invalid options.tokenValue provided&#39;)

    if not is_integer(token_id) or token_id &lt; 0:
        raise ValueError(&#39;Invalid options.tokenId provided&#39;)

    if not self.tron.isAddress(contract_address):
        raise InvalidAddress(&#39;Invalid contract address provided&#39;)

    if not is_string(function_selector):
        raise ValueError(&#39;Invalid function selector provided&#39;)

    if not is_integer(call_value) or call_value &lt; 0:
        raise ValueError(&#39;Invalid call value provided&#39;)

    if not is_integer(fee_limit) or fee_limit &lt;= 0 or fee_limit &gt; 1000000000:
        raise ValueError(&#39;Invalid fee limit provided&#39;)

    &#34;&#34;&#34;remove all the spaces&#34;&#34;&#34;
    function_selector = function_selector.replace(&#39;/\s*/g&#39;, &#39;&#39;)
    print(parameters)
    print(&#34;-------------- this is the last parameters.. &#34;)
    if len(parameters) &gt; 0:
        types = []
        values = []
        for abi in parameters:
            if &#39;type&#39; not in abi or not is_string(abi[&#39;type&#39;]):
                raise ValueError(&#39;Invalid parameter type provided: &#39; + abi[&#39;type&#39;])
            if abi[&#39;type&#39;] == &#39;address&#39;:
                abi[&#39;value&#39;] = self.tron.address.to_hex(abi[&#39;value&#39;]).replace(&#39;41&#39;, &#39;0x&#39;, 1)
            types.append(abi[&#39;type&#39;])
            values.append(abi[&#39;value&#39;])

        try:
            parameters = encode_hex(encode_abi(types, values)).replace(&#39;0x&#39;, &#39;&#39;, 2)
        except ValueError as ex:
            print(ex)

    else:
        parameters = &#39;&#39;

    data = {
        &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
        &#39;owner_address&#39;: issuer_address.hex,
        &#39;function_selector&#39;: function_selector,
        &#39;fee_limit&#39;: int(fee_limit),
        &#39;call_value&#39;: int(call_value),
        &#39;parameter&#39;: parameters
    }

    # if parameters is &#39;&#39;:
    #    data.pop(&#39;parameter&#39;)
    self.debug_input_kv(kv)
    if token_value:
        data[&#39;call_token_value&#39;] = int(token_value)

    if token_id:
        data[&#39;token_id&#39;] = int(token_id)
    self.debug_url_req(data)
    return self.tron.manager.request(&#39;/wallet/triggersmartcontract&#39;, data)</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.trigger_smart_contract_constant"><code class="name flex">
<span>def <span class="ident">trigger_smart_contract_constant</span></span>(<span>self, kv: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trigger_smart_contract_constant(self, kv: dict):

    contract_address = kv.setdefault(&#39;contract_address&#39;, None)
    function_selector = kv.setdefault(&#39;function_selector&#39;, None)

    issuer_address = kv.setdefault(&#39;issuer_address&#39;, self.tron.default_address.hex)
    call_value = kv.setdefault(&#39;call_value&#39;, 0)
    fee_limit = kv.setdefault(&#39;fee_limit&#39;, 1000000000)
    token_value = kv.setdefault(&#39;token_value&#39;, 0)
    token_id = kv.setdefault(&#39;token_id&#39;, 0)

    if not is_integer(token_value) or token_value &lt; 0:
        raise ValueError(&#39;Invalid options.tokenValue provided&#39;)

    if not is_integer(token_id) or token_id &lt; 0:
        raise ValueError(&#39;Invalid options.tokenId provided&#39;)

    if not self.tron.isAddress(contract_address):
        raise InvalidAddress(&#39;Invalid contract address provided&#39;)

    if not is_string(function_selector):
        raise ValueError(&#39;Invalid function selector provided&#39;)

    if not is_integer(call_value) or call_value &lt; 0:
        raise ValueError(&#39;Invalid call value provided&#39;)

    if not is_integer(fee_limit) or fee_limit &lt;= 0 or fee_limit &gt; 1000000000:
        raise ValueError(&#39;Invalid fee limit provided&#39;)

    &#34;&#34;&#34;remove all the spaces&#34;&#34;&#34;
    function_selector = function_selector.replace(&#39;/\s*/g&#39;, &#39;&#39;)

    if hasattr(kv, &#34;parameters&#34;) and len(kv[&#39;parameters&#39;]) &gt; 0:
        types = []
        values = []
        parameters = kv[&#39;parameters&#39;]
        for abi in parameters:
            if &#39;type&#39; not in abi or not is_string(abi[&#39;type&#39;]):
                raise ValueError(&#39;Invalid parameter type provided: &#39; + abi[&#39;type&#39;])

            if abi[&#39;type&#39;] == &#39;address&#39;:
                abi[&#39;value&#39;] = self.tron.address.to_hex(abi[&#39;value&#39;]).replace(&#39;41&#39;, &#39;0x&#39;, 1)

            types.append(abi[&#39;type&#39;])
            values.append(abi[&#39;value&#39;])

        try:
            parameters = encode_hex(encode_abi(types, values)).replace(&#39;0x&#39;, &#39;&#39;, 2)
        except ValueError as ex:
            print(ex)

    else:
        parameters = []

    self.debug_input_kv(kv)

    data = {
        &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
        &#39;owner_address&#39;: issuer_address.hex,
        &#39;function_selector&#39;: function_selector,
        &#39;fee_limit&#39;: int(fee_limit),
        &#39;call_value&#39;: int(call_value),
        &#39;parameter&#39;: parameters
    }

    if token_value:
        data[&#39;call_token_value&#39;] = int(token_value)

    if token_id:
        data[&#39;token_id&#39;] = int(token_id)

    self.debug_url_req(data)

    return self.tron.manager.request(&#39;/wallet/triggerconstantcontract&#39;, kv)</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.unfreeze_balance"><code class="name flex">
<span>def <span class="ident">unfreeze_balance</span></span>(<span>self, resource='BANDWIDTH', account=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Unfreeze TRX that has passed the minimum freeze duration.
Unfreezing will remove bandwidth and TRON Power.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource</code></strong> :&ensp;<code>str</code></dt>
<dd>type of resource, must be either "ENERGY" or "BANDWIDTH"</dd>
<dt><strong><code>account</code></strong> :&ensp;<code>str</code></dt>
<dd>address that is freezing trx account</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unfreeze_balance(self, resource=&#39;BANDWIDTH&#39;, account=None):
    &#34;&#34;&#34;
    Unfreeze TRX that has passed the minimum freeze duration.
    Unfreezing will remove bandwidth and TRON Power.

    Args:
        resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
        account (str): address that is freezing trx account

    &#34;&#34;&#34;

    # If the address of the sender is not specified, we prescribe the default
    if account is None:
        account = self.tron.default_address.hex

    if resource not in (&#39;BANDWIDTH&#39;, &#39;ENERGY&#39;,):
        raise InvalidTronError(&#39;Invalid resource provided: Expected &#34;BANDWIDTH&#34; or &#34;ENERGY&#34;&#39;)

    if not self.tron.isAddress(account):
        raise InvalidTronError(&#39;Invalid address provided&#39;)

    response = self.tron.manager.request(&#39;/wallet/unfreezebalance&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(account),
        &#39;resource&#39;: resource
    })

    if &#39;Error&#39; in response:
        raise ValueError(response[&#39;Error&#39;])

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.update_account"><code class="name flex">
<span>def <span class="ident">update_account</span></span>(<span>self, account_name, account: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Modify account name</p>
<p>Note: Username is allowed to edit only once.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>account_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the account</dd>
<dt><strong><code>account</code></strong> :&ensp;<code>str</code></dt>
<dd>address</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>modified Transaction Object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_account(self, account_name, account: str = None):
    &#34;&#34;&#34;Modify account name

    Note: Username is allowed to edit only once.

    Args:
        account_name (str): name of the account
        account (str): address

    Returns:
        modified Transaction Object

    &#34;&#34;&#34;

    # If the address of the sender is not specified, we prescribe the default
    if account is None:
        account = self.tron.default_address.hex

    if not is_string(account_name):
        raise ValueError(&#39;Name must be a string&#39;)

    if not self.tron.isAddress(account):
        raise TronError(&#39;Invalid origin address provided&#39;)

    response = self.tron.manager.request(&#39;/wallet/updateaccount&#39;, {
        &#39;account_name&#39;: self.tron.toHex(text=account_name),
        &#39;owner_address&#39;: self.tron.address.to_hex(account)
    })

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.update_account_permissions"><code class="name flex">
<span>def <span class="ident">update_account_permissions</span></span>(<span>self, owner_address=None, owner_permissions=None, witness_permissions=None, actives_permissions=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Role: update user permissions (for multi-signature)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>owner_address</code></strong> :&ensp;<code>str</code></dt>
<dd>The address of the account whose permissions are to be modified</dd>
<dt><strong><code>owner_permissions</code></strong></dt>
<dd>Modified owner permission</dd>
<dt><strong><code>witness_permissions</code></strong></dt>
<dd>Modified witness permission (if it is a witness)</dd>
<dt><strong><code>actives_permissions</code></strong></dt>
<dd>Modified actives permission</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_account_permissions(self, owner_address=None,
                               owner_permissions=None,
                               witness_permissions=None,
                               actives_permissions=None
                               ):
    &#34;&#34;&#34;Role: update user permissions (for multi-signature)

    Args:
        owner_address (str): The address of the account whose permissions are to be modified
        owner_permissions: Modified owner permission
        witness_permissions: Modified witness permission (if it is a witness)
        actives_permissions: Modified actives permission
    &#34;&#34;&#34;

    if owner_address is None:
        owner_address = self.tron.default_address.hex

    if not self.check_permissions(owner_permissions, 0):
        raise InvalidTronError(&#39;Invalid ownerPermissions provided&#39;)

    if not self.check_permissions(witness_permissions, 1):
        raise InvalidTronError(&#39;Invalid witnessPermissions provided&#39;)

    for actives_permission in actives_permissions:
        if not self.check_permissions(actives_permission, 2):
            raise InvalidTronError(&#39;Invalid activesPermissions provided&#39;)

    data = {
        owner_address: owner_address
    }

    if owner_permissions:
        data[&#39;owner&#39;] = owner_permissions

    if witness_permissions:
        data[&#39;witness&#39;] = witness_permissions

    if actives_permissions:
        if len(actives_permissions) == 1:
            data[&#39;actives&#39;] = actives_permissions[0]
        else:
            data[&#39;actives&#39;] = actives_permissions

    return self.tron.manager.request(&#39;wallet/accountpermissionupdate&#39;, data)</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.update_energy_limit"><code class="name flex">
<span>def <span class="ident">update_energy_limit</span></span>(<span>self, contract_address, origin_energy_limit, owner_address: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Update energy limit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>contract_address</code></strong> :&ensp;<code>str</code></dt>
<dd>The address of the contract to be modified</dd>
<dt><strong><code>origin_energy_limit</code></strong> :&ensp;<code>int</code></dt>
<dd>The maximum energy set by the creator that is created</dd>
<dt><strong><code>owner_address</code></strong> :&ensp;<code>str</code></dt>
<dd>Is the address of the creator</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Contains unsigned transaction Transaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_energy_limit(self,
                        contract_address,
                        origin_energy_limit,
                        owner_address: str = None):
    &#34;&#34;&#34;Update energy limit.

    Args:
        contract_address (str): The address of the contract to be modified
        origin_energy_limit (int): The maximum energy set by the creator that is created
        owner_address (str): Is the address of the creator

    Returns:
        Contains unsigned transaction Transaction
    &#34;&#34;&#34;

    if owner_address is None:
        owner_address = self.tron.default_address.hex

    if not self.tron.isAddress(owner_address):
        raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

    if not self.tron.isAddress(contract_address):
        raise InvalidAddress(&#39;Invalid contractAddress provided&#39;)

    if not is_integer(origin_energy_limit) or origin_energy_limit &lt; 0 or \
            origin_energy_limit &gt; 10000000:
        raise ValueError(&#39;Invalid originEnergyLimit  provided&#39;)

    return self.tron.manager.request(&#39;wallet/updateenergylimit&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
        &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
        &#39;origin_energy_limit&#39;: origin_energy_limit
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.update_setting"><code class="name flex">
<span>def <span class="ident">update_setting</span></span>(<span>self, contract_address, user_fee_percentage, owner_address: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Update userFeePercentage.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>contract_address</code></strong> :&ensp;<code>str</code></dt>
<dd>the address of the contract to be modified</dd>
<dt><strong><code>user_fee_percentage</code></strong> :&ensp;<code>int</code></dt>
<dd>the percentage of resources specified for users using this contract</dd>
<dt><strong><code>owner_address</code></strong> :&ensp;<code>str</code></dt>
<dd>is the address of the creator</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Contains unsigned transaction Transaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_setting(self,
                   contract_address,
                   user_fee_percentage,
                   owner_address: str = None):
    &#34;&#34;&#34;Update userFeePercentage.

    Args:
        contract_address (str): the address of the contract to be modified
        user_fee_percentage (int): the percentage of resources specified for users using this contract
        owner_address (str): is the address of the creator

    Returns:
        Contains unsigned transaction Transaction
    &#34;&#34;&#34;

    if owner_address is None:
        owner_address = self.tron.default_address.hex

    if not self.tron.isAddress(owner_address):
        raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

    if not self.tron.isAddress(contract_address):
        raise InvalidAddress(&#39;Invalid contract_address provided&#39;)

    if not is_integer(user_fee_percentage) or user_fee_percentage &lt; 0 or \
            user_fee_percentage &gt; 100:
        raise ValueError(&#39;Invalid user_fee_percentage provided&#39;)

    return self.tron.manager.request(&#39;wallet/updatesetting&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
        &#39;contract_address&#39;: self.tron.address.to_hex(contract_address),
        &#39;consume_user_resource_percent&#39;: user_fee_percentage
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.vote"><code class="name flex">
<span>def <span class="ident">vote</span></span>(<span>self, votes: List[Tuple[str, int]], voter_address: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Vote
Vote on the super representative</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>votes</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary of SR address : vote count key-value pair</dd>
<dt><strong><code>voter_address</code></strong></dt>
<dd>voter address</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; from tronpytool import Tron
&gt;&gt;&gt; data = [
&gt;&gt;&gt;     ('TRJpw2uqohP7FUmAEJgt57wakRn6aGQU6Z', 1)
&gt;&gt;&gt; ]
&gt;&gt;&gt; tron = Tron()
&gt;&gt;&gt; tron.transaction.vote(data)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vote(self, votes: List[Tuple[str, int]], voter_address: str = None):
    &#34;&#34;&#34;Vote
    Vote on the super representative

    Args:
        votes (dict): dictionary of SR address : vote count key-value pair
        voter_address: voter address

    Examples:
        &gt;&gt;&gt; from tronpytool import Tron
        &gt;&gt;&gt; data = [
        &gt;&gt;&gt;     (&#39;TRJpw2uqohP7FUmAEJgt57wakRn6aGQU6Z&#39;, 1)
        &gt;&gt;&gt; ]
        &gt;&gt;&gt; tron = Tron()
        &gt;&gt;&gt; tron.transaction.vote(data)

    &#34;&#34;&#34;
    if voter_address is None:
        voter_address = self.tron.default_address.hex

    _view_vote = []

    # We create a cycle to check all the received data for voting.
    for sr_address, vote_count in votes:
        if not self.tron.isAddress(sr_address):
            raise InvalidAddress(
                &#39;Invalid SR address provided: &#39; + sr_address
            )

        if not is_integer(vote_count) or vote_count &lt;= 0:
            raise ValueError(
                &#39;Invalid vote count provided for SR: &#39; + sr_address
            )

        _view_vote.append({
            &#39;vote_address&#39;: self.tron.address.to_hex(sr_address),
            &#39;vote_count&#39;: int(vote_count)
        })

    return self.tron.manager.request(&#39;/wallet/votewitnessaccount&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(voter_address),
        &#39;votes&#39;: _view_vote
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.vote_proposal"><code class="name flex">
<span>def <span class="ident">vote_proposal</span></span>(<span>self, proposal_id, has_approval, voter_address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Proposal approval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proposal_id</code></strong> :&ensp;<code>int</code></dt>
<dd>proposal id</dd>
<dt><strong><code>has_approval</code></strong> :&ensp;<code>bool</code></dt>
<dd>Approved</dd>
<dt><strong><code>voter_address</code></strong> :&ensp;<code>str</code></dt>
<dd>Approve address</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vote_proposal(self, proposal_id, has_approval, voter_address=None):
    &#34;&#34;&#34;Proposal approval

    Args:
        proposal_id (int): proposal id
        has_approval (bool): Approved
        voter_address (str): Approve address

    &#34;&#34;&#34;

    # If the address of the sender is not specified, we prescribe the default
    if voter_address is None:
        voter_address = self.tron.default_address.hex

    if not self.tron.isAddress(voter_address):
        raise TronError(&#39;Invalid voter_address address provided&#39;)

    if not is_integer(proposal_id) or proposal_id &lt; 0:
        raise TronError(&#39;Invalid proposal_id provided&#39;)

    if not is_boolean(has_approval):
        raise TronError(&#39;Invalid has_approval provided&#39;)

    return self.tron.manager.request(&#39;/wallet/proposalapprove&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(voter_address),
        &#39;proposal_id&#39;: int(proposal_id),
        &#39;is_add_approval&#39;: bool(has_approval)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.withdraw_block_rewards"><code class="name flex">
<span>def <span class="ident">withdraw_block_rewards</span></span>(<span>self, address: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Withdraw block rewards
Creates an unsigned Super Representative award balance withdraw transaction.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>Optional address to withdraw from.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def withdraw_block_rewards(self, address: str = None):
    &#34;&#34;&#34;Withdraw block rewards
    Creates an unsigned Super Representative award balance withdraw transaction.

    Args:
        address (str): Optional address to withdraw from.

    &#34;&#34;&#34;
    if not address:
        address = self.tron.default_address.hex

    if not self.tron.isAddress(address):
        raise InvalidAddress(&#39;Invalid address provided&#39;)

    return self.tron.manager.request(&#39;/wallet/withdrawbalance&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(address)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.transactionbuilder.TransactionBuilder.withdraw_exchange_tokens"><code class="name flex">
<span>def <span class="ident">withdraw_exchange_tokens</span></span>(<span>self, exchange_id: int, token_name: str, token_amount: int = 0, owner_address: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Withdraws tokens from a bancor style exchange.
Will withdraw at market rate both tokens.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exchange_id</code></strong> :&ensp;<code>int</code></dt>
<dd>non-negative integer exchange id</dd>
<dt><strong><code>token_name</code></strong> :&ensp;<code>str</code></dt>
<dd>token name</dd>
<dt><strong><code>token_amount</code></strong> :&ensp;<code>int</code></dt>
<dd>number of tokens withdraw</dd>
<dt><strong><code>owner_address</code></strong> :&ensp;<code>str</code></dt>
<dd>owner address in hex</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def withdraw_exchange_tokens(self,
                             exchange_id: int,
                             token_name: str,
                             token_amount: int = 0,
                             owner_address: str = None):
    &#34;&#34;&#34;Withdraws tokens from a bancor style exchange.
    Will withdraw at market rate both tokens.

    Args:
        exchange_id (int): non-negative integer exchange id
        token_name (str): token name
        token_amount (int): number of tokens withdraw
        owner_address (str): owner address in hex

    &#34;&#34;&#34;
    if owner_address is None:
        owner_address = self.tron.default_address.hex

    if not self.tron.isAddress(owner_address):
        raise InvalidAddress(&#39;Invalid owner_address provided&#39;)

    if exchange_id &lt; 0:
        raise ValueError(&#39;Invalid exchange_id provided&#39;)

    if token_amount &lt; 1:
        raise ValueError(&#39;Invalid token_amount provided&#39;)

    return self.tron.manager.request(&#39;/wallet/exchangewithdraw&#39;, {
        &#39;owner_address&#39;: self.tron.address.to_hex(owner_address),
        &#39;exchange_id&#39;: exchange_id,
        &#39;token_id&#39;: self.tron.toHex(text=token_name),
        &#39;quant&#39;: token_amount
    })</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tronpytool" href="index.html">tronpytool</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tronpytool.transactionbuilder.TransactionBuilder" href="#tronpytool.transactionbuilder.TransactionBuilder">TransactionBuilder</a></code></h4>
<ul class="">
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.apply_for_sr" href="#tronpytool.transactionbuilder.TransactionBuilder.apply_for_sr">apply_for_sr</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.check_permissions" href="#tronpytool.transactionbuilder.TransactionBuilder.check_permissions">check_permissions</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.create_proposal" href="#tronpytool.transactionbuilder.TransactionBuilder.create_proposal">create_proposal</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.create_smart_contract" href="#tronpytool.transactionbuilder.TransactionBuilder.create_smart_contract">create_smart_contract</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.create_token" href="#tronpytool.transactionbuilder.TransactionBuilder.create_token">create_token</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.create_token_exchange" href="#tronpytool.transactionbuilder.TransactionBuilder.create_token_exchange">create_token_exchange</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.create_trx_exchange" href="#tronpytool.transactionbuilder.TransactionBuilder.create_trx_exchange">create_trx_exchange</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.debug" href="#tronpytool.transactionbuilder.TransactionBuilder.debug">debug</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.debug_input_kv" href="#tronpytool.transactionbuilder.TransactionBuilder.debug_input_kv">debug_input_kv</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.debug_url_req" href="#tronpytool.transactionbuilder.TransactionBuilder.debug_url_req">debug_url_req</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.delete_proposal" href="#tronpytool.transactionbuilder.TransactionBuilder.delete_proposal">delete_proposal</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.freeze_balance" href="#tronpytool.transactionbuilder.TransactionBuilder.freeze_balance">freeze_balance</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.inject_exchange_tokens" href="#tronpytool.transactionbuilder.TransactionBuilder.inject_exchange_tokens">inject_exchange_tokens</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.purchase_token" href="#tronpytool.transactionbuilder.TransactionBuilder.purchase_token">purchase_token</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.send_token" href="#tronpytool.transactionbuilder.TransactionBuilder.send_token">send_token</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.send_transaction" href="#tronpytool.transactionbuilder.TransactionBuilder.send_transaction">send_transaction</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.setDebug" href="#tronpytool.transactionbuilder.TransactionBuilder.setDebug">setDebug</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.trade_exchange_tokens" href="#tronpytool.transactionbuilder.TransactionBuilder.trade_exchange_tokens">trade_exchange_tokens</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.trigger_smart_contract" href="#tronpytool.transactionbuilder.TransactionBuilder.trigger_smart_contract">trigger_smart_contract</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.trigger_smart_contract_constant" href="#tronpytool.transactionbuilder.TransactionBuilder.trigger_smart_contract_constant">trigger_smart_contract_constant</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.unfreeze_balance" href="#tronpytool.transactionbuilder.TransactionBuilder.unfreeze_balance">unfreeze_balance</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.update_account" href="#tronpytool.transactionbuilder.TransactionBuilder.update_account">update_account</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.update_account_permissions" href="#tronpytool.transactionbuilder.TransactionBuilder.update_account_permissions">update_account_permissions</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.update_energy_limit" href="#tronpytool.transactionbuilder.TransactionBuilder.update_energy_limit">update_energy_limit</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.update_setting" href="#tronpytool.transactionbuilder.TransactionBuilder.update_setting">update_setting</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.vote" href="#tronpytool.transactionbuilder.TransactionBuilder.vote">vote</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.vote_proposal" href="#tronpytool.transactionbuilder.TransactionBuilder.vote_proposal">vote_proposal</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.withdraw_block_rewards" href="#tronpytool.transactionbuilder.TransactionBuilder.withdraw_block_rewards">withdraw_block_rewards</a></code></li>
<li><code><a title="tronpytool.transactionbuilder.TransactionBuilder.withdraw_exchange_tokens" href="#tronpytool.transactionbuilder.TransactionBuilder.withdraw_exchange_tokens">withdraw_exchange_tokens</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>