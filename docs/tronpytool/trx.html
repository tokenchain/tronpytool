<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>tronpytool.trx API documentation</title>
<meta name="description" content="tronpytool.trx
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tronpytool.trx</code></h1>
</header>
<section id="section-intro">
<h1 id="tronpytooltrx">tronpytool.trx</h1>
<p>Work with basic methods</p>
<p>:copyright: © 2018 by the iEXBase.
:license: MIT License</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
#
# --------------------------------------------------------------------
# Copyright (c) iEXBase. All rights reserved.
# Licensed under the MIT License.
# See License.txt in the project root for license information.
# --------------------------------------------------------------------

&#34;&#34;&#34;
    tronpytool.trx
    ===============

    Work with basic methods

    :copyright: © 2018 by the iEXBase.
    :license: MIT License
&#34;&#34;&#34;

import math
from typing import Any

from trx_utils import is_integer, is_hex
from trx_utils.types import is_object, is_string, is_list

from tronpytool.common import key
from tronpytool.common.account import Account
from tronpytool.common.blocks import select_method_for_block
from tronpytool.common.toolz import (
    assoc
)
from tronpytool.common.transactions import wait_for_transaction_id
from tronpytool.contract import Contract
from tronpytool.exceptions import InvalidTronError, TronError, TimeExhausted, AssetNotFound
from tronpytool.module import Module

TRX_MESSAGE_HEADER = &#39;\x19TRON Signed Message:\n&#39;
ETH_MESSAGE_HEADER = &#39;\x19Ethereum Signed Message:\n&#39;


class Trx(Module):
    default_contract_factory = Contract

    def get_current_block(self):
        &#34;&#34;&#34;Query the latest block&#34;&#34;&#34;
        return self.tron.manager.request(url=&#39;/wallet/getnowblock&#39;)

    def get_confirmed_current_block(self):
        &#34;&#34;&#34;Query the confirmed latest block&#34;&#34;&#34;
        return self.tron.manager.request(&#39;/walletsolidity/getnowblock&#39;)

    def get_block(self, block: Any = None):
        &#34;&#34;&#34;Get block details using HashString or blockNumber

        Args:
            block (Any): ID or height for the block

        &#34;&#34;&#34;

        # If the block identifier is not specified,
        # we take the default
        if block is None:
            block = self.tron.default_block

        if block == &#39;latest&#39;:
            return self.get_current_block()
        elif block == &#39;earliest&#39;:
            return self.get_block(0)

        method = select_method_for_block(
            block,
            if_hash={&#39;url&#39;: &#39;/wallet/getblockbyid&#39;, &#39;field&#39;: &#39;value&#39;},
            if_number={&#39;url&#39;: &#39;/wallet/getblockbynum&#39;, &#39;field&#39;: &#39;num&#39;},
        )

        result = self.tron.manager.request(method[&#39;url&#39;], {
            method[&#39;field&#39;]: block
        })

        if result:
            return result
        return ValueError(&#34;The call to {method[&#39;url&#39;]} did not return a value.&#34;)

    def get_transaction_count_by_blocknum(self, num: int):
        &#34;&#34;&#34;Query transaction&#39;s count on a specified block by height

        Args:
            num (int): block number
        &#34;&#34;&#34;
        if not is_integer(num) or num &lt; 0:
            raise ValueError(&#39;Invalid num provider&#39;)

        return self.tron.manager.request(&#39;/wallet/gettransactioncountbyblocknum&#39;, {
            &#39;num&#39;: num
        })

    def get_block_transaction_count(self, block: Any):
        &#34;&#34;&#34;Total number of transactions in a block

        Args:
            block (Any): Number or Hash Block

        &#34;&#34;&#34;
        transaction = self.get_block(block)
        if &#39;transactions&#39; not in transaction:
            raise TronError(&#39;Parameter &#34;transactions&#34; not found&#39;)

        return len(transaction)

    def get_transaction_from_block(self, block: Any, index: int = 0):
        &#34;&#34;&#34;Get transaction details from Block

        Args:
            block (Any): Number or Hash Block
            index (int) Position

        &#34;&#34;&#34;
        if not is_integer(index) or index &lt; 0:
            raise InvalidTronError(&#39;Invalid transaction index provided&#39;)

        transactions = self.get_block(block).get(&#39;transactions&#39;)
        if not transactions or len(transactions) &lt; index:
            raise TronError(&#39;Transaction not found in block&#39;)

        return transactions[index]

    def wait_for_transaction_id(self,
                                transaction_hash: str,
                                timeout=120,
                                poll_latency=0.2):
        &#34;&#34;&#34;
        Waits for the transaction specified by transaction_hash
        to be included in a block, then returns its transaction receipt.

        Optionally, specify a timeout in seconds.
        If timeout elapses before the transaction is added to a block,
        then wait_for_transaction_id() raises a Timeout exception.


        Args:
            transaction_hash (str): Transaction Hash
            timeout (int): TimeOut
            poll_latency (any):  between subsequent requests

        &#34;&#34;&#34;
        try:
            if poll_latency &gt; timeout:
                poll_latency = timeout

            return wait_for_transaction_id(self.tron, transaction_hash, timeout, poll_latency)
        except TimeoutError:
            raise TimeExhausted(
                &#34;Transaction {} is not in the chain, after {} seconds&#34;.format(
                    transaction_hash,
                    timeout,
                )
            )

    def get_transaction(self, transaction_id: str,
                        is_confirm: bool = False):
        &#34;&#34;&#34;Query transaction based on id

        Args:
            transaction_id (str): transaction id
            is_confirm (bool):
        &#34;&#34;&#34;

        method = &#39;walletsolidity&#39; if is_confirm else &#39;wallet&#39;
        response = self.tron.manager.request(&#39;/{}/gettransactionbyid&#39;.format(method), {
            &#39;value&#39;: transaction_id
        })

        if &#39;txID&#39; not in response:
            raise ValueError(&#39;Transaction not found&#39;)

        return response

    def get_account_by_id(self, account_id: str, options: object):
        return self.get_account_info_by_id(account_id, options)

    def get_account_info_by_id(self, account_id: str, options: object):

        if account_id.startswith(&#39;0x&#39;):
            account_id = id[2:]

        if &#39;confirmed&#39; in options:
            return self.tron.manager.request(&#39;/walletsolidity/getaccountbyid&#39;, {
                &#39;account_id&#39;: self.tron.toHex(text=account_id)
            })

        return self.tron.manager.request(&#39;/wallet/getaccountbyid&#39;, {
            &#39;account_id&#39;: self.tron.toHex(text=account_id)
        })

    def get_unconfirmed_account_by_id(self, account_id: str):

        return self.get_account_info_by_id(account_id, {
            &#39;confirmed&#39;: True
        })

    def get_account_resource(self, address=None):
        &#34;&#34;&#34;Query the resource information of the account

        Args:
            address (str): Address

        Results:
            Resource information of the account

        &#34;&#34;&#34;

        if address is None:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getaccountresource&#39;, {
            &#39;address&#39;: self.tron.address.to_hex(address)
        })

    def get_account(self, address=None):
        &#34;&#34;&#34;Query information about an account

        Args:
            address (str): Address

        &#34;&#34;&#34;

        if address is None:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        return self.tron.manager.request(&#39;/walletsolidity/getaccount&#39;, {
            &#39;address&#39;: self.tron.address.to_hex(address)
        })

    def get_balance(self, address=None, is_float=False):
        &#34;&#34;&#34;Getting a balance

        Args:
            address (str): Address
            is_float (bool): Convert to float format

        &#34;&#34;&#34;
        response = self.get_account(address)
        if &#39;balance&#39; not in response:
            return 0

        if is_float:
            return self.tron.fromSun(response[&#39;balance&#39;])

        return response[&#39;balance&#39;]

    def get_transactions_related(self, address, direction=&#39;all&#39;, limit=30, offset=0):
        &#34;&#34;&#34;Getting data in the &#34;from&#34;, &#34;to&#34; and &#34;all&#34; directions

        Args:
            address (str): Address
            direction (str): Type direction
            address (str): address
            limit (int): number of transactions expected to be returned
            offset (int): index of the starting transaction

        &#34;&#34;&#34;

        if direction not in [&#39;from&#39;, &#39;to&#39;, &#39;all&#39;]:
            raise InvalidTronError(&#39;Invalid direction provided: Expected &#34;to&#34;, &#34;from&#34; or &#34;all&#34;&#39;)

        if direction == &#39;all&#39;:
            _from = self.get_transactions_related(address, &#39;from&#39;, limit, offset)
            _to = self.get_transactions_related(address, &#39;to&#39;, limit, offset)

            filter_from = [{**i, &#39;direction&#39;: &#39;from&#39;} for i in _from]
            filter_to = [{**i, &#39;direction&#39;: &#39;to&#39;} for i in _to]

            callback = filter_from
            callback.extend(filter_to)
            return callback

        if address is None:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        if not isinstance(limit, int) or limit &lt; 0 or (offset and limit &lt; 1):
            raise InvalidTronError(&#39;Invalid limit provided&#39;)

        if not isinstance(offset, int) or offset &lt; 0:
            raise InvalidTronError(&#39;Invalid offset provided&#39;)

        path = &#39;/walletextension/gettransactions{0}this&#39;.format(direction)
        response = self.tron.manager.request(path, {
            &#39;account&#39;: {
                &#39;address&#39;: self.tron.address.to_hex(address)
            },
            &#39;limit&#39;: limit,
            &#39;offset&#39;: offset
        }, &#39;get&#39;)

        if &#39;transaction&#39; in response:
            return response[&#39;transaction&#39;]
        return response

    def get_transactions_to_address(self, address=None, limit=30, offset=0):
        &#34;&#34;&#34;Query the list of transactions received by an address

        Args:
            address (str): address
            limit (int): number of transactions expected to be returned
            offset (int): index of the starting transaction

        Returns:
            Transactions list

        &#34;&#34;&#34;
        return self.get_transactions_related(address, &#39;to&#39;, limit, offset)

    def get_transactions_from_address(self, address=None, limit=30, offset=0):
        &#34;&#34;&#34;Query the list of transactions sent by an address

        Args:
            address (str): address
            limit (int): number of transactions expected to be returned
            offset (int): index of the starting transaction

        Returns:
            Transactions list

        &#34;&#34;&#34;
        return self.get_transactions_related(address, &#39;from&#39;, limit, offset)

    def get_transaction_info(self, tx_id):
        &#34;&#34;&#34;Query transaction fee based on id

        Args:
            tx_id (str): Transaction Id

        Returns:
            Transaction fee，block height and block creation time

        &#34;&#34;&#34;
        response = self.tron.manager.request(&#39;/walletsolidity/gettransactioninfobyid&#39;, {
            &#39;value&#39;: tx_id
        })

        return response

    def get_band_width(self, address=None):
        &#34;&#34;&#34;Query bandwidth information.

        Args:
            address (str): address

        Returns:
            Bandwidth information for the account.
            If a field doesn&#39;t appear, then the corresponding value is 0.
            {
                &#34;freeNetUsed&#34;: 557,
                &#34;freeNetLimit&#34;: 5000,
                &#34;NetUsed&#34;: 353,
                &#34;NetLimit&#34;: 5239157853,
                &#34;TotalNetLimit&#34;: 43200000000,
                &#34;TotalNetWeight&#34;: 41228
            }

        &#34;&#34;&#34;

        if address is None:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/getaccountnet&#39;, {
            &#39;address&#39;: self.tron.address.to_hex(address)
        })

        free_net_limit = 0 if &#39;freeNetLimit&#39; not in response else response[&#39;freeNetLimit&#39;]
        free_net_used = 0 if &#39;freeNetUsed&#39; not in response else response[&#39;freeNetUsed&#39;]
        net_limit = 0 if &#39;NetLimit&#39; not in response else response[&#39;NetLimit&#39;]
        net_used = 0 if &#39;NetUsed&#39; not in response else response[&#39;NetUsed&#39;]

        return (free_net_limit - free_net_used) + (net_limit - net_used)

    def get_transaction_count(self):
        &#34;&#34;&#34;Count all transactions on the network
        Note: Possible delays

        Returns:
            Total number of transactions.

        &#34;&#34;&#34;
        response = self.tron.manager.request(&#39;/wallet/totaltransaction&#39;)
        return response.get(&#39;num&#39;)

    def send(self, to, amount, options=None):
        &#34;&#34;&#34;Send funds to the Tron account (option 2)&#34;&#34;&#34;
        return self.send_transaction(to, amount, options)

    def send_trx(self, to, amount, options=None):
        &#34;&#34;&#34;Send funds to the Tron account (option 3)&#34;&#34;&#34;
        return self.send_transaction(to, amount, options)

    def send_transaction(self, to, amount, options=None):
        &#34;&#34;&#34;Send an asset to another account.
        Will create and broadcast the transaction if a private key is provided.

        Args:
            to (str): Address to send TRX to.
            amount (float): Amount of TRX to send.
            options (Any, optional): Options

        &#34;&#34;&#34;

        if options is None:
            options = {}

        if &#39;from&#39; not in options:
            options = assoc(options, &#39;from&#39;, self.tron.default_address.hex)

        tx = self.tron.transaction_builder.send_transaction(
            to,
            amount,
            options[&#39;from&#39;]
        )
        # If a comment is attached to the transaction,
        # in this case adding to the object
        if &#39;message&#39; in options:
            tx[&#39;raw_data&#39;][&#39;data&#39;] = self.tron.toHex(text=str(options[&#39;message&#39;]))

        sign = self.sign(tx)
        result = self.broadcast(sign)

        return result

    def send_token(self, to, amount, token_id=None, account=None):
        &#34;&#34;&#34;Transfer Token

        Args:
            to (str): is the recipient address
            amount (float): is the amount of token to transfer
            token_id (str): Token Name(NOT SYMBOL)
            account: (str): is the address of the withdrawal account

        Returns:
            Token transfer Transaction raw data

        &#34;&#34;&#34;
        if account is None:
            account = self.tron.default_address.hex

        tx = self.tron.transaction_builder.send_token(
            to,
            amount,
            token_id,
            account
        )
        sign = self.sign(tx)
        result = self.broadcast(sign)

        return result

    def freeze_balance(self, amount=0, duration=3, resource=&#39;BANDWIDTH&#39;, account=None):
        &#34;&#34;&#34;
        Freezes an amount of TRX.
        Will give bandwidth OR Energy and TRON Power(voting rights)
        to the owner of the frozen tokens.

        Args:
            amount (int): number of frozen trx
            duration (int): duration in days to be frozen
            resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
            account (str): address that is freezing trx account

        &#34;&#34;&#34;

        if account is None:
            account = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.freeze_balance(
            amount,
            duration,
            resource,
            account
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def unfreeze_balance(self, resource=&#39;BANDWIDTH&#39;, account=None):
        &#34;&#34;&#34;
        Unfreeze TRX that has passed the minimum freeze duration.
        Unfreezing will remove bandwidth and TRON Power.

        Args:
            resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
            account (str): address that is freezing trx account

        &#34;&#34;&#34;

        if account is None:
            account = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.unfreeze_balance(
            resource,
            account
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def online_sign(self, transaction: dict):
        &#34;&#34;&#34;Online transaction signature
        Sign the transaction, the api has the risk of leaking the private key,
        please make sure to call the api in a secure environment

        Warnings:
            Do not use this in any web / user-facing applications.
            This will expose the private key.

        Args:
            transaction (dict): transaction details

        &#34;&#34;&#34;

        if &#39;signature&#39; in transaction:
            raise TronError(&#39;Transaction is already signed&#39;)

        address = self.tron.address.from_private_key(self.tron.private_key).hex.lower()
        owner_address = transaction[&#39;raw_data&#39;][&#39;contract&#39;][0][&#39;parameter&#39;][&#39;value&#39;][&#39;owner_address&#39;]

        if address != owner_address:
            raise ValueError(&#39;Private key does not match address in transaction&#39;)

        return self.tron.manager.request(&#39;/wallet/gettransactionsign&#39;, {
            &#39;transaction&#39;: transaction,
            &#39;privateKey&#39;: self.tron.private_key
        })

    def sign(self, transaction: Any, private_key=None, use_tron: bool = True, multisig: bool = False,
             is_message_hex=False):
        &#34;&#34;&#34;Safe method for signing your transaction

        Warnings:
            method: online_sign() - Use only in extreme cases.

        Args:
            transaction (Any): transaction details
            use_tron (bool): is Tron header
            multisig (bool): multi sign

        &#34;&#34;&#34;

        if is_string(transaction):
            if not is_hex(transaction):
                raise TronError(&#39;Expected hex message input&#39;)

            # Determine which header to attach to the message
            # before encrypting or decrypting
            header = TRX_MESSAGE_HEADER if use_tron else ETH_MESSAGE_HEADER
            header += str(len(transaction))

            if is_message_hex:
                from eth_hash.auto import keccak as keccak_256
                message_hash = keccak_256(header.encode(&#39;utf-8&#39;) + bytes.fromhex(transaction))
            else:
                message_hash = self.tron.keccak(text=header + transaction)

            signed_message = Account.sign_hash(self.tron.toHex(message_hash), private_key or self.tron.private_key)
            return signed_message

        if not multisig and &#39;signature&#39; in transaction:
            raise TronError(&#39;Transaction is already signed&#39;)

        try:
            if transaction.get(&#39;transaction&#39;, &#39;&#39;):
                transaction = transaction[&#39;transaction&#39;]

            if not multisig:
                address = self.tron.address.from_private_key(private_key or self.tron.private_key).hex.lower()
                owner_address = transaction[&#39;raw_data&#39;][&#39;contract&#39;][0][&#39;parameter&#39;][&#39;value&#39;][&#39;owner_address&#39;]

                if address != owner_address:
                    raise ValueError(&#39;Private key does not match address in transaction&#39;)

            # This option deals with signing of transactions, and writing to the array
            signed_tx = Account.sign_hash(
                transaction[&#39;txID&#39;], private_key or self.tron.private_key
            )
            signature = signed_tx[&#39;signature&#39;].hex()[2:]

            # support multi sign
            if &#39;signature&#39; in transaction and is_list(transaction[&#39;signature&#39;]):
                if not transaction[&#39;signature&#39;].index(signature):
                    transaction[&#39;signature&#39;].append(signature)
            else:
                transaction[&#39;signature&#39;] = [signature]

            return transaction
        except ValueError as err:
            raise InvalidTronError(err)

    def broadcast(self, signed_transaction):
        &#34;&#34;&#34;Broadcast the signed transaction

        Args:
            signed_transaction (object): signed transaction contract data

        &#34;&#34;&#34;
        if not is_object(signed_transaction):
            raise InvalidTronError(&#39;Invalid transaction provided&#39;)

        if &#39;signature&#39; not in signed_transaction:
            raise TronError(&#39;Transaction is not signed&#39;)

        response = self.tron.manager.request(&#39;/wallet/broadcasttransaction&#39;,
                                             signed_transaction)

        if &#39;result&#39; in response:
            response.update({
                &#39;transaction&#39;: signed_transaction
            })
        return response

    def sign_and_broadcast(self, transaction: Any):
        &#34;&#34;&#34;Sign and send to the network

        Args:
            transaction (Any): transaction details
        &#34;&#34;&#34;
        if not is_object(transaction):
            raise TronError(&#39;Invalid transaction provided&#39;)

        signed_tx = self.sign(transaction)
        return self.broadcast(signed_tx)

    def verify_message(self, message, signed_message=None, address=None, use_tron: bool = True, is_message_hex=False):
        &#34;&#34;&#34; Get the address of the account that signed the message with the given hash.
        You must specify exactly one of: vrs or signature

        Args:
            message (str): The message in the format &#34;hex&#34;
            signed_message (AttributeDict): Signature
            address (str): is Address
            use_tron (bool): is Tron header

        &#34;&#34;&#34;
        if address is None:
            address = self.tron.default_address.base58

        if not is_hex(message):
            raise TronError(&#39;Expected hex message input&#39;)

        # Determine which header to attach to the message
        # before encrypting or decrypting
        header = TRX_MESSAGE_HEADER if use_tron else ETH_MESSAGE_HEADER
        header += str(len(message))

        if is_message_hex:
            from eth_hash.auto import keccak as keccak_256
            message_hash = keccak_256(header.encode(&#39;utf-8&#39;) + bytes.fromhex(message))
        else:
            message_hash = self.tron.keccak(text=header + message)
        recovered = Account.recover_hash(self.tron.toHex(message_hash), signed_message.signature)

        tron_address = &#39;41&#39; + recovered[2:]
        base58address = self.tron.address.from_hex(tron_address).decode()

        if base58address == address:
            return True

        raise ValueError(&#39;Signature does not match&#39;)

    def update_account(self, account_name, address=None):
        &#34;&#34;&#34;Modify account name
        Note: Username is allowed to edit only once.

        Args:
            account_name (str): name of the account
            address (str): address

        &#34;&#34;&#34;
        if address is None:
            address = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.update_account(
            account_name,
            address
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def apply_for_sr(self, url, address):
        &#34;&#34;&#34;Apply to become a super representative
        Note: Applied to become a super representative. Cost 9999 TRX.

        Args:
            url (str): official website address
            address (str): address

        &#34;&#34;&#34;

        if address is None:
            address = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.apply_for_sr(
            url,
            address
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def list_nodes(self):
        &#34;&#34;&#34;List the nodes which the api fullnode is connecting on the network&#34;&#34;&#34;
        response = self.tron.manager.request(&#39;/wallet/listnodes&#39;)
        callback = map(lambda x: {
            &#39;address&#39;: &#39;{}:{}&#39;.format(self.tron.toText(x[&#39;address&#39;][&#39;host&#39;]),
                                      str(x[&#39;address&#39;][&#39;port&#39;]))
        }, response[&#39;nodes&#39;])

        return list(callback)

    def get_tokens_issued_by_address(self, address):
        &#34;&#34;&#34;List the tokens issued by an account.

        Args:
            address (str): address

        Returns:
            The token issued by the account.
            An account can issue only one token.

        &#34;&#34;&#34;

        if not self.tron.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        address = self.tron.address.to_hex(address)

        return self.tron.manager.request(&#39;/wallet/getassetissuebyaccount&#39;, {
            &#39;address&#39;: address
        })

    def get_token_from_id(self, token_id: str):
        &#34;&#34;&#34;Query token by name.

        Args:
            token_id (str): The name of the token

        &#34;&#34;&#34;
        if not isinstance(token_id, str) or not len(token_id):
            raise InvalidTronError(&#39;Invalid token ID provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getassetissuebyname&#39;, {
            &#39;value&#39;: self.tron.toHex(text=token_id)
        })

    def get_block_range(self, start, end):
        &#34;&#34;&#34;Query a range of blocks by block height

        Args:
            start (int): starting block height, including this block
            end (int): ending block height, excluding that block

        &#34;&#34;&#34;
        if not is_integer(start) or start &lt; 0:
            raise InvalidTronError(&#39;Invalid start of range provided&#39;)

        if not is_integer(end) or end &lt;= start:
            raise InvalidTronError(&#39;Invalid end of range provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/getblockbylimitnext&#39;, {
            &#39;startNum&#39;: int(start),
            &#39;endNum&#39;: int(end) + 1
        }, &#39;post&#39;)

        return response.get(&#39;block&#39;)

    def get_latest_blocks(self, num=1):
        &#34;&#34;&#34;Query the latest blocks

        Args:
            num (int): the number of blocks to query

        &#34;&#34;&#34;
        if not is_integer(num) or num &lt;= 0:
            raise InvalidTronError(&#39;Invalid limit provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/getblockbylatestnum&#39;, {
            &#39;num&#39;: num
        })

        return response.get(&#39;block&#39;)

    def list_super_representatives(self):
        &#34;&#34;&#34;Query the list of Super Representatives&#34;&#34;&#34;
        response = self.tron.manager.request(&#39;/wallet/listwitnesses&#39;)
        return response.get(&#39;witnesses&#39;)

    def list_tokens(self, limit=0, offset=0):
        &#34;&#34;&#34;Query the list of Tokens with pagination

        Args:
            limit (int): index of the starting Token
            offset (int): number of Tokens expected to be returned

        Returns:
            List of Tokens

        &#34;&#34;&#34;
        if not is_integer(limit) or (limit and offset &lt; 1):
            raise InvalidTronError(&#39;Invalid limit provided&#39;)

        if not is_integer(offset) or offset &lt; 0:
            raise InvalidTronError(&#39;Invalid offset provided&#39;)

        if not limit:
            return self.tron.manager.request(&#39;/wallet/getassetissuelist&#39;).get(&#39;assetIssue&#39;)

        return self.tron.manager.request(&#39;/wallet/getpaginatedassetissuelist&#39;, {
            &#39;limit&#39;: int(limit),
            &#39;offset&#39;: int(offset)
        })

    def get_asset_from_name(self, name: str) -&gt; dict:
        &#34;&#34;&#34;Get asset info from its abbr name, might fail if there&#39;re duplicates.&#34;&#34;&#34;
        assets = [asset for asset in self.list_assets(1000, 0) if asset[&#39;abbr&#39;] == name]
        if assets:
            if len(assets) == 1:
                return assets[0]
            raise ValueError(&#34;duplicated assets with the same name&#34;, [asset[&#39;id&#39;] for asset in assets])
        raise AssetNotFound

    def list_assets(self, limit=0, offset=0) -&gt; list:
        &#34;&#34;&#34;List all TRC10 tokens(assets).&#34;&#34;&#34;
        assets = self.list_tokens(limit, offset)
        for asset in assets:
            asset[&#34;id&#34;] = int(asset[&#34;id&#34;])
            asset[&#34;owner_address&#34;] = key.to_base58check_address(asset[&#34;owner_address&#34;])
            asset[&#34;name&#34;] = bytes.fromhex(asset[&#34;name&#34;]).decode()
            if &#34;abbr&#34; in asset:
                asset[&#34;abbr&#34;] = bytes.fromhex(asset[&#34;abbr&#34;]).decode()
            else:
                asset[&#34;abbr&#34;] = &#34;&#34;
            asset[&#34;description&#34;] = bytes.fromhex(asset[&#34;description&#34;]).decode(&#34;utf8&#34;, &#34;replace&#34;)
            asset[&#34;url&#34;] = bytes.fromhex(asset[&#34;url&#34;]).decode()
        return assets

    def time_until_next_vote_cycle(self):
        &#34;&#34;&#34;Get the time of the next Super Representative vote

        Returns:
            Number of milliseconds until the next voting time.

        &#34;&#34;&#34;
        num = self.tron.manager.request(&#39;/wallet/getnextmaintenancetime&#39;).get(&#39;num&#39;)

        if num == -1:
            raise Exception(&#39;Failed to get time until next vote cycle&#39;)

        return math.floor(num / 1000)

    def get_contract(self, contract_address):
        &#34;&#34;&#34;Queries a contract&#39;s information from the blockchain.

        Args:
            contract_address (str): contract address

        Returns:
            SmartContract object. JSON

        &#34;&#34;&#34;

        if not self.tron.isAddress(contract_address):
            raise InvalidTronError(&#39;Invalid contract address provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getcontract&#39;, {
            &#39;value&#39;: self.tron.address.to_hex(contract_address)
        })

    def contract(self, address=None, **kwargs):
        &#34;&#34;&#34;Work with a contract

        Args:
            address (str): TRON Address
            **kwargs (any): details (bytecode, abi)
        &#34;&#34;&#34;
        factory_class = kwargs.pop(&#39;contract_factory_class&#39;, self.default_contract_factory)

        contract_factory = factory_class.factory(self.tron, **kwargs)

        if address:
            return contract_factory(address)
        return contract_factory

    def validate_address(self, address, _is_hex=False):
        &#34;&#34;&#34;Validate address

        Args:
            address (str): The address, should be in base58checksum
            _is_hex (bool): hexString or base64 format

        &#34;&#34;&#34;
        if _is_hex:
            address = self.tron.address.to_hex(address)

        return self.tron.manager.request(&#39;/wallet/validateaddress&#39;, {
            &#39;address&#39;: address
        })

    def get_chain_parameters(self):
        &#34;&#34;&#34;Getting chain parameters&#34;&#34;&#34;
        return self.tron.manager.request(&#39;/wallet/getchainparameters&#39;)

    def get_exchange_by_id(self, exchange_id):
        &#34;&#34;&#34;Find exchange by id

        Args:
             exchange_id (str): ID Exchange

        &#34;&#34;&#34;

        if not isinstance(exchange_id, int) or exchange_id &lt; 0:
            raise InvalidTronError(&#39;Invalid exchangeID provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getexchangebyid&#39;, {
            &#39;id&#39;: exchange_id
        })

    def get_list_exchangers(self):
        &#34;&#34;&#34;Get list exchangers&#34;&#34;&#34;
        return self.tron.manager.request(&#39;/wallet/listexchanges&#39;)

    def get_proposal(self, proposal_id):
        &#34;&#34;&#34;Query proposal based on id

        Args:
            proposal_id (int): ID

        &#34;&#34;&#34;
        if not isinstance(proposal_id, int) or proposal_id &lt; 0:
            raise InvalidTronError(&#39;Invalid proposalID provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getproposalbyid&#39;, {
            &#39;id&#39;: int(proposal_id)
        })

    def list_proposals(self):
        &#34;&#34;&#34;Query all proposals

        Returns:
            Proposal list information

        &#34;&#34;&#34;
        return self.tron.manager.request(&#39;/wallet/listproposals&#39;)

    def vote_proposal(self, proposal_id, has_approval, voter_address):
        &#34;&#34;&#34;Proposal approval

        Args:
            proposal_id (int): proposal id
            has_approval (bool): Approved
            voter_address (str): Approve address

        Returns:
             Approval of the proposed transaction

        &#34;&#34;&#34;

        if voter_address is None:
            voter_address = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.vote_proposal(
            proposal_id,
            has_approval,
            voter_address
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def proposal_delete(self, proposal_id: int, issuer_address: str):
        &#34;&#34;&#34;Delete proposal

        Args:
            proposal_id (int): proposal id
            issuer_address (str): delete the person&#39;s address

        Results:
            Delete the proposal&#39;s transaction

        &#34;&#34;&#34;
        if issuer_address is None:
            issuer_address = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.delete_proposal(
            proposal_id,
            issuer_address
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def list_exchanges_paginated(self, limit=10, offset=0):
        &#34;&#34;&#34;Paged query transaction pair list

        Args:
            limit (int): number of trading pairs  expected to be returned.
            offset (int): index of the starting trading pair

        &#34;&#34;&#34;
        return self.tron.manager.request(&#39;/wallet/listexchangespaginated&#39;, {
            &#39;limit&#39;: limit,
            &#39;offset&#39;: offset
        })

    def get_node_info(self):
        &#34;&#34;&#34;Get info about thre node&#34;&#34;&#34;
        return self.tron.manager.request(&#39;/wallet/getnodeinfo&#39;)

    def get_token_list_name(self, token_id: str) -&gt; any:
        &#34;&#34;&#34;Query token list by name.

            Args:
                token_id (str): The name of the token
        &#34;&#34;&#34;
        if not is_string(token_id):
            raise ValueError(&#39;Invalid token ID provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getassetissuelistbyname&#39;, {
            &#39;value&#39;: self.tron.toHex(text=token_id)
        })

    def get_token_by_id(self, token_id: str) -&gt; any:
        &#34;&#34;&#34;Query token by id.

            Args:
                token_id (str): The id of the token, it&#39;s a string
        &#34;&#34;&#34;
        if not is_string(token_id):
            raise ValueError(&#39;Invalid token ID provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getassetissuebyid&#39;, {
            &#39;value&#39;: token_id
        })</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tronpytool.trx.Trx"><code class="flex name class">
<span>class <span class="ident">Trx</span></span>
<span>(</span><span>tron)</span>
</code></dt>
<dd>
<div class="desc"><p>Module Class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Trx(Module):
    default_contract_factory = Contract

    def get_current_block(self):
        &#34;&#34;&#34;Query the latest block&#34;&#34;&#34;
        return self.tron.manager.request(url=&#39;/wallet/getnowblock&#39;)

    def get_confirmed_current_block(self):
        &#34;&#34;&#34;Query the confirmed latest block&#34;&#34;&#34;
        return self.tron.manager.request(&#39;/walletsolidity/getnowblock&#39;)

    def get_block(self, block: Any = None):
        &#34;&#34;&#34;Get block details using HashString or blockNumber

        Args:
            block (Any): ID or height for the block

        &#34;&#34;&#34;

        # If the block identifier is not specified,
        # we take the default
        if block is None:
            block = self.tron.default_block

        if block == &#39;latest&#39;:
            return self.get_current_block()
        elif block == &#39;earliest&#39;:
            return self.get_block(0)

        method = select_method_for_block(
            block,
            if_hash={&#39;url&#39;: &#39;/wallet/getblockbyid&#39;, &#39;field&#39;: &#39;value&#39;},
            if_number={&#39;url&#39;: &#39;/wallet/getblockbynum&#39;, &#39;field&#39;: &#39;num&#39;},
        )

        result = self.tron.manager.request(method[&#39;url&#39;], {
            method[&#39;field&#39;]: block
        })

        if result:
            return result
        return ValueError(&#34;The call to {method[&#39;url&#39;]} did not return a value.&#34;)

    def get_transaction_count_by_blocknum(self, num: int):
        &#34;&#34;&#34;Query transaction&#39;s count on a specified block by height

        Args:
            num (int): block number
        &#34;&#34;&#34;
        if not is_integer(num) or num &lt; 0:
            raise ValueError(&#39;Invalid num provider&#39;)

        return self.tron.manager.request(&#39;/wallet/gettransactioncountbyblocknum&#39;, {
            &#39;num&#39;: num
        })

    def get_block_transaction_count(self, block: Any):
        &#34;&#34;&#34;Total number of transactions in a block

        Args:
            block (Any): Number or Hash Block

        &#34;&#34;&#34;
        transaction = self.get_block(block)
        if &#39;transactions&#39; not in transaction:
            raise TronError(&#39;Parameter &#34;transactions&#34; not found&#39;)

        return len(transaction)

    def get_transaction_from_block(self, block: Any, index: int = 0):
        &#34;&#34;&#34;Get transaction details from Block

        Args:
            block (Any): Number or Hash Block
            index (int) Position

        &#34;&#34;&#34;
        if not is_integer(index) or index &lt; 0:
            raise InvalidTronError(&#39;Invalid transaction index provided&#39;)

        transactions = self.get_block(block).get(&#39;transactions&#39;)
        if not transactions or len(transactions) &lt; index:
            raise TronError(&#39;Transaction not found in block&#39;)

        return transactions[index]

    def wait_for_transaction_id(self,
                                transaction_hash: str,
                                timeout=120,
                                poll_latency=0.2):
        &#34;&#34;&#34;
        Waits for the transaction specified by transaction_hash
        to be included in a block, then returns its transaction receipt.

        Optionally, specify a timeout in seconds.
        If timeout elapses before the transaction is added to a block,
        then wait_for_transaction_id() raises a Timeout exception.


        Args:
            transaction_hash (str): Transaction Hash
            timeout (int): TimeOut
            poll_latency (any):  between subsequent requests

        &#34;&#34;&#34;
        try:
            if poll_latency &gt; timeout:
                poll_latency = timeout

            return wait_for_transaction_id(self.tron, transaction_hash, timeout, poll_latency)
        except TimeoutError:
            raise TimeExhausted(
                &#34;Transaction {} is not in the chain, after {} seconds&#34;.format(
                    transaction_hash,
                    timeout,
                )
            )

    def get_transaction(self, transaction_id: str,
                        is_confirm: bool = False):
        &#34;&#34;&#34;Query transaction based on id

        Args:
            transaction_id (str): transaction id
            is_confirm (bool):
        &#34;&#34;&#34;

        method = &#39;walletsolidity&#39; if is_confirm else &#39;wallet&#39;
        response = self.tron.manager.request(&#39;/{}/gettransactionbyid&#39;.format(method), {
            &#39;value&#39;: transaction_id
        })

        if &#39;txID&#39; not in response:
            raise ValueError(&#39;Transaction not found&#39;)

        return response

    def get_account_by_id(self, account_id: str, options: object):
        return self.get_account_info_by_id(account_id, options)

    def get_account_info_by_id(self, account_id: str, options: object):

        if account_id.startswith(&#39;0x&#39;):
            account_id = id[2:]

        if &#39;confirmed&#39; in options:
            return self.tron.manager.request(&#39;/walletsolidity/getaccountbyid&#39;, {
                &#39;account_id&#39;: self.tron.toHex(text=account_id)
            })

        return self.tron.manager.request(&#39;/wallet/getaccountbyid&#39;, {
            &#39;account_id&#39;: self.tron.toHex(text=account_id)
        })

    def get_unconfirmed_account_by_id(self, account_id: str):

        return self.get_account_info_by_id(account_id, {
            &#39;confirmed&#39;: True
        })

    def get_account_resource(self, address=None):
        &#34;&#34;&#34;Query the resource information of the account

        Args:
            address (str): Address

        Results:
            Resource information of the account

        &#34;&#34;&#34;

        if address is None:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getaccountresource&#39;, {
            &#39;address&#39;: self.tron.address.to_hex(address)
        })

    def get_account(self, address=None):
        &#34;&#34;&#34;Query information about an account

        Args:
            address (str): Address

        &#34;&#34;&#34;

        if address is None:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        return self.tron.manager.request(&#39;/walletsolidity/getaccount&#39;, {
            &#39;address&#39;: self.tron.address.to_hex(address)
        })

    def get_balance(self, address=None, is_float=False):
        &#34;&#34;&#34;Getting a balance

        Args:
            address (str): Address
            is_float (bool): Convert to float format

        &#34;&#34;&#34;
        response = self.get_account(address)
        if &#39;balance&#39; not in response:
            return 0

        if is_float:
            return self.tron.fromSun(response[&#39;balance&#39;])

        return response[&#39;balance&#39;]

    def get_transactions_related(self, address, direction=&#39;all&#39;, limit=30, offset=0):
        &#34;&#34;&#34;Getting data in the &#34;from&#34;, &#34;to&#34; and &#34;all&#34; directions

        Args:
            address (str): Address
            direction (str): Type direction
            address (str): address
            limit (int): number of transactions expected to be returned
            offset (int): index of the starting transaction

        &#34;&#34;&#34;

        if direction not in [&#39;from&#39;, &#39;to&#39;, &#39;all&#39;]:
            raise InvalidTronError(&#39;Invalid direction provided: Expected &#34;to&#34;, &#34;from&#34; or &#34;all&#34;&#39;)

        if direction == &#39;all&#39;:
            _from = self.get_transactions_related(address, &#39;from&#39;, limit, offset)
            _to = self.get_transactions_related(address, &#39;to&#39;, limit, offset)

            filter_from = [{**i, &#39;direction&#39;: &#39;from&#39;} for i in _from]
            filter_to = [{**i, &#39;direction&#39;: &#39;to&#39;} for i in _to]

            callback = filter_from
            callback.extend(filter_to)
            return callback

        if address is None:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        if not isinstance(limit, int) or limit &lt; 0 or (offset and limit &lt; 1):
            raise InvalidTronError(&#39;Invalid limit provided&#39;)

        if not isinstance(offset, int) or offset &lt; 0:
            raise InvalidTronError(&#39;Invalid offset provided&#39;)

        path = &#39;/walletextension/gettransactions{0}this&#39;.format(direction)
        response = self.tron.manager.request(path, {
            &#39;account&#39;: {
                &#39;address&#39;: self.tron.address.to_hex(address)
            },
            &#39;limit&#39;: limit,
            &#39;offset&#39;: offset
        }, &#39;get&#39;)

        if &#39;transaction&#39; in response:
            return response[&#39;transaction&#39;]
        return response

    def get_transactions_to_address(self, address=None, limit=30, offset=0):
        &#34;&#34;&#34;Query the list of transactions received by an address

        Args:
            address (str): address
            limit (int): number of transactions expected to be returned
            offset (int): index of the starting transaction

        Returns:
            Transactions list

        &#34;&#34;&#34;
        return self.get_transactions_related(address, &#39;to&#39;, limit, offset)

    def get_transactions_from_address(self, address=None, limit=30, offset=0):
        &#34;&#34;&#34;Query the list of transactions sent by an address

        Args:
            address (str): address
            limit (int): number of transactions expected to be returned
            offset (int): index of the starting transaction

        Returns:
            Transactions list

        &#34;&#34;&#34;
        return self.get_transactions_related(address, &#39;from&#39;, limit, offset)

    def get_transaction_info(self, tx_id):
        &#34;&#34;&#34;Query transaction fee based on id

        Args:
            tx_id (str): Transaction Id

        Returns:
            Transaction fee，block height and block creation time

        &#34;&#34;&#34;
        response = self.tron.manager.request(&#39;/walletsolidity/gettransactioninfobyid&#39;, {
            &#39;value&#39;: tx_id
        })

        return response

    def get_band_width(self, address=None):
        &#34;&#34;&#34;Query bandwidth information.

        Args:
            address (str): address

        Returns:
            Bandwidth information for the account.
            If a field doesn&#39;t appear, then the corresponding value is 0.
            {
                &#34;freeNetUsed&#34;: 557,
                &#34;freeNetLimit&#34;: 5000,
                &#34;NetUsed&#34;: 353,
                &#34;NetLimit&#34;: 5239157853,
                &#34;TotalNetLimit&#34;: 43200000000,
                &#34;TotalNetWeight&#34;: 41228
            }

        &#34;&#34;&#34;

        if address is None:
            address = self.tron.default_address.hex

        if not self.tron.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/getaccountnet&#39;, {
            &#39;address&#39;: self.tron.address.to_hex(address)
        })

        free_net_limit = 0 if &#39;freeNetLimit&#39; not in response else response[&#39;freeNetLimit&#39;]
        free_net_used = 0 if &#39;freeNetUsed&#39; not in response else response[&#39;freeNetUsed&#39;]
        net_limit = 0 if &#39;NetLimit&#39; not in response else response[&#39;NetLimit&#39;]
        net_used = 0 if &#39;NetUsed&#39; not in response else response[&#39;NetUsed&#39;]

        return (free_net_limit - free_net_used) + (net_limit - net_used)

    def get_transaction_count(self):
        &#34;&#34;&#34;Count all transactions on the network
        Note: Possible delays

        Returns:
            Total number of transactions.

        &#34;&#34;&#34;
        response = self.tron.manager.request(&#39;/wallet/totaltransaction&#39;)
        return response.get(&#39;num&#39;)

    def send(self, to, amount, options=None):
        &#34;&#34;&#34;Send funds to the Tron account (option 2)&#34;&#34;&#34;
        return self.send_transaction(to, amount, options)

    def send_trx(self, to, amount, options=None):
        &#34;&#34;&#34;Send funds to the Tron account (option 3)&#34;&#34;&#34;
        return self.send_transaction(to, amount, options)

    def send_transaction(self, to, amount, options=None):
        &#34;&#34;&#34;Send an asset to another account.
        Will create and broadcast the transaction if a private key is provided.

        Args:
            to (str): Address to send TRX to.
            amount (float): Amount of TRX to send.
            options (Any, optional): Options

        &#34;&#34;&#34;

        if options is None:
            options = {}

        if &#39;from&#39; not in options:
            options = assoc(options, &#39;from&#39;, self.tron.default_address.hex)

        tx = self.tron.transaction_builder.send_transaction(
            to,
            amount,
            options[&#39;from&#39;]
        )
        # If a comment is attached to the transaction,
        # in this case adding to the object
        if &#39;message&#39; in options:
            tx[&#39;raw_data&#39;][&#39;data&#39;] = self.tron.toHex(text=str(options[&#39;message&#39;]))

        sign = self.sign(tx)
        result = self.broadcast(sign)

        return result

    def send_token(self, to, amount, token_id=None, account=None):
        &#34;&#34;&#34;Transfer Token

        Args:
            to (str): is the recipient address
            amount (float): is the amount of token to transfer
            token_id (str): Token Name(NOT SYMBOL)
            account: (str): is the address of the withdrawal account

        Returns:
            Token transfer Transaction raw data

        &#34;&#34;&#34;
        if account is None:
            account = self.tron.default_address.hex

        tx = self.tron.transaction_builder.send_token(
            to,
            amount,
            token_id,
            account
        )
        sign = self.sign(tx)
        result = self.broadcast(sign)

        return result

    def freeze_balance(self, amount=0, duration=3, resource=&#39;BANDWIDTH&#39;, account=None):
        &#34;&#34;&#34;
        Freezes an amount of TRX.
        Will give bandwidth OR Energy and TRON Power(voting rights)
        to the owner of the frozen tokens.

        Args:
            amount (int): number of frozen trx
            duration (int): duration in days to be frozen
            resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
            account (str): address that is freezing trx account

        &#34;&#34;&#34;

        if account is None:
            account = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.freeze_balance(
            amount,
            duration,
            resource,
            account
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def unfreeze_balance(self, resource=&#39;BANDWIDTH&#39;, account=None):
        &#34;&#34;&#34;
        Unfreeze TRX that has passed the minimum freeze duration.
        Unfreezing will remove bandwidth and TRON Power.

        Args:
            resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
            account (str): address that is freezing trx account

        &#34;&#34;&#34;

        if account is None:
            account = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.unfreeze_balance(
            resource,
            account
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def online_sign(self, transaction: dict):
        &#34;&#34;&#34;Online transaction signature
        Sign the transaction, the api has the risk of leaking the private key,
        please make sure to call the api in a secure environment

        Warnings:
            Do not use this in any web / user-facing applications.
            This will expose the private key.

        Args:
            transaction (dict): transaction details

        &#34;&#34;&#34;

        if &#39;signature&#39; in transaction:
            raise TronError(&#39;Transaction is already signed&#39;)

        address = self.tron.address.from_private_key(self.tron.private_key).hex.lower()
        owner_address = transaction[&#39;raw_data&#39;][&#39;contract&#39;][0][&#39;parameter&#39;][&#39;value&#39;][&#39;owner_address&#39;]

        if address != owner_address:
            raise ValueError(&#39;Private key does not match address in transaction&#39;)

        return self.tron.manager.request(&#39;/wallet/gettransactionsign&#39;, {
            &#39;transaction&#39;: transaction,
            &#39;privateKey&#39;: self.tron.private_key
        })

    def sign(self, transaction: Any, private_key=None, use_tron: bool = True, multisig: bool = False,
             is_message_hex=False):
        &#34;&#34;&#34;Safe method for signing your transaction

        Warnings:
            method: online_sign() - Use only in extreme cases.

        Args:
            transaction (Any): transaction details
            use_tron (bool): is Tron header
            multisig (bool): multi sign

        &#34;&#34;&#34;

        if is_string(transaction):
            if not is_hex(transaction):
                raise TronError(&#39;Expected hex message input&#39;)

            # Determine which header to attach to the message
            # before encrypting or decrypting
            header = TRX_MESSAGE_HEADER if use_tron else ETH_MESSAGE_HEADER
            header += str(len(transaction))

            if is_message_hex:
                from eth_hash.auto import keccak as keccak_256
                message_hash = keccak_256(header.encode(&#39;utf-8&#39;) + bytes.fromhex(transaction))
            else:
                message_hash = self.tron.keccak(text=header + transaction)

            signed_message = Account.sign_hash(self.tron.toHex(message_hash), private_key or self.tron.private_key)
            return signed_message

        if not multisig and &#39;signature&#39; in transaction:
            raise TronError(&#39;Transaction is already signed&#39;)

        try:
            if transaction.get(&#39;transaction&#39;, &#39;&#39;):
                transaction = transaction[&#39;transaction&#39;]

            if not multisig:
                address = self.tron.address.from_private_key(private_key or self.tron.private_key).hex.lower()
                owner_address = transaction[&#39;raw_data&#39;][&#39;contract&#39;][0][&#39;parameter&#39;][&#39;value&#39;][&#39;owner_address&#39;]

                if address != owner_address:
                    raise ValueError(&#39;Private key does not match address in transaction&#39;)

            # This option deals with signing of transactions, and writing to the array
            signed_tx = Account.sign_hash(
                transaction[&#39;txID&#39;], private_key or self.tron.private_key
            )
            signature = signed_tx[&#39;signature&#39;].hex()[2:]

            # support multi sign
            if &#39;signature&#39; in transaction and is_list(transaction[&#39;signature&#39;]):
                if not transaction[&#39;signature&#39;].index(signature):
                    transaction[&#39;signature&#39;].append(signature)
            else:
                transaction[&#39;signature&#39;] = [signature]

            return transaction
        except ValueError as err:
            raise InvalidTronError(err)

    def broadcast(self, signed_transaction):
        &#34;&#34;&#34;Broadcast the signed transaction

        Args:
            signed_transaction (object): signed transaction contract data

        &#34;&#34;&#34;
        if not is_object(signed_transaction):
            raise InvalidTronError(&#39;Invalid transaction provided&#39;)

        if &#39;signature&#39; not in signed_transaction:
            raise TronError(&#39;Transaction is not signed&#39;)

        response = self.tron.manager.request(&#39;/wallet/broadcasttransaction&#39;,
                                             signed_transaction)

        if &#39;result&#39; in response:
            response.update({
                &#39;transaction&#39;: signed_transaction
            })
        return response

    def sign_and_broadcast(self, transaction: Any):
        &#34;&#34;&#34;Sign and send to the network

        Args:
            transaction (Any): transaction details
        &#34;&#34;&#34;
        if not is_object(transaction):
            raise TronError(&#39;Invalid transaction provided&#39;)

        signed_tx = self.sign(transaction)
        return self.broadcast(signed_tx)

    def verify_message(self, message, signed_message=None, address=None, use_tron: bool = True, is_message_hex=False):
        &#34;&#34;&#34; Get the address of the account that signed the message with the given hash.
        You must specify exactly one of: vrs or signature

        Args:
            message (str): The message in the format &#34;hex&#34;
            signed_message (AttributeDict): Signature
            address (str): is Address
            use_tron (bool): is Tron header

        &#34;&#34;&#34;
        if address is None:
            address = self.tron.default_address.base58

        if not is_hex(message):
            raise TronError(&#39;Expected hex message input&#39;)

        # Determine which header to attach to the message
        # before encrypting or decrypting
        header = TRX_MESSAGE_HEADER if use_tron else ETH_MESSAGE_HEADER
        header += str(len(message))

        if is_message_hex:
            from eth_hash.auto import keccak as keccak_256
            message_hash = keccak_256(header.encode(&#39;utf-8&#39;) + bytes.fromhex(message))
        else:
            message_hash = self.tron.keccak(text=header + message)
        recovered = Account.recover_hash(self.tron.toHex(message_hash), signed_message.signature)

        tron_address = &#39;41&#39; + recovered[2:]
        base58address = self.tron.address.from_hex(tron_address).decode()

        if base58address == address:
            return True

        raise ValueError(&#39;Signature does not match&#39;)

    def update_account(self, account_name, address=None):
        &#34;&#34;&#34;Modify account name
        Note: Username is allowed to edit only once.

        Args:
            account_name (str): name of the account
            address (str): address

        &#34;&#34;&#34;
        if address is None:
            address = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.update_account(
            account_name,
            address
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def apply_for_sr(self, url, address):
        &#34;&#34;&#34;Apply to become a super representative
        Note: Applied to become a super representative. Cost 9999 TRX.

        Args:
            url (str): official website address
            address (str): address

        &#34;&#34;&#34;

        if address is None:
            address = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.apply_for_sr(
            url,
            address
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def list_nodes(self):
        &#34;&#34;&#34;List the nodes which the api fullnode is connecting on the network&#34;&#34;&#34;
        response = self.tron.manager.request(&#39;/wallet/listnodes&#39;)
        callback = map(lambda x: {
            &#39;address&#39;: &#39;{}:{}&#39;.format(self.tron.toText(x[&#39;address&#39;][&#39;host&#39;]),
                                      str(x[&#39;address&#39;][&#39;port&#39;]))
        }, response[&#39;nodes&#39;])

        return list(callback)

    def get_tokens_issued_by_address(self, address):
        &#34;&#34;&#34;List the tokens issued by an account.

        Args:
            address (str): address

        Returns:
            The token issued by the account.
            An account can issue only one token.

        &#34;&#34;&#34;

        if not self.tron.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        address = self.tron.address.to_hex(address)

        return self.tron.manager.request(&#39;/wallet/getassetissuebyaccount&#39;, {
            &#39;address&#39;: address
        })

    def get_token_from_id(self, token_id: str):
        &#34;&#34;&#34;Query token by name.

        Args:
            token_id (str): The name of the token

        &#34;&#34;&#34;
        if not isinstance(token_id, str) or not len(token_id):
            raise InvalidTronError(&#39;Invalid token ID provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getassetissuebyname&#39;, {
            &#39;value&#39;: self.tron.toHex(text=token_id)
        })

    def get_block_range(self, start, end):
        &#34;&#34;&#34;Query a range of blocks by block height

        Args:
            start (int): starting block height, including this block
            end (int): ending block height, excluding that block

        &#34;&#34;&#34;
        if not is_integer(start) or start &lt; 0:
            raise InvalidTronError(&#39;Invalid start of range provided&#39;)

        if not is_integer(end) or end &lt;= start:
            raise InvalidTronError(&#39;Invalid end of range provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/getblockbylimitnext&#39;, {
            &#39;startNum&#39;: int(start),
            &#39;endNum&#39;: int(end) + 1
        }, &#39;post&#39;)

        return response.get(&#39;block&#39;)

    def get_latest_blocks(self, num=1):
        &#34;&#34;&#34;Query the latest blocks

        Args:
            num (int): the number of blocks to query

        &#34;&#34;&#34;
        if not is_integer(num) or num &lt;= 0:
            raise InvalidTronError(&#39;Invalid limit provided&#39;)

        response = self.tron.manager.request(&#39;/wallet/getblockbylatestnum&#39;, {
            &#39;num&#39;: num
        })

        return response.get(&#39;block&#39;)

    def list_super_representatives(self):
        &#34;&#34;&#34;Query the list of Super Representatives&#34;&#34;&#34;
        response = self.tron.manager.request(&#39;/wallet/listwitnesses&#39;)
        return response.get(&#39;witnesses&#39;)

    def list_tokens(self, limit=0, offset=0):
        &#34;&#34;&#34;Query the list of Tokens with pagination

        Args:
            limit (int): index of the starting Token
            offset (int): number of Tokens expected to be returned

        Returns:
            List of Tokens

        &#34;&#34;&#34;
        if not is_integer(limit) or (limit and offset &lt; 1):
            raise InvalidTronError(&#39;Invalid limit provided&#39;)

        if not is_integer(offset) or offset &lt; 0:
            raise InvalidTronError(&#39;Invalid offset provided&#39;)

        if not limit:
            return self.tron.manager.request(&#39;/wallet/getassetissuelist&#39;).get(&#39;assetIssue&#39;)

        return self.tron.manager.request(&#39;/wallet/getpaginatedassetissuelist&#39;, {
            &#39;limit&#39;: int(limit),
            &#39;offset&#39;: int(offset)
        })

    def get_asset_from_name(self, name: str) -&gt; dict:
        &#34;&#34;&#34;Get asset info from its abbr name, might fail if there&#39;re duplicates.&#34;&#34;&#34;
        assets = [asset for asset in self.list_assets(1000, 0) if asset[&#39;abbr&#39;] == name]
        if assets:
            if len(assets) == 1:
                return assets[0]
            raise ValueError(&#34;duplicated assets with the same name&#34;, [asset[&#39;id&#39;] for asset in assets])
        raise AssetNotFound

    def list_assets(self, limit=0, offset=0) -&gt; list:
        &#34;&#34;&#34;List all TRC10 tokens(assets).&#34;&#34;&#34;
        assets = self.list_tokens(limit, offset)
        for asset in assets:
            asset[&#34;id&#34;] = int(asset[&#34;id&#34;])
            asset[&#34;owner_address&#34;] = key.to_base58check_address(asset[&#34;owner_address&#34;])
            asset[&#34;name&#34;] = bytes.fromhex(asset[&#34;name&#34;]).decode()
            if &#34;abbr&#34; in asset:
                asset[&#34;abbr&#34;] = bytes.fromhex(asset[&#34;abbr&#34;]).decode()
            else:
                asset[&#34;abbr&#34;] = &#34;&#34;
            asset[&#34;description&#34;] = bytes.fromhex(asset[&#34;description&#34;]).decode(&#34;utf8&#34;, &#34;replace&#34;)
            asset[&#34;url&#34;] = bytes.fromhex(asset[&#34;url&#34;]).decode()
        return assets

    def time_until_next_vote_cycle(self):
        &#34;&#34;&#34;Get the time of the next Super Representative vote

        Returns:
            Number of milliseconds until the next voting time.

        &#34;&#34;&#34;
        num = self.tron.manager.request(&#39;/wallet/getnextmaintenancetime&#39;).get(&#39;num&#39;)

        if num == -1:
            raise Exception(&#39;Failed to get time until next vote cycle&#39;)

        return math.floor(num / 1000)

    def get_contract(self, contract_address):
        &#34;&#34;&#34;Queries a contract&#39;s information from the blockchain.

        Args:
            contract_address (str): contract address

        Returns:
            SmartContract object. JSON

        &#34;&#34;&#34;

        if not self.tron.isAddress(contract_address):
            raise InvalidTronError(&#39;Invalid contract address provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getcontract&#39;, {
            &#39;value&#39;: self.tron.address.to_hex(contract_address)
        })

    def contract(self, address=None, **kwargs):
        &#34;&#34;&#34;Work with a contract

        Args:
            address (str): TRON Address
            **kwargs (any): details (bytecode, abi)
        &#34;&#34;&#34;
        factory_class = kwargs.pop(&#39;contract_factory_class&#39;, self.default_contract_factory)

        contract_factory = factory_class.factory(self.tron, **kwargs)

        if address:
            return contract_factory(address)
        return contract_factory

    def validate_address(self, address, _is_hex=False):
        &#34;&#34;&#34;Validate address

        Args:
            address (str): The address, should be in base58checksum
            _is_hex (bool): hexString or base64 format

        &#34;&#34;&#34;
        if _is_hex:
            address = self.tron.address.to_hex(address)

        return self.tron.manager.request(&#39;/wallet/validateaddress&#39;, {
            &#39;address&#39;: address
        })

    def get_chain_parameters(self):
        &#34;&#34;&#34;Getting chain parameters&#34;&#34;&#34;
        return self.tron.manager.request(&#39;/wallet/getchainparameters&#39;)

    def get_exchange_by_id(self, exchange_id):
        &#34;&#34;&#34;Find exchange by id

        Args:
             exchange_id (str): ID Exchange

        &#34;&#34;&#34;

        if not isinstance(exchange_id, int) or exchange_id &lt; 0:
            raise InvalidTronError(&#39;Invalid exchangeID provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getexchangebyid&#39;, {
            &#39;id&#39;: exchange_id
        })

    def get_list_exchangers(self):
        &#34;&#34;&#34;Get list exchangers&#34;&#34;&#34;
        return self.tron.manager.request(&#39;/wallet/listexchanges&#39;)

    def get_proposal(self, proposal_id):
        &#34;&#34;&#34;Query proposal based on id

        Args:
            proposal_id (int): ID

        &#34;&#34;&#34;
        if not isinstance(proposal_id, int) or proposal_id &lt; 0:
            raise InvalidTronError(&#39;Invalid proposalID provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getproposalbyid&#39;, {
            &#39;id&#39;: int(proposal_id)
        })

    def list_proposals(self):
        &#34;&#34;&#34;Query all proposals

        Returns:
            Proposal list information

        &#34;&#34;&#34;
        return self.tron.manager.request(&#39;/wallet/listproposals&#39;)

    def vote_proposal(self, proposal_id, has_approval, voter_address):
        &#34;&#34;&#34;Proposal approval

        Args:
            proposal_id (int): proposal id
            has_approval (bool): Approved
            voter_address (str): Approve address

        Returns:
             Approval of the proposed transaction

        &#34;&#34;&#34;

        if voter_address is None:
            voter_address = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.vote_proposal(
            proposal_id,
            has_approval,
            voter_address
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def proposal_delete(self, proposal_id: int, issuer_address: str):
        &#34;&#34;&#34;Delete proposal

        Args:
            proposal_id (int): proposal id
            issuer_address (str): delete the person&#39;s address

        Results:
            Delete the proposal&#39;s transaction

        &#34;&#34;&#34;
        if issuer_address is None:
            issuer_address = self.tron.default_address.hex

        transaction = self.tron.transaction_builder.delete_proposal(
            proposal_id,
            issuer_address
        )
        sign = self.sign(transaction)
        response = self.broadcast(sign)

        return response

    def list_exchanges_paginated(self, limit=10, offset=0):
        &#34;&#34;&#34;Paged query transaction pair list

        Args:
            limit (int): number of trading pairs  expected to be returned.
            offset (int): index of the starting trading pair

        &#34;&#34;&#34;
        return self.tron.manager.request(&#39;/wallet/listexchangespaginated&#39;, {
            &#39;limit&#39;: limit,
            &#39;offset&#39;: offset
        })

    def get_node_info(self):
        &#34;&#34;&#34;Get info about thre node&#34;&#34;&#34;
        return self.tron.manager.request(&#39;/wallet/getnodeinfo&#39;)

    def get_token_list_name(self, token_id: str) -&gt; any:
        &#34;&#34;&#34;Query token list by name.

            Args:
                token_id (str): The name of the token
        &#34;&#34;&#34;
        if not is_string(token_id):
            raise ValueError(&#39;Invalid token ID provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getassetissuelistbyname&#39;, {
            &#39;value&#39;: self.tron.toHex(text=token_id)
        })

    def get_token_by_id(self, token_id: str) -&gt; any:
        &#34;&#34;&#34;Query token by id.

            Args:
                token_id (str): The id of the token, it&#39;s a string
        &#34;&#34;&#34;
        if not is_string(token_id):
            raise ValueError(&#39;Invalid token ID provided&#39;)

        return self.tron.manager.request(&#39;/wallet/getassetissuebyid&#39;, {
            &#39;value&#39;: token_id
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tronpytool.module.Module" href="module.html#tronpytool.module.Module">Module</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="tronpytool.trx.Trx.default_contract_factory"><code class="name">var <span class="ident">default_contract_factory</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tronpytool.trx.Trx.apply_for_sr"><code class="name flex">
<span>def <span class="ident">apply_for_sr</span></span>(<span>self, url, address)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply to become a super representative
Note: Applied to become a super representative. Cost 9999 TRX.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>url</code></strong> :&ensp;<code>str</code></dt>
<dd>official website address</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>address</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_for_sr(self, url, address):
    &#34;&#34;&#34;Apply to become a super representative
    Note: Applied to become a super representative. Cost 9999 TRX.

    Args:
        url (str): official website address
        address (str): address

    &#34;&#34;&#34;

    if address is None:
        address = self.tron.default_address.hex

    transaction = self.tron.transaction_builder.apply_for_sr(
        url,
        address
    )
    sign = self.sign(transaction)
    response = self.broadcast(sign)

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.broadcast"><code class="name flex">
<span>def <span class="ident">broadcast</span></span>(<span>self, signed_transaction)</span>
</code></dt>
<dd>
<div class="desc"><p>Broadcast the signed transaction</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signed_transaction</code></strong> :&ensp;<code>object</code></dt>
<dd>signed transaction contract data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def broadcast(self, signed_transaction):
    &#34;&#34;&#34;Broadcast the signed transaction

    Args:
        signed_transaction (object): signed transaction contract data

    &#34;&#34;&#34;
    if not is_object(signed_transaction):
        raise InvalidTronError(&#39;Invalid transaction provided&#39;)

    if &#39;signature&#39; not in signed_transaction:
        raise TronError(&#39;Transaction is not signed&#39;)

    response = self.tron.manager.request(&#39;/wallet/broadcasttransaction&#39;,
                                         signed_transaction)

    if &#39;result&#39; in response:
        response.update({
            &#39;transaction&#39;: signed_transaction
        })
    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.contract"><code class="name flex">
<span>def <span class="ident">contract</span></span>(<span>self, address=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Work with a contract</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>TRON Address</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>any</code></dt>
<dd>details (bytecode, abi)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contract(self, address=None, **kwargs):
    &#34;&#34;&#34;Work with a contract

    Args:
        address (str): TRON Address
        **kwargs (any): details (bytecode, abi)
    &#34;&#34;&#34;
    factory_class = kwargs.pop(&#39;contract_factory_class&#39;, self.default_contract_factory)

    contract_factory = factory_class.factory(self.tron, **kwargs)

    if address:
        return contract_factory(address)
    return contract_factory</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.freeze_balance"><code class="name flex">
<span>def <span class="ident">freeze_balance</span></span>(<span>self, amount=0, duration=3, resource='BANDWIDTH', account=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Freezes an amount of TRX.
Will give bandwidth OR Energy and TRON Power(voting rights)
to the owner of the frozen tokens.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>number of frozen trx</dd>
<dt><strong><code>duration</code></strong> :&ensp;<code>int</code></dt>
<dd>duration in days to be frozen</dd>
<dt><strong><code>resource</code></strong> :&ensp;<code>str</code></dt>
<dd>type of resource, must be either "ENERGY" or "BANDWIDTH"</dd>
<dt><strong><code>account</code></strong> :&ensp;<code>str</code></dt>
<dd>address that is freezing trx account</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freeze_balance(self, amount=0, duration=3, resource=&#39;BANDWIDTH&#39;, account=None):
    &#34;&#34;&#34;
    Freezes an amount of TRX.
    Will give bandwidth OR Energy and TRON Power(voting rights)
    to the owner of the frozen tokens.

    Args:
        amount (int): number of frozen trx
        duration (int): duration in days to be frozen
        resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
        account (str): address that is freezing trx account

    &#34;&#34;&#34;

    if account is None:
        account = self.tron.default_address.hex

    transaction = self.tron.transaction_builder.freeze_balance(
        amount,
        duration,
        resource,
        account
    )
    sign = self.sign(transaction)
    response = self.broadcast(sign)

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_account"><code class="name flex">
<span>def <span class="ident">get_account</span></span>(<span>self, address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Query information about an account</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>Address</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_account(self, address=None):
    &#34;&#34;&#34;Query information about an account

    Args:
        address (str): Address

    &#34;&#34;&#34;

    if address is None:
        address = self.tron.default_address.hex

    if not self.tron.isAddress(address):
        raise InvalidTronError(&#39;Invalid address provided&#39;)

    return self.tron.manager.request(&#39;/walletsolidity/getaccount&#39;, {
        &#39;address&#39;: self.tron.address.to_hex(address)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_account_by_id"><code class="name flex">
<span>def <span class="ident">get_account_by_id</span></span>(<span>self, account_id: str, options: object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_account_by_id(self, account_id: str, options: object):
    return self.get_account_info_by_id(account_id, options)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_account_info_by_id"><code class="name flex">
<span>def <span class="ident">get_account_info_by_id</span></span>(<span>self, account_id: str, options: object)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_account_info_by_id(self, account_id: str, options: object):

    if account_id.startswith(&#39;0x&#39;):
        account_id = id[2:]

    if &#39;confirmed&#39; in options:
        return self.tron.manager.request(&#39;/walletsolidity/getaccountbyid&#39;, {
            &#39;account_id&#39;: self.tron.toHex(text=account_id)
        })

    return self.tron.manager.request(&#39;/wallet/getaccountbyid&#39;, {
        &#39;account_id&#39;: self.tron.toHex(text=account_id)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_account_resource"><code class="name flex">
<span>def <span class="ident">get_account_resource</span></span>(<span>self, address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Query the resource information of the account</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>Address</dd>
</dl>
<h2 id="results">Results</h2>
<p>Resource information of the account</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_account_resource(self, address=None):
    &#34;&#34;&#34;Query the resource information of the account

    Args:
        address (str): Address

    Results:
        Resource information of the account

    &#34;&#34;&#34;

    if address is None:
        address = self.tron.default_address.hex

    if not self.tron.isAddress(address):
        raise InvalidTronError(&#39;Invalid address provided&#39;)

    return self.tron.manager.request(&#39;/wallet/getaccountresource&#39;, {
        &#39;address&#39;: self.tron.address.to_hex(address)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_asset_from_name"><code class="name flex">
<span>def <span class="ident">get_asset_from_name</span></span>(<span>self, name: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get asset info from its abbr name, might fail if there're duplicates.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_asset_from_name(self, name: str) -&gt; dict:
    &#34;&#34;&#34;Get asset info from its abbr name, might fail if there&#39;re duplicates.&#34;&#34;&#34;
    assets = [asset for asset in self.list_assets(1000, 0) if asset[&#39;abbr&#39;] == name]
    if assets:
        if len(assets) == 1:
            return assets[0]
        raise ValueError(&#34;duplicated assets with the same name&#34;, [asset[&#39;id&#39;] for asset in assets])
    raise AssetNotFound</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_balance"><code class="name flex">
<span>def <span class="ident">get_balance</span></span>(<span>self, address=None, is_float=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Getting a balance</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>Address</dd>
<dt><strong><code>is_float</code></strong> :&ensp;<code>bool</code></dt>
<dd>Convert to float format</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_balance(self, address=None, is_float=False):
    &#34;&#34;&#34;Getting a balance

    Args:
        address (str): Address
        is_float (bool): Convert to float format

    &#34;&#34;&#34;
    response = self.get_account(address)
    if &#39;balance&#39; not in response:
        return 0

    if is_float:
        return self.tron.fromSun(response[&#39;balance&#39;])

    return response[&#39;balance&#39;]</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_band_width"><code class="name flex">
<span>def <span class="ident">get_band_width</span></span>(<span>self, address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Query bandwidth information.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>address</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Bandwidth information for the account.
If a field doesn't appear, then the corresponding value is 0.
{
"freeNetUsed": 557,
"freeNetLimit": 5000,
"NetUsed": 353,
"NetLimit": 5239157853,
"TotalNetLimit": 43200000000,
"TotalNetWeight": 41228
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_band_width(self, address=None):
    &#34;&#34;&#34;Query bandwidth information.

    Args:
        address (str): address

    Returns:
        Bandwidth information for the account.
        If a field doesn&#39;t appear, then the corresponding value is 0.
        {
            &#34;freeNetUsed&#34;: 557,
            &#34;freeNetLimit&#34;: 5000,
            &#34;NetUsed&#34;: 353,
            &#34;NetLimit&#34;: 5239157853,
            &#34;TotalNetLimit&#34;: 43200000000,
            &#34;TotalNetWeight&#34;: 41228
        }

    &#34;&#34;&#34;

    if address is None:
        address = self.tron.default_address.hex

    if not self.tron.isAddress(address):
        raise InvalidTronError(&#39;Invalid address provided&#39;)

    response = self.tron.manager.request(&#39;/wallet/getaccountnet&#39;, {
        &#39;address&#39;: self.tron.address.to_hex(address)
    })

    free_net_limit = 0 if &#39;freeNetLimit&#39; not in response else response[&#39;freeNetLimit&#39;]
    free_net_used = 0 if &#39;freeNetUsed&#39; not in response else response[&#39;freeNetUsed&#39;]
    net_limit = 0 if &#39;NetLimit&#39; not in response else response[&#39;NetLimit&#39;]
    net_used = 0 if &#39;NetUsed&#39; not in response else response[&#39;NetUsed&#39;]

    return (free_net_limit - free_net_used) + (net_limit - net_used)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_block"><code class="name flex">
<span>def <span class="ident">get_block</span></span>(<span>self, block: Any = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Get block details using HashString or blockNumber</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Any</code></dt>
<dd>ID or height for the block</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block(self, block: Any = None):
    &#34;&#34;&#34;Get block details using HashString or blockNumber

    Args:
        block (Any): ID or height for the block

    &#34;&#34;&#34;

    # If the block identifier is not specified,
    # we take the default
    if block is None:
        block = self.tron.default_block

    if block == &#39;latest&#39;:
        return self.get_current_block()
    elif block == &#39;earliest&#39;:
        return self.get_block(0)

    method = select_method_for_block(
        block,
        if_hash={&#39;url&#39;: &#39;/wallet/getblockbyid&#39;, &#39;field&#39;: &#39;value&#39;},
        if_number={&#39;url&#39;: &#39;/wallet/getblockbynum&#39;, &#39;field&#39;: &#39;num&#39;},
    )

    result = self.tron.manager.request(method[&#39;url&#39;], {
        method[&#39;field&#39;]: block
    })

    if result:
        return result
    return ValueError(&#34;The call to {method[&#39;url&#39;]} did not return a value.&#34;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_block_range"><code class="name flex">
<span>def <span class="ident">get_block_range</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<div class="desc"><p>Query a range of blocks by block height</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong> :&ensp;<code>int</code></dt>
<dd>starting block height, including this block</dd>
<dt><strong><code>end</code></strong> :&ensp;<code>int</code></dt>
<dd>ending block height, excluding that block</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block_range(self, start, end):
    &#34;&#34;&#34;Query a range of blocks by block height

    Args:
        start (int): starting block height, including this block
        end (int): ending block height, excluding that block

    &#34;&#34;&#34;
    if not is_integer(start) or start &lt; 0:
        raise InvalidTronError(&#39;Invalid start of range provided&#39;)

    if not is_integer(end) or end &lt;= start:
        raise InvalidTronError(&#39;Invalid end of range provided&#39;)

    response = self.tron.manager.request(&#39;/wallet/getblockbylimitnext&#39;, {
        &#39;startNum&#39;: int(start),
        &#39;endNum&#39;: int(end) + 1
    }, &#39;post&#39;)

    return response.get(&#39;block&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_block_transaction_count"><code class="name flex">
<span>def <span class="ident">get_block_transaction_count</span></span>(<span>self, block: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Total number of transactions in a block</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Any</code></dt>
<dd>Number or Hash Block</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_block_transaction_count(self, block: Any):
    &#34;&#34;&#34;Total number of transactions in a block

    Args:
        block (Any): Number or Hash Block

    &#34;&#34;&#34;
    transaction = self.get_block(block)
    if &#39;transactions&#39; not in transaction:
        raise TronError(&#39;Parameter &#34;transactions&#34; not found&#39;)

    return len(transaction)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_chain_parameters"><code class="name flex">
<span>def <span class="ident">get_chain_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Getting chain parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_chain_parameters(self):
    &#34;&#34;&#34;Getting chain parameters&#34;&#34;&#34;
    return self.tron.manager.request(&#39;/wallet/getchainparameters&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_confirmed_current_block"><code class="name flex">
<span>def <span class="ident">get_confirmed_current_block</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Query the confirmed latest block</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_confirmed_current_block(self):
    &#34;&#34;&#34;Query the confirmed latest block&#34;&#34;&#34;
    return self.tron.manager.request(&#39;/walletsolidity/getnowblock&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_contract"><code class="name flex">
<span>def <span class="ident">get_contract</span></span>(<span>self, contract_address)</span>
</code></dt>
<dd>
<div class="desc"><p>Queries a contract's information from the blockchain.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>contract_address</code></strong> :&ensp;<code>str</code></dt>
<dd>contract address</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>SmartContract object. JSON</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_contract(self, contract_address):
    &#34;&#34;&#34;Queries a contract&#39;s information from the blockchain.

    Args:
        contract_address (str): contract address

    Returns:
        SmartContract object. JSON

    &#34;&#34;&#34;

    if not self.tron.isAddress(contract_address):
        raise InvalidTronError(&#39;Invalid contract address provided&#39;)

    return self.tron.manager.request(&#39;/wallet/getcontract&#39;, {
        &#39;value&#39;: self.tron.address.to_hex(contract_address)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_current_block"><code class="name flex">
<span>def <span class="ident">get_current_block</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Query the latest block</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_current_block(self):
    &#34;&#34;&#34;Query the latest block&#34;&#34;&#34;
    return self.tron.manager.request(url=&#39;/wallet/getnowblock&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_exchange_by_id"><code class="name flex">
<span>def <span class="ident">get_exchange_by_id</span></span>(<span>self, exchange_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Find exchange by id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>exchange_id</code></strong> :&ensp;<code>str</code></dt>
<dd>ID Exchange</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_exchange_by_id(self, exchange_id):
    &#34;&#34;&#34;Find exchange by id

    Args:
         exchange_id (str): ID Exchange

    &#34;&#34;&#34;

    if not isinstance(exchange_id, int) or exchange_id &lt; 0:
        raise InvalidTronError(&#39;Invalid exchangeID provided&#39;)

    return self.tron.manager.request(&#39;/wallet/getexchangebyid&#39;, {
        &#39;id&#39;: exchange_id
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_latest_blocks"><code class="name flex">
<span>def <span class="ident">get_latest_blocks</span></span>(<span>self, num=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Query the latest blocks</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code></dt>
<dd>the number of blocks to query</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_latest_blocks(self, num=1):
    &#34;&#34;&#34;Query the latest blocks

    Args:
        num (int): the number of blocks to query

    &#34;&#34;&#34;
    if not is_integer(num) or num &lt;= 0:
        raise InvalidTronError(&#39;Invalid limit provided&#39;)

    response = self.tron.manager.request(&#39;/wallet/getblockbylatestnum&#39;, {
        &#39;num&#39;: num
    })

    return response.get(&#39;block&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_list_exchangers"><code class="name flex">
<span>def <span class="ident">get_list_exchangers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get list exchangers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_list_exchangers(self):
    &#34;&#34;&#34;Get list exchangers&#34;&#34;&#34;
    return self.tron.manager.request(&#39;/wallet/listexchanges&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_node_info"><code class="name flex">
<span>def <span class="ident">get_node_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get info about thre node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_node_info(self):
    &#34;&#34;&#34;Get info about thre node&#34;&#34;&#34;
    return self.tron.manager.request(&#39;/wallet/getnodeinfo&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_proposal"><code class="name flex">
<span>def <span class="ident">get_proposal</span></span>(<span>self, proposal_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Query proposal based on id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proposal_id</code></strong> :&ensp;<code>int</code></dt>
<dd>ID</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_proposal(self, proposal_id):
    &#34;&#34;&#34;Query proposal based on id

    Args:
        proposal_id (int): ID

    &#34;&#34;&#34;
    if not isinstance(proposal_id, int) or proposal_id &lt; 0:
        raise InvalidTronError(&#39;Invalid proposalID provided&#39;)

    return self.tron.manager.request(&#39;/wallet/getproposalbyid&#39;, {
        &#39;id&#39;: int(proposal_id)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_token_by_id"><code class="name flex">
<span>def <span class="ident">get_token_by_id</span></span>(<span>self, token_id: str) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"><p>Query token by id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The id of the token, it's a string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_token_by_id(self, token_id: str) -&gt; any:
    &#34;&#34;&#34;Query token by id.

        Args:
            token_id (str): The id of the token, it&#39;s a string
    &#34;&#34;&#34;
    if not is_string(token_id):
        raise ValueError(&#39;Invalid token ID provided&#39;)

    return self.tron.manager.request(&#39;/wallet/getassetissuebyid&#39;, {
        &#39;value&#39;: token_id
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_token_from_id"><code class="name flex">
<span>def <span class="ident">get_token_from_id</span></span>(<span>self, token_id: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Query token by name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the token</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_token_from_id(self, token_id: str):
    &#34;&#34;&#34;Query token by name.

    Args:
        token_id (str): The name of the token

    &#34;&#34;&#34;
    if not isinstance(token_id, str) or not len(token_id):
        raise InvalidTronError(&#39;Invalid token ID provided&#39;)

    return self.tron.manager.request(&#39;/wallet/getassetissuebyname&#39;, {
        &#39;value&#39;: self.tron.toHex(text=token_id)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_token_list_name"><code class="name flex">
<span>def <span class="ident">get_token_list_name</span></span>(<span>self, token_id: str) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"><p>Query token list by name.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>token_id</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the token</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_token_list_name(self, token_id: str) -&gt; any:
    &#34;&#34;&#34;Query token list by name.

        Args:
            token_id (str): The name of the token
    &#34;&#34;&#34;
    if not is_string(token_id):
        raise ValueError(&#39;Invalid token ID provided&#39;)

    return self.tron.manager.request(&#39;/wallet/getassetissuelistbyname&#39;, {
        &#39;value&#39;: self.tron.toHex(text=token_id)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_tokens_issued_by_address"><code class="name flex">
<span>def <span class="ident">get_tokens_issued_by_address</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<div class="desc"><p>List the tokens issued by an account.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>address</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The token issued by the account.
An account can issue only one token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tokens_issued_by_address(self, address):
    &#34;&#34;&#34;List the tokens issued by an account.

    Args:
        address (str): address

    Returns:
        The token issued by the account.
        An account can issue only one token.

    &#34;&#34;&#34;

    if not self.tron.isAddress(address):
        raise InvalidTronError(&#39;Invalid address provided&#39;)

    address = self.tron.address.to_hex(address)

    return self.tron.manager.request(&#39;/wallet/getassetissuebyaccount&#39;, {
        &#39;address&#39;: address
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_transaction"><code class="name flex">
<span>def <span class="ident">get_transaction</span></span>(<span>self, transaction_id: str, is_confirm: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Query transaction based on id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transaction_id</code></strong> :&ensp;<code>str</code></dt>
<dd>transaction id</dd>
</dl>
<p>is_confirm (bool):</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transaction(self, transaction_id: str,
                    is_confirm: bool = False):
    &#34;&#34;&#34;Query transaction based on id

    Args:
        transaction_id (str): transaction id
        is_confirm (bool):
    &#34;&#34;&#34;

    method = &#39;walletsolidity&#39; if is_confirm else &#39;wallet&#39;
    response = self.tron.manager.request(&#39;/{}/gettransactionbyid&#39;.format(method), {
        &#39;value&#39;: transaction_id
    })

    if &#39;txID&#39; not in response:
        raise ValueError(&#39;Transaction not found&#39;)

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_transaction_count"><code class="name flex">
<span>def <span class="ident">get_transaction_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Count all transactions on the network
Note: Possible delays</p>
<h2 id="returns">Returns</h2>
<p>Total number of transactions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transaction_count(self):
    &#34;&#34;&#34;Count all transactions on the network
    Note: Possible delays

    Returns:
        Total number of transactions.

    &#34;&#34;&#34;
    response = self.tron.manager.request(&#39;/wallet/totaltransaction&#39;)
    return response.get(&#39;num&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_transaction_count_by_blocknum"><code class="name flex">
<span>def <span class="ident">get_transaction_count_by_blocknum</span></span>(<span>self, num: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Query transaction's count on a specified block by height</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>num</code></strong> :&ensp;<code>int</code></dt>
<dd>block number</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transaction_count_by_blocknum(self, num: int):
    &#34;&#34;&#34;Query transaction&#39;s count on a specified block by height

    Args:
        num (int): block number
    &#34;&#34;&#34;
    if not is_integer(num) or num &lt; 0:
        raise ValueError(&#39;Invalid num provider&#39;)

    return self.tron.manager.request(&#39;/wallet/gettransactioncountbyblocknum&#39;, {
        &#39;num&#39;: num
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_transaction_from_block"><code class="name flex">
<span>def <span class="ident">get_transaction_from_block</span></span>(<span>self, block: Any, index: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Get transaction details from Block</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>block</code></strong> :&ensp;<code>Any</code></dt>
<dd>Number or Hash Block</dd>
</dl>
<p>index (int) Position</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transaction_from_block(self, block: Any, index: int = 0):
    &#34;&#34;&#34;Get transaction details from Block

    Args:
        block (Any): Number or Hash Block
        index (int) Position

    &#34;&#34;&#34;
    if not is_integer(index) or index &lt; 0:
        raise InvalidTronError(&#39;Invalid transaction index provided&#39;)

    transactions = self.get_block(block).get(&#39;transactions&#39;)
    if not transactions or len(transactions) &lt; index:
        raise TronError(&#39;Transaction not found in block&#39;)

    return transactions[index]</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_transaction_info"><code class="name flex">
<span>def <span class="ident">get_transaction_info</span></span>(<span>self, tx_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Query transaction fee based on id</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tx_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Transaction Id</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Transaction fee，block height and block creation time</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transaction_info(self, tx_id):
    &#34;&#34;&#34;Query transaction fee based on id

    Args:
        tx_id (str): Transaction Id

    Returns:
        Transaction fee，block height and block creation time

    &#34;&#34;&#34;
    response = self.tron.manager.request(&#39;/walletsolidity/gettransactioninfobyid&#39;, {
        &#39;value&#39;: tx_id
    })

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_transactions_from_address"><code class="name flex">
<span>def <span class="ident">get_transactions_from_address</span></span>(<span>self, address=None, limit=30, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Query the list of transactions sent by an address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>address</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code></dt>
<dd>number of transactions expected to be returned</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the starting transaction</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Transactions list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transactions_from_address(self, address=None, limit=30, offset=0):
    &#34;&#34;&#34;Query the list of transactions sent by an address

    Args:
        address (str): address
        limit (int): number of transactions expected to be returned
        offset (int): index of the starting transaction

    Returns:
        Transactions list

    &#34;&#34;&#34;
    return self.get_transactions_related(address, &#39;from&#39;, limit, offset)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_transactions_related"><code class="name flex">
<span>def <span class="ident">get_transactions_related</span></span>(<span>self, address, direction='all', limit=30, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Getting data in the "from", "to" and "all" directions</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>Address</dd>
<dt><strong><code>direction</code></strong> :&ensp;<code>str</code></dt>
<dd>Type direction</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>address</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code></dt>
<dd>number of transactions expected to be returned</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the starting transaction</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transactions_related(self, address, direction=&#39;all&#39;, limit=30, offset=0):
    &#34;&#34;&#34;Getting data in the &#34;from&#34;, &#34;to&#34; and &#34;all&#34; directions

    Args:
        address (str): Address
        direction (str): Type direction
        address (str): address
        limit (int): number of transactions expected to be returned
        offset (int): index of the starting transaction

    &#34;&#34;&#34;

    if direction not in [&#39;from&#39;, &#39;to&#39;, &#39;all&#39;]:
        raise InvalidTronError(&#39;Invalid direction provided: Expected &#34;to&#34;, &#34;from&#34; or &#34;all&#34;&#39;)

    if direction == &#39;all&#39;:
        _from = self.get_transactions_related(address, &#39;from&#39;, limit, offset)
        _to = self.get_transactions_related(address, &#39;to&#39;, limit, offset)

        filter_from = [{**i, &#39;direction&#39;: &#39;from&#39;} for i in _from]
        filter_to = [{**i, &#39;direction&#39;: &#39;to&#39;} for i in _to]

        callback = filter_from
        callback.extend(filter_to)
        return callback

    if address is None:
        address = self.tron.default_address.hex

    if not self.tron.isAddress(address):
        raise InvalidTronError(&#39;Invalid address provided&#39;)

    if not isinstance(limit, int) or limit &lt; 0 or (offset and limit &lt; 1):
        raise InvalidTronError(&#39;Invalid limit provided&#39;)

    if not isinstance(offset, int) or offset &lt; 0:
        raise InvalidTronError(&#39;Invalid offset provided&#39;)

    path = &#39;/walletextension/gettransactions{0}this&#39;.format(direction)
    response = self.tron.manager.request(path, {
        &#39;account&#39;: {
            &#39;address&#39;: self.tron.address.to_hex(address)
        },
        &#39;limit&#39;: limit,
        &#39;offset&#39;: offset
    }, &#39;get&#39;)

    if &#39;transaction&#39; in response:
        return response[&#39;transaction&#39;]
    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_transactions_to_address"><code class="name flex">
<span>def <span class="ident">get_transactions_to_address</span></span>(<span>self, address=None, limit=30, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Query the list of transactions received by an address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>address</dd>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code></dt>
<dd>number of transactions expected to be returned</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the starting transaction</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Transactions list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_transactions_to_address(self, address=None, limit=30, offset=0):
    &#34;&#34;&#34;Query the list of transactions received by an address

    Args:
        address (str): address
        limit (int): number of transactions expected to be returned
        offset (int): index of the starting transaction

    Returns:
        Transactions list

    &#34;&#34;&#34;
    return self.get_transactions_related(address, &#39;to&#39;, limit, offset)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.get_unconfirmed_account_by_id"><code class="name flex">
<span>def <span class="ident">get_unconfirmed_account_by_id</span></span>(<span>self, account_id: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_unconfirmed_account_by_id(self, account_id: str):

    return self.get_account_info_by_id(account_id, {
        &#39;confirmed&#39;: True
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.list_assets"><code class="name flex">
<span>def <span class="ident">list_assets</span></span>(<span>self, limit=0, offset=0) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>List all TRC10 tokens(assets).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_assets(self, limit=0, offset=0) -&gt; list:
    &#34;&#34;&#34;List all TRC10 tokens(assets).&#34;&#34;&#34;
    assets = self.list_tokens(limit, offset)
    for asset in assets:
        asset[&#34;id&#34;] = int(asset[&#34;id&#34;])
        asset[&#34;owner_address&#34;] = key.to_base58check_address(asset[&#34;owner_address&#34;])
        asset[&#34;name&#34;] = bytes.fromhex(asset[&#34;name&#34;]).decode()
        if &#34;abbr&#34; in asset:
            asset[&#34;abbr&#34;] = bytes.fromhex(asset[&#34;abbr&#34;]).decode()
        else:
            asset[&#34;abbr&#34;] = &#34;&#34;
        asset[&#34;description&#34;] = bytes.fromhex(asset[&#34;description&#34;]).decode(&#34;utf8&#34;, &#34;replace&#34;)
        asset[&#34;url&#34;] = bytes.fromhex(asset[&#34;url&#34;]).decode()
    return assets</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.list_exchanges_paginated"><code class="name flex">
<span>def <span class="ident">list_exchanges_paginated</span></span>(<span>self, limit=10, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Paged query transaction pair list</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code></dt>
<dd>number of trading pairs
expected to be returned.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the starting trading pair</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_exchanges_paginated(self, limit=10, offset=0):
    &#34;&#34;&#34;Paged query transaction pair list

    Args:
        limit (int): number of trading pairs  expected to be returned.
        offset (int): index of the starting trading pair

    &#34;&#34;&#34;
    return self.tron.manager.request(&#39;/wallet/listexchangespaginated&#39;, {
        &#39;limit&#39;: limit,
        &#39;offset&#39;: offset
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.list_nodes"><code class="name flex">
<span>def <span class="ident">list_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>List the nodes which the api fullnode is connecting on the network</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_nodes(self):
    &#34;&#34;&#34;List the nodes which the api fullnode is connecting on the network&#34;&#34;&#34;
    response = self.tron.manager.request(&#39;/wallet/listnodes&#39;)
    callback = map(lambda x: {
        &#39;address&#39;: &#39;{}:{}&#39;.format(self.tron.toText(x[&#39;address&#39;][&#39;host&#39;]),
                                  str(x[&#39;address&#39;][&#39;port&#39;]))
    }, response[&#39;nodes&#39;])

    return list(callback)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.list_proposals"><code class="name flex">
<span>def <span class="ident">list_proposals</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Query all proposals</p>
<h2 id="returns">Returns</h2>
<p>Proposal list information</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_proposals(self):
    &#34;&#34;&#34;Query all proposals

    Returns:
        Proposal list information

    &#34;&#34;&#34;
    return self.tron.manager.request(&#39;/wallet/listproposals&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.list_super_representatives"><code class="name flex">
<span>def <span class="ident">list_super_representatives</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Query the list of Super Representatives</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_super_representatives(self):
    &#34;&#34;&#34;Query the list of Super Representatives&#34;&#34;&#34;
    response = self.tron.manager.request(&#39;/wallet/listwitnesses&#39;)
    return response.get(&#39;witnesses&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.list_tokens"><code class="name flex">
<span>def <span class="ident">list_tokens</span></span>(<span>self, limit=0, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Query the list of Tokens with pagination</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>limit</code></strong> :&ensp;<code>int</code></dt>
<dd>index of the starting Token</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>int</code></dt>
<dd>number of Tokens expected to be returned</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of Tokens</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def list_tokens(self, limit=0, offset=0):
    &#34;&#34;&#34;Query the list of Tokens with pagination

    Args:
        limit (int): index of the starting Token
        offset (int): number of Tokens expected to be returned

    Returns:
        List of Tokens

    &#34;&#34;&#34;
    if not is_integer(limit) or (limit and offset &lt; 1):
        raise InvalidTronError(&#39;Invalid limit provided&#39;)

    if not is_integer(offset) or offset &lt; 0:
        raise InvalidTronError(&#39;Invalid offset provided&#39;)

    if not limit:
        return self.tron.manager.request(&#39;/wallet/getassetissuelist&#39;).get(&#39;assetIssue&#39;)

    return self.tron.manager.request(&#39;/wallet/getpaginatedassetissuelist&#39;, {
        &#39;limit&#39;: int(limit),
        &#39;offset&#39;: int(offset)
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.online_sign"><code class="name flex">
<span>def <span class="ident">online_sign</span></span>(<span>self, transaction: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Online transaction signature
Sign the transaction, the api has the risk of leaking the private key,
please make sure to call the api in a secure environment</p>
<h2 id="warnings">Warnings</h2>
<p>Do not use this in any web / user-facing applications.
This will expose the private key.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transaction</code></strong> :&ensp;<code>dict</code></dt>
<dd>transaction details</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def online_sign(self, transaction: dict):
    &#34;&#34;&#34;Online transaction signature
    Sign the transaction, the api has the risk of leaking the private key,
    please make sure to call the api in a secure environment

    Warnings:
        Do not use this in any web / user-facing applications.
        This will expose the private key.

    Args:
        transaction (dict): transaction details

    &#34;&#34;&#34;

    if &#39;signature&#39; in transaction:
        raise TronError(&#39;Transaction is already signed&#39;)

    address = self.tron.address.from_private_key(self.tron.private_key).hex.lower()
    owner_address = transaction[&#39;raw_data&#39;][&#39;contract&#39;][0][&#39;parameter&#39;][&#39;value&#39;][&#39;owner_address&#39;]

    if address != owner_address:
        raise ValueError(&#39;Private key does not match address in transaction&#39;)

    return self.tron.manager.request(&#39;/wallet/gettransactionsign&#39;, {
        &#39;transaction&#39;: transaction,
        &#39;privateKey&#39;: self.tron.private_key
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.proposal_delete"><code class="name flex">
<span>def <span class="ident">proposal_delete</span></span>(<span>self, proposal_id: int, issuer_address: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete proposal</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proposal_id</code></strong> :&ensp;<code>int</code></dt>
<dd>proposal id</dd>
<dt><strong><code>issuer_address</code></strong> :&ensp;<code>str</code></dt>
<dd>delete the person's address</dd>
</dl>
<h2 id="results">Results</h2>
<p>Delete the proposal's transaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def proposal_delete(self, proposal_id: int, issuer_address: str):
    &#34;&#34;&#34;Delete proposal

    Args:
        proposal_id (int): proposal id
        issuer_address (str): delete the person&#39;s address

    Results:
        Delete the proposal&#39;s transaction

    &#34;&#34;&#34;
    if issuer_address is None:
        issuer_address = self.tron.default_address.hex

    transaction = self.tron.transaction_builder.delete_proposal(
        proposal_id,
        issuer_address
    )
    sign = self.sign(transaction)
    response = self.broadcast(sign)

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, to, amount, options=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send funds to the Tron account (option 2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, to, amount, options=None):
    &#34;&#34;&#34;Send funds to the Tron account (option 2)&#34;&#34;&#34;
    return self.send_transaction(to, amount, options)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.send_token"><code class="name flex">
<span>def <span class="ident">send_token</span></span>(<span>self, to, amount, token_id=None, account=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Transfer Token</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>to</code></strong> :&ensp;<code>str</code></dt>
<dd>is the recipient address</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>float</code></dt>
<dd>is the amount of token to transfer</dd>
<dt><strong><code>token_id</code></strong> :&ensp;<code>str</code></dt>
<dd>Token Name(NOT SYMBOL)</dd>
<dt><strong><code>account</code></strong></dt>
<dd>(str): is the address of the withdrawal account</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Token transfer Transaction raw data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_token(self, to, amount, token_id=None, account=None):
    &#34;&#34;&#34;Transfer Token

    Args:
        to (str): is the recipient address
        amount (float): is the amount of token to transfer
        token_id (str): Token Name(NOT SYMBOL)
        account: (str): is the address of the withdrawal account

    Returns:
        Token transfer Transaction raw data

    &#34;&#34;&#34;
    if account is None:
        account = self.tron.default_address.hex

    tx = self.tron.transaction_builder.send_token(
        to,
        amount,
        token_id,
        account
    )
    sign = self.sign(tx)
    result = self.broadcast(sign)

    return result</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.send_transaction"><code class="name flex">
<span>def <span class="ident">send_transaction</span></span>(<span>self, to, amount, options=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send an asset to another account.
Will create and broadcast the transaction if a private key is provided.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>to</code></strong> :&ensp;<code>str</code></dt>
<dd>Address to send TRX to.</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>float</code></dt>
<dd>Amount of TRX to send.</dd>
<dt><strong><code>options</code></strong> :&ensp;<code>Any</code>, optional</dt>
<dd>Options</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_transaction(self, to, amount, options=None):
    &#34;&#34;&#34;Send an asset to another account.
    Will create and broadcast the transaction if a private key is provided.

    Args:
        to (str): Address to send TRX to.
        amount (float): Amount of TRX to send.
        options (Any, optional): Options

    &#34;&#34;&#34;

    if options is None:
        options = {}

    if &#39;from&#39; not in options:
        options = assoc(options, &#39;from&#39;, self.tron.default_address.hex)

    tx = self.tron.transaction_builder.send_transaction(
        to,
        amount,
        options[&#39;from&#39;]
    )
    # If a comment is attached to the transaction,
    # in this case adding to the object
    if &#39;message&#39; in options:
        tx[&#39;raw_data&#39;][&#39;data&#39;] = self.tron.toHex(text=str(options[&#39;message&#39;]))

    sign = self.sign(tx)
    result = self.broadcast(sign)

    return result</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.send_trx"><code class="name flex">
<span>def <span class="ident">send_trx</span></span>(<span>self, to, amount, options=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send funds to the Tron account (option 3)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_trx(self, to, amount, options=None):
    &#34;&#34;&#34;Send funds to the Tron account (option 3)&#34;&#34;&#34;
    return self.send_transaction(to, amount, options)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.sign"><code class="name flex">
<span>def <span class="ident">sign</span></span>(<span>self, transaction: Any, private_key=None, use_tron: bool = True, multisig: bool = False, is_message_hex=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Safe method for signing your transaction</p>
<h2 id="warnings">Warnings</h2>
<p>method: online_sign() - Use only in extreme cases.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transaction</code></strong> :&ensp;<code>Any</code></dt>
<dd>transaction details</dd>
<dt><strong><code>use_tron</code></strong> :&ensp;<code>bool</code></dt>
<dd>is Tron header</dd>
<dt><strong><code>multisig</code></strong> :&ensp;<code>bool</code></dt>
<dd>multi sign</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign(self, transaction: Any, private_key=None, use_tron: bool = True, multisig: bool = False,
         is_message_hex=False):
    &#34;&#34;&#34;Safe method for signing your transaction

    Warnings:
        method: online_sign() - Use only in extreme cases.

    Args:
        transaction (Any): transaction details
        use_tron (bool): is Tron header
        multisig (bool): multi sign

    &#34;&#34;&#34;

    if is_string(transaction):
        if not is_hex(transaction):
            raise TronError(&#39;Expected hex message input&#39;)

        # Determine which header to attach to the message
        # before encrypting or decrypting
        header = TRX_MESSAGE_HEADER if use_tron else ETH_MESSAGE_HEADER
        header += str(len(transaction))

        if is_message_hex:
            from eth_hash.auto import keccak as keccak_256
            message_hash = keccak_256(header.encode(&#39;utf-8&#39;) + bytes.fromhex(transaction))
        else:
            message_hash = self.tron.keccak(text=header + transaction)

        signed_message = Account.sign_hash(self.tron.toHex(message_hash), private_key or self.tron.private_key)
        return signed_message

    if not multisig and &#39;signature&#39; in transaction:
        raise TronError(&#39;Transaction is already signed&#39;)

    try:
        if transaction.get(&#39;transaction&#39;, &#39;&#39;):
            transaction = transaction[&#39;transaction&#39;]

        if not multisig:
            address = self.tron.address.from_private_key(private_key or self.tron.private_key).hex.lower()
            owner_address = transaction[&#39;raw_data&#39;][&#39;contract&#39;][0][&#39;parameter&#39;][&#39;value&#39;][&#39;owner_address&#39;]

            if address != owner_address:
                raise ValueError(&#39;Private key does not match address in transaction&#39;)

        # This option deals with signing of transactions, and writing to the array
        signed_tx = Account.sign_hash(
            transaction[&#39;txID&#39;], private_key or self.tron.private_key
        )
        signature = signed_tx[&#39;signature&#39;].hex()[2:]

        # support multi sign
        if &#39;signature&#39; in transaction and is_list(transaction[&#39;signature&#39;]):
            if not transaction[&#39;signature&#39;].index(signature):
                transaction[&#39;signature&#39;].append(signature)
        else:
            transaction[&#39;signature&#39;] = [signature]

        return transaction
    except ValueError as err:
        raise InvalidTronError(err)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.sign_and_broadcast"><code class="name flex">
<span>def <span class="ident">sign_and_broadcast</span></span>(<span>self, transaction: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Sign and send to the network</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transaction</code></strong> :&ensp;<code>Any</code></dt>
<dd>transaction details</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sign_and_broadcast(self, transaction: Any):
    &#34;&#34;&#34;Sign and send to the network

    Args:
        transaction (Any): transaction details
    &#34;&#34;&#34;
    if not is_object(transaction):
        raise TronError(&#39;Invalid transaction provided&#39;)

    signed_tx = self.sign(transaction)
    return self.broadcast(signed_tx)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.time_until_next_vote_cycle"><code class="name flex">
<span>def <span class="ident">time_until_next_vote_cycle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the time of the next Super Representative vote</p>
<h2 id="returns">Returns</h2>
<p>Number of milliseconds until the next voting time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def time_until_next_vote_cycle(self):
    &#34;&#34;&#34;Get the time of the next Super Representative vote

    Returns:
        Number of milliseconds until the next voting time.

    &#34;&#34;&#34;
    num = self.tron.manager.request(&#39;/wallet/getnextmaintenancetime&#39;).get(&#39;num&#39;)

    if num == -1:
        raise Exception(&#39;Failed to get time until next vote cycle&#39;)

    return math.floor(num / 1000)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.unfreeze_balance"><code class="name flex">
<span>def <span class="ident">unfreeze_balance</span></span>(<span>self, resource='BANDWIDTH', account=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Unfreeze TRX that has passed the minimum freeze duration.
Unfreezing will remove bandwidth and TRON Power.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>resource</code></strong> :&ensp;<code>str</code></dt>
<dd>type of resource, must be either "ENERGY" or "BANDWIDTH"</dd>
<dt><strong><code>account</code></strong> :&ensp;<code>str</code></dt>
<dd>address that is freezing trx account</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unfreeze_balance(self, resource=&#39;BANDWIDTH&#39;, account=None):
    &#34;&#34;&#34;
    Unfreeze TRX that has passed the minimum freeze duration.
    Unfreezing will remove bandwidth and TRON Power.

    Args:
        resource (str): type of resource, must be either &#34;ENERGY&#34; or &#34;BANDWIDTH&#34;
        account (str): address that is freezing trx account

    &#34;&#34;&#34;

    if account is None:
        account = self.tron.default_address.hex

    transaction = self.tron.transaction_builder.unfreeze_balance(
        resource,
        account
    )
    sign = self.sign(transaction)
    response = self.broadcast(sign)

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.update_account"><code class="name flex">
<span>def <span class="ident">update_account</span></span>(<span>self, account_name, address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Modify account name
Note: Username is allowed to edit only once.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>account_name</code></strong> :&ensp;<code>str</code></dt>
<dd>name of the account</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>address</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_account(self, account_name, address=None):
    &#34;&#34;&#34;Modify account name
    Note: Username is allowed to edit only once.

    Args:
        account_name (str): name of the account
        address (str): address

    &#34;&#34;&#34;
    if address is None:
        address = self.tron.default_address.hex

    transaction = self.tron.transaction_builder.update_account(
        account_name,
        address
    )
    sign = self.sign(transaction)
    response = self.broadcast(sign)

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.validate_address"><code class="name flex">
<span>def <span class="ident">validate_address</span></span>(<span>self, address)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate address</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>The address, should be in base58checksum</dd>
<dt><strong><code>_is_hex</code></strong> :&ensp;<code>bool</code></dt>
<dd>hexString or base64 format</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_address(self, address, _is_hex=False):
    &#34;&#34;&#34;Validate address

    Args:
        address (str): The address, should be in base58checksum
        _is_hex (bool): hexString or base64 format

    &#34;&#34;&#34;
    if _is_hex:
        address = self.tron.address.to_hex(address)

    return self.tron.manager.request(&#39;/wallet/validateaddress&#39;, {
        &#39;address&#39;: address
    })</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.verify_message"><code class="name flex">
<span>def <span class="ident">verify_message</span></span>(<span>self, message, signed_message=None, address=None, use_tron: bool = True, is_message_hex=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the address of the account that signed the message with the given hash.
You must specify exactly one of: vrs or signature</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>The message in the format "hex"</dd>
<dt><strong><code>signed_message</code></strong> :&ensp;<code>AttributeDict</code></dt>
<dd>Signature</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>str</code></dt>
<dd>is Address</dd>
<dt><strong><code>use_tron</code></strong> :&ensp;<code>bool</code></dt>
<dd>is Tron header</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_message(self, message, signed_message=None, address=None, use_tron: bool = True, is_message_hex=False):
    &#34;&#34;&#34; Get the address of the account that signed the message with the given hash.
    You must specify exactly one of: vrs or signature

    Args:
        message (str): The message in the format &#34;hex&#34;
        signed_message (AttributeDict): Signature
        address (str): is Address
        use_tron (bool): is Tron header

    &#34;&#34;&#34;
    if address is None:
        address = self.tron.default_address.base58

    if not is_hex(message):
        raise TronError(&#39;Expected hex message input&#39;)

    # Determine which header to attach to the message
    # before encrypting or decrypting
    header = TRX_MESSAGE_HEADER if use_tron else ETH_MESSAGE_HEADER
    header += str(len(message))

    if is_message_hex:
        from eth_hash.auto import keccak as keccak_256
        message_hash = keccak_256(header.encode(&#39;utf-8&#39;) + bytes.fromhex(message))
    else:
        message_hash = self.tron.keccak(text=header + message)
    recovered = Account.recover_hash(self.tron.toHex(message_hash), signed_message.signature)

    tron_address = &#39;41&#39; + recovered[2:]
    base58address = self.tron.address.from_hex(tron_address).decode()

    if base58address == address:
        return True

    raise ValueError(&#39;Signature does not match&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.vote_proposal"><code class="name flex">
<span>def <span class="ident">vote_proposal</span></span>(<span>self, proposal_id, has_approval, voter_address)</span>
</code></dt>
<dd>
<div class="desc"><p>Proposal approval</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proposal_id</code></strong> :&ensp;<code>int</code></dt>
<dd>proposal id</dd>
<dt><strong><code>has_approval</code></strong> :&ensp;<code>bool</code></dt>
<dd>Approved</dd>
<dt><strong><code>voter_address</code></strong> :&ensp;<code>str</code></dt>
<dd>Approve address</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Approval of the proposed transaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vote_proposal(self, proposal_id, has_approval, voter_address):
    &#34;&#34;&#34;Proposal approval

    Args:
        proposal_id (int): proposal id
        has_approval (bool): Approved
        voter_address (str): Approve address

    Returns:
         Approval of the proposed transaction

    &#34;&#34;&#34;

    if voter_address is None:
        voter_address = self.tron.default_address.hex

    transaction = self.tron.transaction_builder.vote_proposal(
        proposal_id,
        has_approval,
        voter_address
    )
    sign = self.sign(transaction)
    response = self.broadcast(sign)

    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.trx.Trx.wait_for_transaction_id"><code class="name flex">
<span>def <span class="ident">wait_for_transaction_id</span></span>(<span>self, transaction_hash: str, timeout=120, poll_latency=0.2)</span>
</code></dt>
<dd>
<div class="desc"><p>Waits for the transaction specified by transaction_hash
to be included in a block, then returns its transaction receipt.</p>
<p>Optionally, specify a timeout in seconds.
If timeout elapses before the transaction is added to a block,
then wait_for_transaction_id() raises a Timeout exception.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>transaction_hash</code></strong> :&ensp;<code>str</code></dt>
<dd>Transaction Hash</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>int</code></dt>
<dd>TimeOut</dd>
<dt><strong><code>poll_latency</code></strong> :&ensp;<code>any</code></dt>
<dd>between subsequent requests</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_transaction_id(self,
                            transaction_hash: str,
                            timeout=120,
                            poll_latency=0.2):
    &#34;&#34;&#34;
    Waits for the transaction specified by transaction_hash
    to be included in a block, then returns its transaction receipt.

    Optionally, specify a timeout in seconds.
    If timeout elapses before the transaction is added to a block,
    then wait_for_transaction_id() raises a Timeout exception.


    Args:
        transaction_hash (str): Transaction Hash
        timeout (int): TimeOut
        poll_latency (any):  between subsequent requests

    &#34;&#34;&#34;
    try:
        if poll_latency &gt; timeout:
            poll_latency = timeout

        return wait_for_transaction_id(self.tron, transaction_hash, timeout, poll_latency)
    except TimeoutError:
        raise TimeExhausted(
            &#34;Transaction {} is not in the chain, after {} seconds&#34;.format(
                transaction_hash,
                timeout,
            )
        )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#tronpytooltrx">tronpytool.trx</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tronpytool" href="index.html">tronpytool</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tronpytool.trx.Trx" href="#tronpytool.trx.Trx">Trx</a></code></h4>
<ul class="">
<li><code><a title="tronpytool.trx.Trx.apply_for_sr" href="#tronpytool.trx.Trx.apply_for_sr">apply_for_sr</a></code></li>
<li><code><a title="tronpytool.trx.Trx.broadcast" href="#tronpytool.trx.Trx.broadcast">broadcast</a></code></li>
<li><code><a title="tronpytool.trx.Trx.contract" href="#tronpytool.trx.Trx.contract">contract</a></code></li>
<li><code><a title="tronpytool.trx.Trx.default_contract_factory" href="#tronpytool.trx.Trx.default_contract_factory">default_contract_factory</a></code></li>
<li><code><a title="tronpytool.trx.Trx.freeze_balance" href="#tronpytool.trx.Trx.freeze_balance">freeze_balance</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_account" href="#tronpytool.trx.Trx.get_account">get_account</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_account_by_id" href="#tronpytool.trx.Trx.get_account_by_id">get_account_by_id</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_account_info_by_id" href="#tronpytool.trx.Trx.get_account_info_by_id">get_account_info_by_id</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_account_resource" href="#tronpytool.trx.Trx.get_account_resource">get_account_resource</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_asset_from_name" href="#tronpytool.trx.Trx.get_asset_from_name">get_asset_from_name</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_balance" href="#tronpytool.trx.Trx.get_balance">get_balance</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_band_width" href="#tronpytool.trx.Trx.get_band_width">get_band_width</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_block" href="#tronpytool.trx.Trx.get_block">get_block</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_block_range" href="#tronpytool.trx.Trx.get_block_range">get_block_range</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_block_transaction_count" href="#tronpytool.trx.Trx.get_block_transaction_count">get_block_transaction_count</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_chain_parameters" href="#tronpytool.trx.Trx.get_chain_parameters">get_chain_parameters</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_confirmed_current_block" href="#tronpytool.trx.Trx.get_confirmed_current_block">get_confirmed_current_block</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_contract" href="#tronpytool.trx.Trx.get_contract">get_contract</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_current_block" href="#tronpytool.trx.Trx.get_current_block">get_current_block</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_exchange_by_id" href="#tronpytool.trx.Trx.get_exchange_by_id">get_exchange_by_id</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_latest_blocks" href="#tronpytool.trx.Trx.get_latest_blocks">get_latest_blocks</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_list_exchangers" href="#tronpytool.trx.Trx.get_list_exchangers">get_list_exchangers</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_node_info" href="#tronpytool.trx.Trx.get_node_info">get_node_info</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_proposal" href="#tronpytool.trx.Trx.get_proposal">get_proposal</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_token_by_id" href="#tronpytool.trx.Trx.get_token_by_id">get_token_by_id</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_token_from_id" href="#tronpytool.trx.Trx.get_token_from_id">get_token_from_id</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_token_list_name" href="#tronpytool.trx.Trx.get_token_list_name">get_token_list_name</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_tokens_issued_by_address" href="#tronpytool.trx.Trx.get_tokens_issued_by_address">get_tokens_issued_by_address</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_transaction" href="#tronpytool.trx.Trx.get_transaction">get_transaction</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_transaction_count" href="#tronpytool.trx.Trx.get_transaction_count">get_transaction_count</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_transaction_count_by_blocknum" href="#tronpytool.trx.Trx.get_transaction_count_by_blocknum">get_transaction_count_by_blocknum</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_transaction_from_block" href="#tronpytool.trx.Trx.get_transaction_from_block">get_transaction_from_block</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_transaction_info" href="#tronpytool.trx.Trx.get_transaction_info">get_transaction_info</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_transactions_from_address" href="#tronpytool.trx.Trx.get_transactions_from_address">get_transactions_from_address</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_transactions_related" href="#tronpytool.trx.Trx.get_transactions_related">get_transactions_related</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_transactions_to_address" href="#tronpytool.trx.Trx.get_transactions_to_address">get_transactions_to_address</a></code></li>
<li><code><a title="tronpytool.trx.Trx.get_unconfirmed_account_by_id" href="#tronpytool.trx.Trx.get_unconfirmed_account_by_id">get_unconfirmed_account_by_id</a></code></li>
<li><code><a title="tronpytool.trx.Trx.list_assets" href="#tronpytool.trx.Trx.list_assets">list_assets</a></code></li>
<li><code><a title="tronpytool.trx.Trx.list_exchanges_paginated" href="#tronpytool.trx.Trx.list_exchanges_paginated">list_exchanges_paginated</a></code></li>
<li><code><a title="tronpytool.trx.Trx.list_nodes" href="#tronpytool.trx.Trx.list_nodes">list_nodes</a></code></li>
<li><code><a title="tronpytool.trx.Trx.list_proposals" href="#tronpytool.trx.Trx.list_proposals">list_proposals</a></code></li>
<li><code><a title="tronpytool.trx.Trx.list_super_representatives" href="#tronpytool.trx.Trx.list_super_representatives">list_super_representatives</a></code></li>
<li><code><a title="tronpytool.trx.Trx.list_tokens" href="#tronpytool.trx.Trx.list_tokens">list_tokens</a></code></li>
<li><code><a title="tronpytool.trx.Trx.online_sign" href="#tronpytool.trx.Trx.online_sign">online_sign</a></code></li>
<li><code><a title="tronpytool.trx.Trx.proposal_delete" href="#tronpytool.trx.Trx.proposal_delete">proposal_delete</a></code></li>
<li><code><a title="tronpytool.trx.Trx.send" href="#tronpytool.trx.Trx.send">send</a></code></li>
<li><code><a title="tronpytool.trx.Trx.send_token" href="#tronpytool.trx.Trx.send_token">send_token</a></code></li>
<li><code><a title="tronpytool.trx.Trx.send_transaction" href="#tronpytool.trx.Trx.send_transaction">send_transaction</a></code></li>
<li><code><a title="tronpytool.trx.Trx.send_trx" href="#tronpytool.trx.Trx.send_trx">send_trx</a></code></li>
<li><code><a title="tronpytool.trx.Trx.sign" href="#tronpytool.trx.Trx.sign">sign</a></code></li>
<li><code><a title="tronpytool.trx.Trx.sign_and_broadcast" href="#tronpytool.trx.Trx.sign_and_broadcast">sign_and_broadcast</a></code></li>
<li><code><a title="tronpytool.trx.Trx.time_until_next_vote_cycle" href="#tronpytool.trx.Trx.time_until_next_vote_cycle">time_until_next_vote_cycle</a></code></li>
<li><code><a title="tronpytool.trx.Trx.unfreeze_balance" href="#tronpytool.trx.Trx.unfreeze_balance">unfreeze_balance</a></code></li>
<li><code><a title="tronpytool.trx.Trx.update_account" href="#tronpytool.trx.Trx.update_account">update_account</a></code></li>
<li><code><a title="tronpytool.trx.Trx.validate_address" href="#tronpytool.trx.Trx.validate_address">validate_address</a></code></li>
<li><code><a title="tronpytool.trx.Trx.verify_message" href="#tronpytool.trx.Trx.verify_message">verify_message</a></code></li>
<li><code><a title="tronpytool.trx.Trx.vote_proposal" href="#tronpytool.trx.Trx.vote_proposal">vote_proposal</a></code></li>
<li><code><a title="tronpytool.trx.Trx.wait_for_transaction_id" href="#tronpytool.trx.Trx.wait_for_transaction_id">wait_for_transaction_id</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>