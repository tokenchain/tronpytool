<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>tronpytool.main API documentation</title>
<meta name="description" content="tronpytool.main
…" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tronpytool.main</code></h1>
</header>
<section id="section-intro">
<h1 id="tronpytoolmain">tronpytool.main</h1>
<p>Connect to the Tron network.</p>
<p>:copyright: © 2019 by the iEXBase.
:license: MIT License</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# -*- coding: utf-8 -*-
# --------------------------------------------------------------------
# Copyright (c) iEXBase. All rights reserved.
# Licensed under the MIT License.
# See License.txt in the project root for license information.
# --------------------------------------------------------------------

&#34;&#34;&#34;
    tronpytool.main
    ===============

    Connect to the Tron network.

    :copyright: © 2019 by the iEXBase.
    :license: MIT License
&#34;&#34;&#34;

from urllib.parse import urlencode

from eth_account.datastructures import AttributeDict
from eth_utils import (
    apply_to_return_value,
    keccak as tron_keccak,
)
from hexbytes import HexBytes
from trx_utils import (
    to_sun,
    from_sun,
    is_integer,
    add_0x_prefix,
    remove_0x_prefix,
    is_address,
    to_hex
)

from tronpytool import constants
from tronpytool.common.abi import map_abi_data
from tronpytool.common.account import Address, PrivateKey, Account
from tronpytool.common.encoding import (
    to_bytes,
    to_int,
    to_text,
    to_json,
    hex_encode_abi_type
)
from tronpytool.common.key import PrivateKey as PrivateKeyFactory
from tronpytool.common.normalizers import abi_resolver
from tronpytool.exceptions import (
    InvalidTronError,
    TronError
)
from tronpytool.manager import TronManager
from tronpytool.transactionbuilder import TransactionBuilder
from tronpytool.trx import Trx

DEFAULT_MODULES = {
    &#39;trx&#39;: Trx
}


class Tron:
    # Providers
    # SolcWrap = SolcWrap

    _default_block = None
    _private_key = None
    _default_address = AttributeDict({})

    # Encoding and Decoding
    toBytes = staticmethod(to_bytes)
    toInt = staticmethod(to_int)
    toHex = staticmethod(to_hex)
    toText = staticmethod(to_text)
    toJSON = staticmethod(to_json)

    # Currency Utility
    toSun = staticmethod(to_sun)
    fromSun = staticmethod(from_sun)

    # Validate address
    isAddress = staticmethod(is_address)

    def __init__(self, **kwargs):
        &#34;&#34;&#34;Connect to the Tron network.

        Args:
            kwargs (Any): We fill the most necessary parameters
            for working with blockchain Tron

        &#34;&#34;&#34;

        # We check the obtained nodes, if the necessary parameters
        # are not specified, then we take the default
        kwargs.setdefault(&#39;full_node&#39;, constants.DEFAULT_NODES[&#39;full_node&#39;])
        kwargs.setdefault(&#39;solidity_node&#39;, constants.DEFAULT_NODES[&#39;solidity_node&#39;])
        kwargs.setdefault(&#39;event_server&#39;, constants.DEFAULT_NODES[&#39;event_server&#39;])

        # The node manager allows you to automatically determine the node
        # on the router or manually refer to a specific node.
        # solidity_node, full_node or event_server
        self.manager = TronManager(self, dict(
            full_node=kwargs.get(&#39;full_node&#39;),
            solidity_node=kwargs.get(&#39;solidity_node&#39;),
            event_server=kwargs.get(&#39;event_server&#39;)
        ))

        # If the parameter of the private key is not empty,
        # then write to the variable
        if &#39;private_key&#39; in kwargs:
            self.private_key = kwargs.get(&#39;private_key&#39;)

        # We check whether the default wallet address is set when
        # defining the class, and then written to the variable
        if &#39;default_address&#39; in kwargs:
            self.default_address = kwargs.get(&#39;default_address&#39;)

        # If custom methods are not declared,
        # we take the default from the list
        modules = kwargs.setdefault(&#39;modules&#39;, DEFAULT_MODULES)
        for module_name, module_class in modules.items():
            module_class.attach(self, module_name)

        self.transaction_builder = TransactionBuilder(self)

    def setNetwork(self, networkname=&#34;nile&#34;):
        group = constants.conf_for_name(networkname)
        self.manager = TronManager(self, constants.to_providers_set(group))
        return self

    @property
    def default_block(self):
        return self._default_block

    @default_block.setter
    def default_block(self, block_id):
        &#34;&#34;&#34;Sets the default block used as a reference for all future calls.&#34;&#34;&#34;
        if block_id in (&#39;latest&#39;, &#39;earliest&#39;, 0):
            self._default_block = block_id
            return

        if not is_integer(block_id) or not block_id:
            raise ValueError(&#39;Invalid block ID provided&#39;)

        self._default_block = abs(block_id)

    @property
    def providers(self):
        &#34;&#34;&#34;List providers&#34;&#34;&#34;
        return self.manager.providers

    @property
    def private_key(self) -&gt; str:
        &#34;&#34;&#34;Get a private key&#34;&#34;&#34;
        return self._private_key

    def getKey(self) -&gt; &#34;PrivateKey&#34;:
        return self.private_key_class


    @private_key.setter
    def private_key(self, value: str) -&gt; None:
        &#34;&#34;&#34;Set a private key used with the TronAPI instance,
        used for obtaining the address, signing transactions etc...

        Args:
            value (str): Private key
        &#34;&#34;&#34;
        try:
            private_key = PrivateKey(value)
        except ValueError:
            raise TronError(&#39;Invalid private key provided&#39;)
        self.private_key_class = private_key
        self._private_key = str(private_key).lower()

    @property
    def default_address(self) -&gt; AttributeDict:
        &#34;&#34;&#34;Get a TRON Address&#34;&#34;&#34;
        return self._default_address

    @default_address.setter
    def default_address(self, address: str) -&gt; None:
        &#34;&#34;&#34;Sets the address used with all Tron API.
        Will not sign any transactions.

        Args:
             address (str) Tron Address

        &#34;&#34;&#34;

        if not self.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        _hex = self.address.to_hex(address)
        _base58 = self.address.from_hex(address)
        _private_base58 = self.address.from_private_key(self._private_key).base58

        # check the addresses
        if self._private_key and _private_base58 != _base58:
            self._private_key = None

        self._default_address = AttributeDict({
            &#39;hex&#39;: _hex,
            &#39;base58&#39;: _base58
        })

    def get_event_result(self, **kwargs):
        &#34;&#34;&#34;Will return all events matching the filters.

        Args:
            kwargs (any): List parameters
        &#34;&#34;&#34;

        # Check the most necessary parameters
        since_timestamp = kwargs.setdefault(&#39;since_timestamp&#39;, 0)
        event_name = kwargs.setdefault(&#39;event_name&#39;, &#39;Notify&#39;)
        block_number = kwargs.setdefault(&#39;block_number&#39;, &#39;&#39;)
        size = kwargs.setdefault(&#39;size&#39;, 20)
        page = kwargs.setdefault(&#39;page&#39;, 1)
        only_confirmed = kwargs.setdefault(&#39;only_confirmed&#39;, None)
        only_unconfirmed = kwargs.setdefault(&#39;only_unconfirmed&#39;, None)
        previous_last = kwargs.setdefault(&#39;previous_last_event_fingerprint&#39;, None)
        contract_address = kwargs.setdefault(&#39;contract_address&#39;, self.default_address.hex)
        sort = kwargs.setdefault(&#39;sort&#39;, None)
        from_timestamp = kwargs.setdefault(&#39;from_timestamp&#39;, None)

        if not self.isAddress(contract_address):
            raise InvalidTronError(&#39;Invalid contract address provided&#39;)

        if event_name and not contract_address:
            raise TronError(&#39;Usage of event name filtering requires a contract address&#39;)

        if block_number and event_name is None:
            raise TronError(&#39;Usage of block number filtering requires an event name&#39;)

        if not is_integer(page):
            raise ValueError(&#39;Invalid size provided&#39;)

        if not is_integer(since_timestamp):
            raise ValueError(&#39;Invalid sinceTimestamp provided&#39;)

        # If the size exceeds 200, displays an error
        if size &gt; 200:
            raise ValueError(&#39;Defaulting to maximum accepted size: 200&#39;)

        # We collect all parameters in one array
        route_params = []
        if contract_address:
            route_params.append(contract_address)
        if event_name:
            route_params.append(event_name)
        if block_number:
            route_params.append(block_number)

        route = &#39;/&#39;.join(route_params)

        qs = {
            &#39;since&#39;: since_timestamp,
            &#39;page&#39;: page,
            &#39;size&#39;: size
        }

        if only_confirmed is not None:
            qs.update({&#39;onlyConfirmed&#39;: only_confirmed})

        if only_unconfirmed is not None and not only_confirmed:
            qs.update({&#39;onlyUnconfirmed&#39;: only_unconfirmed})

        if previous_last is not None:
            qs.update({&#39;previousLastEventFingerprint&#39;: previous_last})

        if from_timestamp is not None:
            qs.update({&#39;fromTimestamp&#39;: from_timestamp})

        if sort is not None:
            qs.update({&#39;sort&#39;: sort})

        return self.manager.request(&#34;/event/contract/{0}?{1}&#34;
                                    .format(route, urlencode(qs)), method=&#39;get&#39;)

    def get_event_transaction_id(self, tx_id):
        &#34;&#34;&#34;Will return all events within a transactionID.

        Args:
            tx_id (str): TransactionID to query for events.
        &#34;&#34;&#34;
        response = self.manager.request(&#39;/event/transaction/&#39; + tx_id, method=&#39;get&#39;)
        return response

    @property
    def address(self) -&gt; Address:
        &#34;&#34;&#34;Helper object that allows you to convert
        between hex/base58 and private key representations of a TRON address.

        Note:
            If you wish to convert generic data to hexadecimal strings,
            please use the function tron.to_hex.
            return a static class
        &#34;&#34;&#34;
        return Address()

    # Address utilities
    @staticmethod
    def generate_address(priv_key=None) -&gt; dict:
        &#34;&#34;&#34;Address utilities Generate a random address.&#34;&#34;&#34;
        if priv_key is None:
            priv_key = PrivateKeyFactory.random()
        return {
            &#34;base58check_address&#34;: priv_key.public_key.to_base58check_address(),
            &#34;hex_address&#34;: priv_key.public_key.to_hex_address(),
            &#34;private_key&#34;: priv_key.hex(),
            &#34;public_key&#34;: priv_key.public_key.hex(),
        }

    def get_address_from_passphrase(self, passphrase: str) -&gt; dict:
        &#34;&#34;&#34;Get an address from a passphrase, compatiable with `wallet/createaddress`.&#34;&#34;&#34;
        priv_key = PrivateKeyFactory.from_passphrase(passphrase.encode())
        return self.generate_address(priv_key)

    @staticmethod
    def create_account() -&gt; PrivateKey:
        &#34;&#34;&#34;Create account

        Warning: Please control risks when using this API.
        To ensure environmental security, please do not invoke APIs
        provided by other or invoke this very API on a public network.

        &#34;&#34;&#34;
        return Account.create()

    def solidity_sha3(self, abi_types, values):
        &#34;&#34;&#34;
            Executes keccak256 exactly as Solidity does.
            Takes list of abi_types as inputs -- `[uint24, int8[], bool]`
            and list of corresponding values  -- `[20, [-1, 5, 0], True]`

            Args:
                abi_types (any): types abi
                values (any): values

            Examples:
                &gt;&gt;&gt; tron = Tron()
                &gt;&gt;&gt; sol = tron.solidity_sha3([&#39;uint8[]&#39;], [[1, 2, 3, 4, 5]])
                &gt;&gt;&gt; assert sol.hex() == &#39;0x5917e5a395fb9b454434de59651d36822a9e29c5ec57474df3e67937b969460c&#39;

        &#34;&#34;&#34;
        if len(abi_types) != len(values):
            raise ValueError(
                &#34;Length mismatch between provided abi types and values.  Got &#34;
                &#34;{0} types and {1} values.&#34;.format(len(abi_types), len(values))
            )

        normalized_values = map_abi_data([abi_resolver()], abi_types, values)

        hex_string = add_0x_prefix(&#39;&#39;.join(
            remove_0x_prefix(hex_encode_abi_type(abi_type, value))
            for abi_type, value
            in zip(abi_types, normalized_values)
        ))
        return self.keccak(hexstr=hex_string)

    @staticmethod
    @apply_to_return_value(HexBytes)
    def keccak(primitive=None, text=None, hexstr=None):
        if isinstance(primitive, (bytes, int, type(None))):
            input_bytes = to_bytes(primitive, hexstr=hexstr, text=text)
            return tron_keccak(input_bytes)

        raise TypeError(
            &#34;You called keccak with first arg %r and keywords %r. You must call it with one of &#34;
            &#34;these approaches: keccak(text=&#39;txt&#39;), keccak(hexstr=&#39;0x747874&#39;), &#34;
            &#34;keccak(b&#39;\\x74\\x78\\x74&#39;), or keccak(0x747874).&#34; % (
                primitive,
                {&#39;text&#39;: text, &#39;hexstr&#39;: hexstr}
            )
        )

    def is_connected(self):
        &#34;&#34;&#34;List of available providers&#34;&#34;&#34;
        return self.manager.is_connected()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tronpytool.main.Tron"><code class="flex name class">
<span>class <span class="ident">Tron</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Connect to the Tron network.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>Any</code></dt>
<dd>We fill the most necessary parameters</dd>
</dl>
<p>for working with blockchain Tron</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tron:
    # Providers
    # SolcWrap = SolcWrap

    _default_block = None
    _private_key = None
    _default_address = AttributeDict({})

    # Encoding and Decoding
    toBytes = staticmethod(to_bytes)
    toInt = staticmethod(to_int)
    toHex = staticmethod(to_hex)
    toText = staticmethod(to_text)
    toJSON = staticmethod(to_json)

    # Currency Utility
    toSun = staticmethod(to_sun)
    fromSun = staticmethod(from_sun)

    # Validate address
    isAddress = staticmethod(is_address)

    def __init__(self, **kwargs):
        &#34;&#34;&#34;Connect to the Tron network.

        Args:
            kwargs (Any): We fill the most necessary parameters
            for working with blockchain Tron

        &#34;&#34;&#34;

        # We check the obtained nodes, if the necessary parameters
        # are not specified, then we take the default
        kwargs.setdefault(&#39;full_node&#39;, constants.DEFAULT_NODES[&#39;full_node&#39;])
        kwargs.setdefault(&#39;solidity_node&#39;, constants.DEFAULT_NODES[&#39;solidity_node&#39;])
        kwargs.setdefault(&#39;event_server&#39;, constants.DEFAULT_NODES[&#39;event_server&#39;])

        # The node manager allows you to automatically determine the node
        # on the router or manually refer to a specific node.
        # solidity_node, full_node or event_server
        self.manager = TronManager(self, dict(
            full_node=kwargs.get(&#39;full_node&#39;),
            solidity_node=kwargs.get(&#39;solidity_node&#39;),
            event_server=kwargs.get(&#39;event_server&#39;)
        ))

        # If the parameter of the private key is not empty,
        # then write to the variable
        if &#39;private_key&#39; in kwargs:
            self.private_key = kwargs.get(&#39;private_key&#39;)

        # We check whether the default wallet address is set when
        # defining the class, and then written to the variable
        if &#39;default_address&#39; in kwargs:
            self.default_address = kwargs.get(&#39;default_address&#39;)

        # If custom methods are not declared,
        # we take the default from the list
        modules = kwargs.setdefault(&#39;modules&#39;, DEFAULT_MODULES)
        for module_name, module_class in modules.items():
            module_class.attach(self, module_name)

        self.transaction_builder = TransactionBuilder(self)

    def setNetwork(self, networkname=&#34;nile&#34;):
        group = constants.conf_for_name(networkname)
        self.manager = TronManager(self, constants.to_providers_set(group))
        return self

    @property
    def default_block(self):
        return self._default_block

    @default_block.setter
    def default_block(self, block_id):
        &#34;&#34;&#34;Sets the default block used as a reference for all future calls.&#34;&#34;&#34;
        if block_id in (&#39;latest&#39;, &#39;earliest&#39;, 0):
            self._default_block = block_id
            return

        if not is_integer(block_id) or not block_id:
            raise ValueError(&#39;Invalid block ID provided&#39;)

        self._default_block = abs(block_id)

    @property
    def providers(self):
        &#34;&#34;&#34;List providers&#34;&#34;&#34;
        return self.manager.providers

    @property
    def private_key(self) -&gt; str:
        &#34;&#34;&#34;Get a private key&#34;&#34;&#34;
        return self._private_key

    def getKey(self) -&gt; &#34;PrivateKey&#34;:
        return self.private_key_class


    @private_key.setter
    def private_key(self, value: str) -&gt; None:
        &#34;&#34;&#34;Set a private key used with the TronAPI instance,
        used for obtaining the address, signing transactions etc...

        Args:
            value (str): Private key
        &#34;&#34;&#34;
        try:
            private_key = PrivateKey(value)
        except ValueError:
            raise TronError(&#39;Invalid private key provided&#39;)
        self.private_key_class = private_key
        self._private_key = str(private_key).lower()

    @property
    def default_address(self) -&gt; AttributeDict:
        &#34;&#34;&#34;Get a TRON Address&#34;&#34;&#34;
        return self._default_address

    @default_address.setter
    def default_address(self, address: str) -&gt; None:
        &#34;&#34;&#34;Sets the address used with all Tron API.
        Will not sign any transactions.

        Args:
             address (str) Tron Address

        &#34;&#34;&#34;

        if not self.isAddress(address):
            raise InvalidTronError(&#39;Invalid address provided&#39;)

        _hex = self.address.to_hex(address)
        _base58 = self.address.from_hex(address)
        _private_base58 = self.address.from_private_key(self._private_key).base58

        # check the addresses
        if self._private_key and _private_base58 != _base58:
            self._private_key = None

        self._default_address = AttributeDict({
            &#39;hex&#39;: _hex,
            &#39;base58&#39;: _base58
        })

    def get_event_result(self, **kwargs):
        &#34;&#34;&#34;Will return all events matching the filters.

        Args:
            kwargs (any): List parameters
        &#34;&#34;&#34;

        # Check the most necessary parameters
        since_timestamp = kwargs.setdefault(&#39;since_timestamp&#39;, 0)
        event_name = kwargs.setdefault(&#39;event_name&#39;, &#39;Notify&#39;)
        block_number = kwargs.setdefault(&#39;block_number&#39;, &#39;&#39;)
        size = kwargs.setdefault(&#39;size&#39;, 20)
        page = kwargs.setdefault(&#39;page&#39;, 1)
        only_confirmed = kwargs.setdefault(&#39;only_confirmed&#39;, None)
        only_unconfirmed = kwargs.setdefault(&#39;only_unconfirmed&#39;, None)
        previous_last = kwargs.setdefault(&#39;previous_last_event_fingerprint&#39;, None)
        contract_address = kwargs.setdefault(&#39;contract_address&#39;, self.default_address.hex)
        sort = kwargs.setdefault(&#39;sort&#39;, None)
        from_timestamp = kwargs.setdefault(&#39;from_timestamp&#39;, None)

        if not self.isAddress(contract_address):
            raise InvalidTronError(&#39;Invalid contract address provided&#39;)

        if event_name and not contract_address:
            raise TronError(&#39;Usage of event name filtering requires a contract address&#39;)

        if block_number and event_name is None:
            raise TronError(&#39;Usage of block number filtering requires an event name&#39;)

        if not is_integer(page):
            raise ValueError(&#39;Invalid size provided&#39;)

        if not is_integer(since_timestamp):
            raise ValueError(&#39;Invalid sinceTimestamp provided&#39;)

        # If the size exceeds 200, displays an error
        if size &gt; 200:
            raise ValueError(&#39;Defaulting to maximum accepted size: 200&#39;)

        # We collect all parameters in one array
        route_params = []
        if contract_address:
            route_params.append(contract_address)
        if event_name:
            route_params.append(event_name)
        if block_number:
            route_params.append(block_number)

        route = &#39;/&#39;.join(route_params)

        qs = {
            &#39;since&#39;: since_timestamp,
            &#39;page&#39;: page,
            &#39;size&#39;: size
        }

        if only_confirmed is not None:
            qs.update({&#39;onlyConfirmed&#39;: only_confirmed})

        if only_unconfirmed is not None and not only_confirmed:
            qs.update({&#39;onlyUnconfirmed&#39;: only_unconfirmed})

        if previous_last is not None:
            qs.update({&#39;previousLastEventFingerprint&#39;: previous_last})

        if from_timestamp is not None:
            qs.update({&#39;fromTimestamp&#39;: from_timestamp})

        if sort is not None:
            qs.update({&#39;sort&#39;: sort})

        return self.manager.request(&#34;/event/contract/{0}?{1}&#34;
                                    .format(route, urlencode(qs)), method=&#39;get&#39;)

    def get_event_transaction_id(self, tx_id):
        &#34;&#34;&#34;Will return all events within a transactionID.

        Args:
            tx_id (str): TransactionID to query for events.
        &#34;&#34;&#34;
        response = self.manager.request(&#39;/event/transaction/&#39; + tx_id, method=&#39;get&#39;)
        return response

    @property
    def address(self) -&gt; Address:
        &#34;&#34;&#34;Helper object that allows you to convert
        between hex/base58 and private key representations of a TRON address.

        Note:
            If you wish to convert generic data to hexadecimal strings,
            please use the function tron.to_hex.
            return a static class
        &#34;&#34;&#34;
        return Address()

    # Address utilities
    @staticmethod
    def generate_address(priv_key=None) -&gt; dict:
        &#34;&#34;&#34;Address utilities Generate a random address.&#34;&#34;&#34;
        if priv_key is None:
            priv_key = PrivateKeyFactory.random()
        return {
            &#34;base58check_address&#34;: priv_key.public_key.to_base58check_address(),
            &#34;hex_address&#34;: priv_key.public_key.to_hex_address(),
            &#34;private_key&#34;: priv_key.hex(),
            &#34;public_key&#34;: priv_key.public_key.hex(),
        }

    def get_address_from_passphrase(self, passphrase: str) -&gt; dict:
        &#34;&#34;&#34;Get an address from a passphrase, compatiable with `wallet/createaddress`.&#34;&#34;&#34;
        priv_key = PrivateKeyFactory.from_passphrase(passphrase.encode())
        return self.generate_address(priv_key)

    @staticmethod
    def create_account() -&gt; PrivateKey:
        &#34;&#34;&#34;Create account

        Warning: Please control risks when using this API.
        To ensure environmental security, please do not invoke APIs
        provided by other or invoke this very API on a public network.

        &#34;&#34;&#34;
        return Account.create()

    def solidity_sha3(self, abi_types, values):
        &#34;&#34;&#34;
            Executes keccak256 exactly as Solidity does.
            Takes list of abi_types as inputs -- `[uint24, int8[], bool]`
            and list of corresponding values  -- `[20, [-1, 5, 0], True]`

            Args:
                abi_types (any): types abi
                values (any): values

            Examples:
                &gt;&gt;&gt; tron = Tron()
                &gt;&gt;&gt; sol = tron.solidity_sha3([&#39;uint8[]&#39;], [[1, 2, 3, 4, 5]])
                &gt;&gt;&gt; assert sol.hex() == &#39;0x5917e5a395fb9b454434de59651d36822a9e29c5ec57474df3e67937b969460c&#39;

        &#34;&#34;&#34;
        if len(abi_types) != len(values):
            raise ValueError(
                &#34;Length mismatch between provided abi types and values.  Got &#34;
                &#34;{0} types and {1} values.&#34;.format(len(abi_types), len(values))
            )

        normalized_values = map_abi_data([abi_resolver()], abi_types, values)

        hex_string = add_0x_prefix(&#39;&#39;.join(
            remove_0x_prefix(hex_encode_abi_type(abi_type, value))
            for abi_type, value
            in zip(abi_types, normalized_values)
        ))
        return self.keccak(hexstr=hex_string)

    @staticmethod
    @apply_to_return_value(HexBytes)
    def keccak(primitive=None, text=None, hexstr=None):
        if isinstance(primitive, (bytes, int, type(None))):
            input_bytes = to_bytes(primitive, hexstr=hexstr, text=text)
            return tron_keccak(input_bytes)

        raise TypeError(
            &#34;You called keccak with first arg %r and keywords %r. You must call it with one of &#34;
            &#34;these approaches: keccak(text=&#39;txt&#39;), keccak(hexstr=&#39;0x747874&#39;), &#34;
            &#34;keccak(b&#39;\\x74\\x78\\x74&#39;), or keccak(0x747874).&#34; % (
                primitive,
                {&#39;text&#39;: text, &#39;hexstr&#39;: hexstr}
            )
        )

    def is_connected(self):
        &#34;&#34;&#34;List of available providers&#34;&#34;&#34;
        return self.manager.is_connected()</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="tronpytool.main.Tron.create_account"><code class="name flex">
<span>def <span class="ident">create_account</span></span>(<span>) ‑> <a title="tronpytool.common.account.PrivateKey" href="common/account.html#tronpytool.common.account.PrivateKey">PrivateKey</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create account</p>
<p>Warning: Please control risks when using this API.
To ensure environmental security, please do not invoke APIs
provided by other or invoke this very API on a public network.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_account() -&gt; PrivateKey:
    &#34;&#34;&#34;Create account

    Warning: Please control risks when using this API.
    To ensure environmental security, please do not invoke APIs
    provided by other or invoke this very API on a public network.

    &#34;&#34;&#34;
    return Account.create()</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.fromSun"><code class="name flex">
<span>def <span class="ident">fromSun</span></span>(<span>number: int) ‑> Union[int, decimal.Decimal]</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function that will convert a value in SUN to TRX.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code>int</code></dt>
<dd>Value in SUN to convert to TRX</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_sun(number: int) -&gt; Union[int, decimal.Decimal]:
    &#34;&#34;&#34;Helper function that will convert a value in SUN to TRX.

    Args:
        number (int): Value in SUN to convert to TRX

    &#34;&#34;&#34;
    if number == 0:
        return 0

    if number &lt; MIN_SUN or number &gt; MAX_SUN:
        raise ValueError(&#34;value must be between 1 and 2**256 - 1&#34;)

    unit_value = UNITS[&#39;sun&#39;]

    with localcontext() as ctx:
        ctx.prec = 999
        d_number = decimal.Decimal(value=number, context=ctx)
        result_value = d_number / unit_value

    return result_value</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.generate_address"><code class="name flex">
<span>def <span class="ident">generate_address</span></span>(<span>priv_key=None) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Address utilities Generate a random address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def generate_address(priv_key=None) -&gt; dict:
    &#34;&#34;&#34;Address utilities Generate a random address.&#34;&#34;&#34;
    if priv_key is None:
        priv_key = PrivateKeyFactory.random()
    return {
        &#34;base58check_address&#34;: priv_key.public_key.to_base58check_address(),
        &#34;hex_address&#34;: priv_key.public_key.to_hex_address(),
        &#34;private_key&#34;: priv_key.hex(),
        &#34;public_key&#34;: priv_key.public_key.hex(),
    }</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.isAddress"><code class="name flex">
<span>def <span class="ident">isAddress</span></span>(<span>value: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the given string in a supported value is an address
in any of the known formats.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong> :&ensp;<code>str</code></dt>
<dd>Address</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_address(value: str) -&gt; bool:
    &#34;&#34;&#34;Checks if the given string in a supported value is an address
    in any of the known formats.
    Args:
        value (str): Address
    &#34;&#34;&#34;
    if is_checksum_address(value):
        return True
    elif is_hex_address(value):
        return True

    return False</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.keccak"><code class="name flex">
<span>def <span class="ident">keccak</span></span>(<span>primitive=None, text=None, hexstr=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
@apply_to_return_value(HexBytes)
def keccak(primitive=None, text=None, hexstr=None):
    if isinstance(primitive, (bytes, int, type(None))):
        input_bytes = to_bytes(primitive, hexstr=hexstr, text=text)
        return tron_keccak(input_bytes)

    raise TypeError(
        &#34;You called keccak with first arg %r and keywords %r. You must call it with one of &#34;
        &#34;these approaches: keccak(text=&#39;txt&#39;), keccak(hexstr=&#39;0x747874&#39;), &#34;
        &#34;keccak(b&#39;\\x74\\x78\\x74&#39;), or keccak(0x747874).&#34; % (
            primitive,
            {&#39;text&#39;: text, &#39;hexstr&#39;: hexstr}
        )
    )</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.toBytes"><code class="name flex">
<span>def <span class="ident">toBytes</span></span>(<span>primitive=None, hexstr=None, text=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bytes(primitive=None, hexstr=None, text=None):
    assert_one_val(primitive, hexstr=hexstr, text=text)

    if is_boolean(primitive):
        return b&#39;\x01&#39; if primitive else b&#39;\x00&#39;
    elif isinstance(primitive, bytes):
        return primitive
    elif is_integer(primitive):
        return to_bytes(hexstr=to_hex(primitive))
    elif hexstr is not None:
        if len(hexstr) % 2:
            hexstr = &#39;0x0&#39; + remove_0x_prefix(hexstr)
        return decode_hex(hexstr)
    elif text is not None:
        return text.encode(&#39;utf-8&#39;)
    raise TypeError(&#34;expected an int in first arg, or keyword of hexstr or text&#34;)</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.toHex"><code class="name flex">
<span>def <span class="ident">toHex</span></span>(<span>primitive: Union[bytes, int, bool] = None, hexstr: <function NewType.<locals>.new_type at 0x7ff648077310> = None, text: str = None) ‑> <function NewType.<locals>.new_type at 0x7ff648077310></span>
</code></dt>
<dd>
<div class="desc"><p>Auto converts any supported value into its hex representation.
Trims leading zeros, as defined in:
<a href="https://github.com/ethereum/wiki/wiki/JSON-RPC#hex-value-encoding">https://github.com/ethereum/wiki/wiki/JSON-RPC#hex-value-encoding</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@validate_conversion_arguments
def to_hex(
        primitive: Primitives = None, hexstr: HexStr = None, text: str = None
) -&gt; HexStr:
    &#34;&#34;&#34;
    Auto converts any supported value into its hex representation.
    Trims leading zeros, as defined in:
    https://github.com/ethereum/wiki/wiki/JSON-RPC#hex-value-encoding
    &#34;&#34;&#34;
    if hexstr is not None:
        return HexStr(add_0x_prefix(hexstr.lower()))

    if text is not None:
        return HexStr(encode_hex(text.encode(&#34;utf-8&#34;)))

    if is_boolean(primitive):
        return HexStr(&#34;0x1&#34;) if primitive else HexStr(&#34;0x0&#34;)

    if isinstance(primitive, (bytes, bytearray)):
        return HexStr(encode_hex(primitive))
    elif is_string(primitive):
        raise TypeError(
            &#34;Unsupported type: The primitive argument must be one of: bytes,&#34;
            &#34;bytearray, int or bool and not str&#34;
        )

    if is_integer(primitive):
        return HexStr(hex(primitive))

    raise TypeError(
        &#34;Unsupported type: &#39;{0}&#39;.  Must be one of: bool, str, bytes, bytearray&#34;
        &#34;or int.&#34;.format(repr(type(primitive)))
    )</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.toInt"><code class="name flex">
<span>def <span class="ident">toInt</span></span>(<span>value=None, hexstr=None, text=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts value to it's integer representation.</p>
<p>Values are converted this way:</p>
<ul>
<li>value:</li>
<li>bytes: big-endian integer</li>
<li>bool: True =&gt; 1, False =&gt; 0</li>
<li>hexstr: interpret hex as integer</li>
<li>text: interpret as string of digits, like '12' =&gt; 12</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_int(value=None, hexstr=None, text=None):
    &#34;&#34;&#34;Converts value to it&#39;s integer representation.

    Values are converted this way:

     * value:
       * bytes: big-endian integer
       * bool: True =&gt; 1, False =&gt; 0
     * hexstr: interpret hex as integer
     * text: interpret as string of digits, like &#39;12&#39; =&gt; 12
    &#34;&#34;&#34;
    assert_one_val(value, hexstr=hexstr, text=text)

    if hexstr is not None:
        return int(hexstr, 16)
    elif text is not None:
        return int(text)
    elif isinstance(value, bytes):
        return big_endian_to_int(value)
    elif isinstance(value, str):
        raise TypeError(&#34;Pass in strings with keyword hexstr or text&#34;)
    else:
        return int(value)</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.toJSON"><code class="name flex">
<span>def <span class="ident">toJSON</span></span>(<span>obj: object) ‑> object</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a complex object (like a transaction object) to a JSON string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(obj: object) -&gt; object:
    &#34;&#34;&#34;Convert a complex object (like a transaction object) to a JSON string&#34;&#34;&#34;
    return FriendlyJsonSerialize().json_encode(obj, cls=TronJsonEncoder)</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.toSun"><code class="name flex">
<span>def <span class="ident">toSun</span></span>(<span>number: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function that will convert a value in TRX to SUN.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>number</code></strong> :&ensp;<code>int</code></dt>
<dd>Value in TRX to convert to SUN</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_sun(number: int) -&gt; int:
    &#34;&#34;&#34;Helper function that will convert a value in TRX to SUN.

    Args:
        number (int): Value in TRX to convert to SUN

    &#34;&#34;&#34;
    if is_integer(number) or is_string(number):
        d_number = decimal.Decimal(value=number)
    elif isinstance(number, float):
        d_number = decimal.Decimal(value=str(number))
    elif isinstance(number, decimal.Decimal):
        d_number = number
    else:
        raise TypeError(&#34;Unsupported type.  Must be one of integer, float, or string&#34;)

    s_number = str(number)
    unit_value = UNITS[&#39;sun&#39;]

    if d_number == 0:
        return 0

    if d_number &lt; 1 and &#39;.&#39; in s_number:
        with localcontext() as ctx:
            multiplier = len(s_number) - s_number.index(&#39;.&#39;) - 1
            ctx.prec = multiplier
            d_number = decimal.Decimal(value=number, context=ctx) * 10 ** multiplier
        unit_value /= 10 ** multiplier

    with localcontext() as ctx:
        ctx.prec = 999
        result_value = decimal.Decimal(value=d_number, context=ctx) * unit_value

    if result_value &lt; MIN_SUN or result_value &gt; MAX_SUN:
        raise ValueError(&#34;Resulting wei value must be between 1 and 2**256 - 1&#34;)

    return int(result_value)</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.toText"><code class="name flex">
<span>def <span class="ident">toText</span></span>(<span>primitive=None, hexstr=None, text=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_text(primitive=None, hexstr=None, text=None):
    assert_one_val(primitive, hexstr=hexstr, text=text)

    if hexstr is not None:
        return to_bytes(hexstr=hexstr).decode(&#39;utf-8&#39;)
    elif text is not None:
        return text
    elif isinstance(primitive, str):
        return to_text(hexstr=primitive)
    elif isinstance(primitive, bytes):
        return primitive.decode(&#39;utf-8&#39;)
    elif is_integer(primitive):
        byte_encoding = int_to_big_endian(primitive)
        return to_text(byte_encoding)
    raise TypeError(&#34;Expected an int, bytes or hexstr.&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tronpytool.main.Tron.address"><code class="name">var <span class="ident">address</span> : <a title="tronpytool.common.account.Address" href="common/account.html#tronpytool.common.account.Address">Address</a></code></dt>
<dd>
<div class="desc"><p>Helper object that allows you to convert
between hex/base58 and private key representations of a TRON address.</p>
<h2 id="note">Note</h2>
<p>If you wish to convert generic data to hexadecimal strings,
please use the function tron.to_hex.
return a static class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def address(self) -&gt; Address:
    &#34;&#34;&#34;Helper object that allows you to convert
    between hex/base58 and private key representations of a TRON address.

    Note:
        If you wish to convert generic data to hexadecimal strings,
        please use the function tron.to_hex.
        return a static class
    &#34;&#34;&#34;
    return Address()</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.default_address"><code class="name">var <span class="ident">default_address</span> : eth_account.datastructures.AttributeDict</code></dt>
<dd>
<div class="desc"><p>Get a TRON Address</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default_address(self) -&gt; AttributeDict:
    &#34;&#34;&#34;Get a TRON Address&#34;&#34;&#34;
    return self._default_address</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.default_block"><code class="name">var <span class="ident">default_block</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def default_block(self):
    return self._default_block</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.private_key"><code class="name">var <span class="ident">private_key</span> : str</code></dt>
<dd>
<div class="desc"><p>Get a private key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def private_key(self) -&gt; str:
    &#34;&#34;&#34;Get a private key&#34;&#34;&#34;
    return self._private_key</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.providers"><code class="name">var <span class="ident">providers</span></code></dt>
<dd>
<div class="desc"><p>List providers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def providers(self):
    &#34;&#34;&#34;List providers&#34;&#34;&#34;
    return self.manager.providers</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tronpytool.main.Tron.getKey"><code class="name flex">
<span>def <span class="ident">getKey</span></span>(<span>self) ‑> <a title="tronpytool.common.account.PrivateKey" href="common/account.html#tronpytool.common.account.PrivateKey">PrivateKey</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getKey(self) -&gt; &#34;PrivateKey&#34;:
    return self.private_key_class</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.get_address_from_passphrase"><code class="name flex">
<span>def <span class="ident">get_address_from_passphrase</span></span>(<span>self, passphrase: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get an address from a passphrase, compatiable with <code>wallet/createaddress</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_address_from_passphrase(self, passphrase: str) -&gt; dict:
    &#34;&#34;&#34;Get an address from a passphrase, compatiable with `wallet/createaddress`.&#34;&#34;&#34;
    priv_key = PrivateKeyFactory.from_passphrase(passphrase.encode())
    return self.generate_address(priv_key)</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.get_event_result"><code class="name flex">
<span>def <span class="ident">get_event_result</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Will return all events matching the filters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>any</code></dt>
<dd>List parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_event_result(self, **kwargs):
    &#34;&#34;&#34;Will return all events matching the filters.

    Args:
        kwargs (any): List parameters
    &#34;&#34;&#34;

    # Check the most necessary parameters
    since_timestamp = kwargs.setdefault(&#39;since_timestamp&#39;, 0)
    event_name = kwargs.setdefault(&#39;event_name&#39;, &#39;Notify&#39;)
    block_number = kwargs.setdefault(&#39;block_number&#39;, &#39;&#39;)
    size = kwargs.setdefault(&#39;size&#39;, 20)
    page = kwargs.setdefault(&#39;page&#39;, 1)
    only_confirmed = kwargs.setdefault(&#39;only_confirmed&#39;, None)
    only_unconfirmed = kwargs.setdefault(&#39;only_unconfirmed&#39;, None)
    previous_last = kwargs.setdefault(&#39;previous_last_event_fingerprint&#39;, None)
    contract_address = kwargs.setdefault(&#39;contract_address&#39;, self.default_address.hex)
    sort = kwargs.setdefault(&#39;sort&#39;, None)
    from_timestamp = kwargs.setdefault(&#39;from_timestamp&#39;, None)

    if not self.isAddress(contract_address):
        raise InvalidTronError(&#39;Invalid contract address provided&#39;)

    if event_name and not contract_address:
        raise TronError(&#39;Usage of event name filtering requires a contract address&#39;)

    if block_number and event_name is None:
        raise TronError(&#39;Usage of block number filtering requires an event name&#39;)

    if not is_integer(page):
        raise ValueError(&#39;Invalid size provided&#39;)

    if not is_integer(since_timestamp):
        raise ValueError(&#39;Invalid sinceTimestamp provided&#39;)

    # If the size exceeds 200, displays an error
    if size &gt; 200:
        raise ValueError(&#39;Defaulting to maximum accepted size: 200&#39;)

    # We collect all parameters in one array
    route_params = []
    if contract_address:
        route_params.append(contract_address)
    if event_name:
        route_params.append(event_name)
    if block_number:
        route_params.append(block_number)

    route = &#39;/&#39;.join(route_params)

    qs = {
        &#39;since&#39;: since_timestamp,
        &#39;page&#39;: page,
        &#39;size&#39;: size
    }

    if only_confirmed is not None:
        qs.update({&#39;onlyConfirmed&#39;: only_confirmed})

    if only_unconfirmed is not None and not only_confirmed:
        qs.update({&#39;onlyUnconfirmed&#39;: only_unconfirmed})

    if previous_last is not None:
        qs.update({&#39;previousLastEventFingerprint&#39;: previous_last})

    if from_timestamp is not None:
        qs.update({&#39;fromTimestamp&#39;: from_timestamp})

    if sort is not None:
        qs.update({&#39;sort&#39;: sort})

    return self.manager.request(&#34;/event/contract/{0}?{1}&#34;
                                .format(route, urlencode(qs)), method=&#39;get&#39;)</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.get_event_transaction_id"><code class="name flex">
<span>def <span class="ident">get_event_transaction_id</span></span>(<span>self, tx_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Will return all events within a transactionID.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tx_id</code></strong> :&ensp;<code>str</code></dt>
<dd>TransactionID to query for events.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_event_transaction_id(self, tx_id):
    &#34;&#34;&#34;Will return all events within a transactionID.

    Args:
        tx_id (str): TransactionID to query for events.
    &#34;&#34;&#34;
    response = self.manager.request(&#39;/event/transaction/&#39; + tx_id, method=&#39;get&#39;)
    return response</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.is_connected"><code class="name flex">
<span>def <span class="ident">is_connected</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>List of available providers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_connected(self):
    &#34;&#34;&#34;List of available providers&#34;&#34;&#34;
    return self.manager.is_connected()</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.setNetwork"><code class="name flex">
<span>def <span class="ident">setNetwork</span></span>(<span>self, networkname='nile')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setNetwork(self, networkname=&#34;nile&#34;):
    group = constants.conf_for_name(networkname)
    self.manager = TronManager(self, constants.to_providers_set(group))
    return self</code></pre>
</details>
</dd>
<dt id="tronpytool.main.Tron.solidity_sha3"><code class="name flex">
<span>def <span class="ident">solidity_sha3</span></span>(<span>self, abi_types, values)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes keccak256 exactly as Solidity does.
Takes list of abi_types as inputs &ndash; <code>[uint24, int8[], bool]</code>
and list of corresponding values
&ndash; <code>[20, [-1, 5, 0], True]</code></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>abi_types</code></strong> :&ensp;<code>any</code></dt>
<dd>types abi</dd>
<dt><strong><code>values</code></strong> :&ensp;<code>any</code></dt>
<dd>values</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="python-repl">&gt;&gt;&gt; tron = Tron()
&gt;&gt;&gt; sol = tron.solidity_sha3(['uint8[]'], [[1, 2, 3, 4, 5]])
&gt;&gt;&gt; assert sol.hex() == '0x5917e5a395fb9b454434de59651d36822a9e29c5ec57474df3e67937b969460c'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def solidity_sha3(self, abi_types, values):
    &#34;&#34;&#34;
        Executes keccak256 exactly as Solidity does.
        Takes list of abi_types as inputs -- `[uint24, int8[], bool]`
        and list of corresponding values  -- `[20, [-1, 5, 0], True]`

        Args:
            abi_types (any): types abi
            values (any): values

        Examples:
            &gt;&gt;&gt; tron = Tron()
            &gt;&gt;&gt; sol = tron.solidity_sha3([&#39;uint8[]&#39;], [[1, 2, 3, 4, 5]])
            &gt;&gt;&gt; assert sol.hex() == &#39;0x5917e5a395fb9b454434de59651d36822a9e29c5ec57474df3e67937b969460c&#39;

    &#34;&#34;&#34;
    if len(abi_types) != len(values):
        raise ValueError(
            &#34;Length mismatch between provided abi types and values.  Got &#34;
            &#34;{0} types and {1} values.&#34;.format(len(abi_types), len(values))
        )

    normalized_values = map_abi_data([abi_resolver()], abi_types, values)

    hex_string = add_0x_prefix(&#39;&#39;.join(
        remove_0x_prefix(hex_encode_abi_type(abi_type, value))
        for abi_type, value
        in zip(abi_types, normalized_values)
    ))
    return self.keccak(hexstr=hex_string)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#tronpytoolmain">tronpytool.main</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tronpytool" href="index.html">tronpytool</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tronpytool.main.Tron" href="#tronpytool.main.Tron">Tron</a></code></h4>
<ul class="">
<li><code><a title="tronpytool.main.Tron.address" href="#tronpytool.main.Tron.address">address</a></code></li>
<li><code><a title="tronpytool.main.Tron.create_account" href="#tronpytool.main.Tron.create_account">create_account</a></code></li>
<li><code><a title="tronpytool.main.Tron.default_address" href="#tronpytool.main.Tron.default_address">default_address</a></code></li>
<li><code><a title="tronpytool.main.Tron.default_block" href="#tronpytool.main.Tron.default_block">default_block</a></code></li>
<li><code><a title="tronpytool.main.Tron.fromSun" href="#tronpytool.main.Tron.fromSun">fromSun</a></code></li>
<li><code><a title="tronpytool.main.Tron.generate_address" href="#tronpytool.main.Tron.generate_address">generate_address</a></code></li>
<li><code><a title="tronpytool.main.Tron.getKey" href="#tronpytool.main.Tron.getKey">getKey</a></code></li>
<li><code><a title="tronpytool.main.Tron.get_address_from_passphrase" href="#tronpytool.main.Tron.get_address_from_passphrase">get_address_from_passphrase</a></code></li>
<li><code><a title="tronpytool.main.Tron.get_event_result" href="#tronpytool.main.Tron.get_event_result">get_event_result</a></code></li>
<li><code><a title="tronpytool.main.Tron.get_event_transaction_id" href="#tronpytool.main.Tron.get_event_transaction_id">get_event_transaction_id</a></code></li>
<li><code><a title="tronpytool.main.Tron.isAddress" href="#tronpytool.main.Tron.isAddress">isAddress</a></code></li>
<li><code><a title="tronpytool.main.Tron.is_connected" href="#tronpytool.main.Tron.is_connected">is_connected</a></code></li>
<li><code><a title="tronpytool.main.Tron.keccak" href="#tronpytool.main.Tron.keccak">keccak</a></code></li>
<li><code><a title="tronpytool.main.Tron.private_key" href="#tronpytool.main.Tron.private_key">private_key</a></code></li>
<li><code><a title="tronpytool.main.Tron.providers" href="#tronpytool.main.Tron.providers">providers</a></code></li>
<li><code><a title="tronpytool.main.Tron.setNetwork" href="#tronpytool.main.Tron.setNetwork">setNetwork</a></code></li>
<li><code><a title="tronpytool.main.Tron.solidity_sha3" href="#tronpytool.main.Tron.solidity_sha3">solidity_sha3</a></code></li>
<li><code><a title="tronpytool.main.Tron.toBytes" href="#tronpytool.main.Tron.toBytes">toBytes</a></code></li>
<li><code><a title="tronpytool.main.Tron.toHex" href="#tronpytool.main.Tron.toHex">toHex</a></code></li>
<li><code><a title="tronpytool.main.Tron.toInt" href="#tronpytool.main.Tron.toInt">toInt</a></code></li>
<li><code><a title="tronpytool.main.Tron.toJSON" href="#tronpytool.main.Tron.toJSON">toJSON</a></code></li>
<li><code><a title="tronpytool.main.Tron.toSun" href="#tronpytool.main.Tron.toSun">toSun</a></code></li>
<li><code><a title="tronpytool.main.Tron.toText" href="#tronpytool.main.Tron.toText">toText</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>