<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>tronpytool.compile.basecore API documentation</title>
<meta name="description" content="Base wrapper class for accessing ethereum smart contracts." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tronpytool.compile.basecore</code></h1>
</header>
<section id="section-intro">
<p>Base wrapper class for accessing ethereum smart contracts.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
&#34;&#34;&#34;Base wrapper class for accessing ethereum smart contracts.&#34;&#34;&#34;

from typing import Any, Union, Tuple

from tronpytool import Tron
from tronpytool.common.abi import method_result_handler, decode_single
from tronpytool.common.key import to_hex_address, keccak256, is_address
from tronpytool.common.normalizers import to_checksum_address
from tronpytool.contract import Contract
from tronpytool.exceptions import DoubleSpending
from tronpytool.transactionbuilder import TransactionBuilder


# from trx import is_list, is_object

class Validator:
    &#34;&#34;&#34;Base class for validating inputs to methods.&#34;&#34;&#34;

    def __init__(
            self,
            web3_or_provider: Tron,
            contract_address: str,
    ):
        &#34;&#34;&#34;Initialize the instance.&#34;&#34;&#34;

    def assert_valid(
            self, method_name: str, parameter_name: str, argument_value: Any
    ):
        &#34;&#34;&#34;Raise an exception if method input is not valid.

        :param method_name: Name of the method whose input is to be validated.
        :param parameter_name: Name of the parameter whose input is to be
            validated.
        :param argument_value: Value of argument to parameter to be validated.
        &#34;&#34;&#34;


class ContractMethod:
    debug = True

    def __init__(self, abi: dict, contract: Contract, owner_address: str, contract_address: str,
                 validator: Validator = None):

        self._abi = abi
        self.validator = validator
        self._owner_address = owner_address
        self._client = contract.tron.trx
        self._tron: Tron = contract.tron
        self.transaction_builder = contract.tron.transaction_builder
        self.inputs = abi.get(&#34;inputs&#34;, [])
        self.outputs = abi.get(&#34;outputs&#34;, [])
        self.method_name = abi.get(&#34;name&#34;, &#34;&#34;)
        self.element_type = abi.get(&#34;type&#34;, &#34;&#34;)
        self.call_value = 0
        self.call_token_value = 0
        self.call_token_id = 0
        self.contract_address = contract_address

    def __str__(self):
        return self.function_type

    def setDebug(self, b: bool) -&gt; None:
        self.debug = b

    @staticmethod
    def validate_and_checksum_address(address: str):
        &#34;&#34;&#34;Validate the given address, and return it&#39;s checksum address.&#34;&#34;&#34;
        if not is_address(address):
            raise TypeError(&#34;Invalid address provided: {}&#34;.format(address))
        return to_checksum_address(address)

    def normalize_tx_params(self, tx_params) -&gt; dict:
        &#34;&#34;&#34;Normalize and return the given transaction parameters.&#34;&#34;&#34;
        params = dict()
        return params

    def with_owner(self, addr: str) -&gt; &#34;ContractMethod&#34;:
        &#34;&#34;&#34;Set the calling owner address.

        Can also be changed through :meth:`TransactionBuilder.with_owner() &lt;tronpy.tron.TransactionBuilder.with_owner&gt;`.
        &#34;&#34;&#34;
        self._owner_address = addr
        return self

    def with_transfer(self, amount: int) -&gt; &#34;ContractMethod&#34;:
        &#34;&#34;&#34;Call a contract function with TRX transfer. ``amount`` in `SUN`.&#34;&#34;&#34;
        self.call_value = amount
        return self

    def with_asset_transfer(self, amount: int, token_id: int) -&gt; &#34;ContractMethod&#34;:
        &#34;&#34;&#34;Call a contract function with TRC10 token transfer.&#34;&#34;&#34;
        self.call_token_value = amount
        self.call_token_id = token_id
        return self

    def call(self, *args, **kwargs) -&gt; &#34;TransactionBuilder&#34;:
        &#34;&#34;&#34;Call the contract method.&#34;&#34;&#34;
        return self.__call__(*args, **kwargs)

    def trackEventReceipt(self, trnId: str):
        event = self._tron.get_event_transaction_id(trnId)
        print(&#34;=======debug event returns on this Transaction ID {}&#34;.format(trnId))
        print(event)
        print(&#34;=======end event report ========&#34;)

    def handle_url_response(self, r: dict) -&gt; any:
        ok, key, message = method_result_handler(r)
        if ok:
            print(&#34;transaction ID: {}&#34;.format(message))
            if len(key) &gt; 0:
                display = self.parse_output(key)
                self.debug_raw_io(key)
                return display
            else:
                return &#34;&#34;
        else:
            raise KeyError(&#39;Request returns Error - {} msg:{} txt:{}&#39;.format(key, message, self.parse_output(message)))

    def parse_output(self, raw: any) -&gt; any:
        if type(raw) is bytes:
            &#34;&#34;&#34;Parse contract result as result.&#34;&#34;&#34;

            parsed_result = decode_single(self.output_type, bytes.fromhex(raw))
            if len(self.outputs) == 1:
                return parsed_result[0]
            if len(self.outputs) == 0:
                return None
            return parsed_result

        elif type(raw) is str:
            &#34;&#34;&#34;Parse contract result as result.&#34;&#34;&#34;

            parsed_result = decode_single(self.output_type, bytes.fromhex(raw))
            if len(self.outputs) == 1:
                return parsed_result[0]
            if len(self.outputs) == 0:
                return None
            return parsed_result

        elif type(raw) is list:
            &#34;&#34;&#34;Parse contract result as result.&#34;&#34;&#34;

            parsed_result = []
            for k in raw:
                p = decode_single(self.output_type, bytes.fromhex(k))
                parsed_result.append(p)
            if len(self.outputs) &gt;= 1:
                self.debug_io(parsed_result)
                return parsed_result[0]
            if len(self.outputs) == 0:
                print(&#34;no returns.. &#34;)
                return None

            return None

        else:

            print(&#34;there is not type were found.. &#34;)
            print(self.output_type)
            return raw

    def debug_input_io(self, data_type, args):
        if self.debug:
            print(&#34;=======raw input ======== type-label: {}, type: {}&#34;.format(data_type, type(data_type)))
            print(args)
            print(&#34;=======end raw input ========&#34;)

    def debug_params(self, data):
        if self.debug:
            print(&#34;=======param input ========&#34;)
            print(data)
            print(&#34;=======end param input========&#34;)

    def debug_raw_io(self, data):
        if self.debug:
            print(&#34;=======raw output ========&#34;)
            print(data)
            print(&#34;=======end raw output ========&#34;)

    def debug_io(self, data):
        if self.debug:
            print(&#34;====testing output type&#34;)
            print(&#34;output type {}&#34;.format(type(data[0])))
            print(&#34;output type detail: {}&#34;.format(self.output_type))
            print(&#34;==end&#34;)

    def __call__(self, *args, **kwargs) -&gt; any:
        &#34;&#34;&#34;Call the contract method.&#34;&#34;&#34;
        parameters = []

        if args and kwargs:
            raise ValueError(&#34;do not mix positional arguments and keyword arguments&#34;)

        if len(self.inputs) == 0:
            if args or kwargs:
                raise TypeError(&#34;{} expected {} arguments&#34;.format(self.name, len(self.inputs)))
        elif args:
            if len(args) != len(self.inputs):
                raise TypeError(&#34;wrong number of arguments, require {} got {}&#34;.format(len(self.inputs), len(args)))
            self.debug_input_io(self.input_type, args)
            argpos = 0
            # vals = encode_single(self.input_type, args).hex()
            # self.debug_params(vals)
            for type_label in self.input_type_list:
                parameters.append(dict(
                    type=type_label,
                    value=args[argpos],
                ))
                argpos = argpos + 1

        elif kwargs:
            if len(kwargs) != len(self.inputs):
                raise TypeError(&#34;wrong number of arguments, require {} got {}&#34;.format(len(self.inputs), len(args)))
            args = []
            for arg in self.inputs:
                try:
                    args.append(kwargs[arg[&#34;name&#34;]])
                except KeyError:
                    raise TypeError(&#34;missing argument &#39;{}&#39;&#34;.format(arg[&#34;name&#34;]))
            # parameter = encode_single(self.input_type, args).hex()
        else:
            raise TypeError(&#34;wrong number of arguments, require {}&#34;.format(len(self.inputs)))

        paramdict = dict(
            contract_address=self.contract_address,
            function_selector=self.function_signature,
            issuer_address=self._owner_address,
            fee_limit=30000,
            call_value=0
        )

        if len(parameters) &gt; 0:
            paramdict[&#39;parameters&#39;] = parameters

        if self._abi.get(&#34;stateMutability&#34;, None).lower() in [&#34;view&#34;, &#34;pure&#34;]:
            # const call, contract ret
            ret = self.transaction_builder.trigger_smart_contract(paramdict)
            return self.handle_url_response(ret)
        else:
            ret = self.transaction_builder.trigger_smart_contract(paramdict)
            return self.handle_url_response(ret)

    @property
    def name(self) -&gt; str:
        return self._abi[&#34;name&#34;]

    @property
    def input_type(self) -&gt; str:
        return &#34;(&#34; + (&#34;,&#34;.join(self.__format_json_abi_type_entry(arg) for arg in self.inputs)) + &#34;)&#34;

    @property
    def input_type_list(self) -&gt; list:
        return self.input_type[1:len(self.input_type) - 1].split(&#34;,&#34;)

    @property
    def output_type(self) -&gt; str:
        return &#34;({})&#34;.format(&#34;,&#34;.join(self.__format_json_abi_type_entry(arg) for arg in self.outputs))

    def __format_json_abi_type_entry(self, entry) -&gt; str:
        if entry[&#39;type&#39;].startswith(&#39;tuple&#39;):
            surfix = entry[&#39;type&#39;][5:]
            if &#39;components&#39; not in entry:
                raise ValueError(&#34;ABIEncoderV2 used, ABI should be set by hand&#34;)
            return &#34;({}){}&#34;.format(
                &#34;,&#34;.join(self.__format_json_abi_type_entry(arg) for arg in entry[&#39;components&#39;]), surfix
            )
        else:
            return entry[&#39;type&#39;]

    @property
    def function_signature(self) -&gt; str:
        return self.name + self.input_type

    @property
    def function_signature_hash(self) -&gt; str:
        return keccak256(self.function_signature.encode())[:4].hex()

    @property
    def function_type(self) -&gt; str:
        types = &#34;, &#34;.join(arg[&#34;type&#34;] + &#34; &#34; + arg.get(&#34;name&#34;, &#34;&#34;) for arg in self.inputs)
        ret = &#34;function {}({})&#34;.format(self.name, types)
        if self._abi.get(&#34;stateMutability&#34;, None).lower() == &#34;view&#34;:
            ret += &#34; view&#34;
        elif self._abi.get(&#34;stateMutability&#34;, None).lower() == &#34;pure&#34;:
            ret += &#34; pure&#34;
        if self.outputs:
            ret += &#34; returns ({})&#34;.format(&#34;, &#34;.join(arg[&#34;type&#34;] + &#34; &#34; + arg.get(&#34;name&#34;, &#34;&#34;) for arg in self.outputs))
        return ret

    def as_shielded_trc20(self, contractaddr: str) -&gt; &#34;ShieldedTRC20&#34;:
        return ShieldedTRC20(self._contract, self._tron, contractaddr)


class ShieldedTRC20(object):
    &#34;&#34;&#34;Shielded TRC20 Wrapper.&#34;&#34;&#34;

    def __init__(self, contract: Contract, client: Tron, address: str):
        self.shielded = address
        &#34;&#34;&#34;The shielded TRC20 contract.&#34;&#34;&#34;
        self._client = client
        self._trx_module = client.trx
        self._contract = contract
        # lazy properties
        self._trc20 = None
        self._scale_factor = None

    @property
    def trc20(self) -&gt; Contract:
        &#34;&#34;&#34;The corresponding TRC20 contract.&#34;&#34;&#34;
        if self._trc20 is None:
            trc20_address = &#34;41&#34; + str(self.shielded)._bytecode[-52:-32].hex()
            self._trc20 = self._trx_module.get_contract(trc20_address)
        return self._trc20

    @property
    def scale_factor(self) -&gt; int:
        &#34;&#34;&#34;Scaling factor of the shielded contract.&#34;&#34;&#34;
        if self._scale_factor is None:
            self._scale_factor = self._contract.functions.scalingFactor()
        return self._scale_factor

    def get_rcm(self) -&gt; str:
        return self._client.manager.request(&#34;wallet/getrcm&#34;)[&#34;value&#34;]

    def mint(self, taddr: str, zaddr: str, amount: int, memo: str = &#34;&#34;) -&gt; &#34;TransactionBuilder&#34;:
        &#34;&#34;&#34;Mint, transfer from T-address to z-address.&#34;&#34;&#34;
        rcm = self.get_rcm()
        payload = {
            &#34;from_amount&#34;: str(amount),
            &#34;shielded_receives&#34;: {
                &#34;note&#34;: {
                    &#34;value&#34;: amount // self.scale_factor,
                    &#34;payment_address&#34;: zaddr,
                    &#34;rcm&#34;: rcm,
                    &#34;memo&#34;: memo.encode().hex(),
                }
            },
            &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self._contract.contract_address),
        }

        ret = self._client.manager.request(&#34;wallet/createshieldedcontractparameters&#34;, payload)
        self._client._handle_api_error(ret)
        parameter = ret[&#34;trigger_contract_input&#34;]
        function_signature = self._contract.functions.mint.function_signature_hash
        return self._trx_module._build_transaction(
            &#34;TriggerSmartContract&#34;,
            {
                &#34;owner_address&#34;: to_hex_address(taddr),
                &#34;contract_address&#34;: to_hex_address(self._contract.contract_address),
                &#34;data&#34;: function_signature + parameter,
            },
            method=self._contract.functions.mint,
        )

    def transfer(
            self, zkey: dict, notes: Union[list, dict], *to: Union[Tuple[str, int], Tuple[str, int, str]],
    ) -&gt; &#34;tronpy.tron.TransactionBuilder&#34;:
        &#34;&#34;&#34;Transfer from z-address to z-address.&#34;&#34;&#34;
        if isinstance(notes, (dict,)):
            notes = [notes]

        assert 1 &lt;= len(notes) &lt;= 2

        spends = []
        spend_amount = 0
        for note in notes:
            if note.get(&#34;is_spent&#34;, False):
                raise DoubleSpending
            alpha = self.get_rcm()
            root, path = self.get_path(note.get(&#34;position&#34;, 0))
            spends.append(
                {&#34;note&#34;: note[&#34;note&#34;], &#34;alpha&#34;: alpha, &#34;root&#34;: root, &#34;path&#34;: path, &#34;pos&#34;: note.get(&#34;position&#34;, 0)}
            )
            spend_amount += note[&#34;note&#34;][&#34;value&#34;]

        receives = []
        receive_amount = 0
        for recv in to:
            addr = recv[0]
            amount = recv[1]
            receive_amount += amount
            if len(recv) == 3:
                memo = recv[2]
            else:
                memo = &#34;&#34;

            rcm = self.get_rcm()

            receives.append(
                {&#34;note&#34;: {&#34;value&#34;: amount, &#34;payment_address&#34;: addr, &#34;rcm&#34;: rcm, &#34;memo&#34;: memo.encode().hex()}}
            )

        if spend_amount != receive_amount:
            raise ValueError(&#34;spend amount is not equal to receive amount&#34;)

        payload = {
            &#34;ask&#34;: zkey[&#34;ask&#34;],
            &#34;nsk&#34;: zkey[&#34;nsk&#34;],
            &#34;ovk&#34;: zkey[&#34;ovk&#34;],
            &#34;shielded_spends&#34;: spends,
            &#34;shielded_receives&#34;: receives,
            &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
        }
        ret = self._client.provider.make_request(&#34;wallet/createshieldedcontractparameters&#34;, payload)
        self._client._handle_api_error(ret)
        parameter = ret[&#34;trigger_contract_input&#34;]
        function_signature = self.shielded.functions.transfer.function_signature_hash
        return self._trx_module._build_transaction(
            &#34;TriggerSmartContract&#34;,
            {
                &#34;owner_address&#34;: &#34;0000000000000000000000000000000000000000&#34;,
                &#34;contract_address&#34;: to_hex_address(self.shielded.contract_address),
                &#34;data&#34;: function_signature + parameter,
            },
            method=self.shielded.functions.transfer,
        )

    def burn(
            self, zkey: dict, note: dict, *to: Union[Tuple[str, int], Tuple[str, int, str]]
    ) -&gt; &#34;tronpy.tron.TransactionBuilder&#34;:
        &#34;&#34;&#34;Burn, transfer from z-address to T-address.&#34;&#34;&#34;
        spends = []
        alpha = self.get_rcm()
        root, path = self.get_path(note.get(&#34;position&#34;, 0))
        if note.get(&#34;is_spent&#34;, False):
            raise DoubleSpending
        spends.append(
            {&#34;note&#34;: note[&#34;note&#34;], &#34;alpha&#34;: alpha, &#34;root&#34;: root, &#34;path&#34;: path, &#34;pos&#34;: note.get(&#34;position&#34;, 0)}
        )
        change_amount = 0
        receives = []
        to_addr = None
        to_amount = 0
        to_memo = &#39;&#39;
        if not to:
            raise ValueError(&#39;burn must have a output&#39;)
        for receive in to:
            addr = receive[0]
            amount = receive[1]
            if len(receive) == 3:
                memo = receive[2]
            else:
                memo = &#34;&#34;

            if addr.startswith(&#39;ztron1&#39;):
                change_amount += amount
                rcm = self.get_rcm()
                receives = [
                    {&#34;note&#34;: {&#34;value&#34;: amount, &#34;payment_address&#34;: addr, &#34;rcm&#34;: rcm, &#34;memo&#34;: memo.encode().hex()}}
                ]
            else:
                # assume T-address
                to_addr = addr
                to_amount = amount
                to_memo = memo

        if note[&#34;note&#34;][&#34;value&#34;] * self.scale_factor - change_amount * self.scale_factor != to_amount:
            raise ValueError(&#34;Balance amount is wrong&#34;)

        payload = {
            &#34;ask&#34;: zkey[&#34;ask&#34;],
            &#34;nsk&#34;: zkey[&#34;nsk&#34;],
            &#34;ovk&#34;: zkey[&#34;ovk&#34;],
            &#34;shielded_spends&#34;: spends,
            &#34;shielded_receives&#34;: receives,
            &#34;to_amount&#34;: str(to_amount),
            &#34;transparent_to_address&#34;: to_hex_address(to_addr),
            &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
        }

        ret = self._client.provider.make_request(&#34;wallet/createshieldedcontractparameters&#34;, payload)
        self._client._handle_api_error(ret)
        parameter = ret[&#34;trigger_contract_input&#34;]
        function_signature = self.shielded.functions.burn.function_signature_hash
        txn = self._trx_module._build_transaction(
            &#34;TriggerSmartContract&#34;,
            {
                &#34;owner_address&#34;: &#34;410000000000000000000000000000000000000000&#34;,
                &#34;contract_address&#34;: to_hex_address(self.shielded.contract_address),
                &#34;data&#34;: function_signature + parameter,
            },
            method=self.shielded.functions.burn,
        )
        if to_memo:
            txn = txn.memo(to_memo)
        return txn

    def _fix_notes(self, notes: list) -&gt; list:
        for note in notes:
            if &#34;position&#34; not in note:
                note[&#34;position&#34;] = 0
            if &#34;is_spent&#34; not in note:
                note[&#34;is_spent&#34;] = False
            # if &#34;memo&#34; in note[&#34;note&#34;]:
            #     note[&#34;note&#34;][&#34;memo&#34;] = bytes.fromhex(note[&#34;note&#34;][&#34;memo&#34;]).decode(&#34;utf8&#34;, &#39;ignore&#39;)
        return notes

    # use zkey pair from wallet/getnewshieldedaddress
    def scan_incoming_notes(self, zkey: dict, start_block_number: int, end_block_number: int = None) -&gt; list:
        &#34;&#34;&#34;Scan incoming notes using ivk, ak, nk.&#34;&#34;&#34;
        if end_block_number is None:
            end_block_number = start_block_number + 1000
        payload = {
            &#34;start_block_index&#34;: start_block_number,
            &#34;end_block_index&#34;: end_block_number,
            &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
            &#34;ivk&#34;: zkey[&#34;ivk&#34;],
            &#34;ak&#34;: zkey[&#34;ak&#34;],
            &#34;nk&#34;: zkey[&#34;nk&#34;],
        }
        ret = self._client.provider.make_request(&#34;wallet/scanshieldedtrc20notesbyivk&#34;, payload)
        self._client._handle_api_error(ret)
        return self._fix_notes(ret.get(&#34;noteTxs&#34;, []))

    def scan_outgoing_notes(
            self, zkey_or_ovk: Union[dict, str], start_block_number: int, end_block_number: int = None
    ) -&gt; list:
        &#34;&#34;&#34;Scan outgoing notes using ovk.&#34;&#34;&#34;
        if end_block_number is None:
            end_block_number = start_block_number + 1000

        ovk = zkey_or_ovk
        if isinstance(zkey_or_ovk, (dict,)):
            ovk = zkey_or_ovk[&#34;ovk&#34;]

        payload = {
            &#34;start_block_index&#34;: start_block_number,
            &#34;end_block_index&#34;: end_block_number,
            &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
            &#34;ovk&#34;: ovk,
        }
        ret = self._client.provider.make_request(&#34;wallet/scanshieldedtrc20notesbyovk&#34;, payload)
        self._client._handle_api_error(ret)
        return ret.get(&#34;noteTxs&#34;, [])

    # (root, path)
    def get_path(self, position: int = 0) -&gt; (str, str):
        root, path = self.shielded.functions.getPath(position)
        root = root.hex()
        path = &#34;&#34;.join(p.hex() for p in path)
        return (root, path)

    def is_note_spent(self, zkey: dict, note: dict) -&gt; bool:
        &#34;&#34;&#34;Is a note spent.&#34;&#34;&#34;
        payload = dict(note)
        payload[&#34;shielded_TRC20_contract_address&#34;] = to_hex_address(self.shielded.contract_address)
        if &#34;position&#34; not in note:
            payload[&#34;position&#34;] = 0
        payload[&#34;ak&#34;] = zkey[&#34;ak&#34;]
        payload[&#34;nk&#34;] = zkey[&#34;nk&#34;]

        ret = self._client.provider.make_request(&#34;wallet/isshieldedtrc20contractnotespent&#34;, payload)

        return ret.get(&#39;is_spent&#39;, None)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tronpytool.compile.basecore.ContractMethod"><code class="flex name class">
<span>class <span class="ident">ContractMethod</span></span>
<span>(</span><span>abi: dict, contract: <a title="tronpytool.contract.Contract" href="../contract.html#tronpytool.contract.Contract">Contract</a>, owner_address: str, contract_address: str, validator: <a title="tronpytool.compile.basecore.Validator" href="#tronpytool.compile.basecore.Validator">Validator</a> = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContractMethod:
    debug = True

    def __init__(self, abi: dict, contract: Contract, owner_address: str, contract_address: str,
                 validator: Validator = None):

        self._abi = abi
        self.validator = validator
        self._owner_address = owner_address
        self._client = contract.tron.trx
        self._tron: Tron = contract.tron
        self.transaction_builder = contract.tron.transaction_builder
        self.inputs = abi.get(&#34;inputs&#34;, [])
        self.outputs = abi.get(&#34;outputs&#34;, [])
        self.method_name = abi.get(&#34;name&#34;, &#34;&#34;)
        self.element_type = abi.get(&#34;type&#34;, &#34;&#34;)
        self.call_value = 0
        self.call_token_value = 0
        self.call_token_id = 0
        self.contract_address = contract_address

    def __str__(self):
        return self.function_type

    def setDebug(self, b: bool) -&gt; None:
        self.debug = b

    @staticmethod
    def validate_and_checksum_address(address: str):
        &#34;&#34;&#34;Validate the given address, and return it&#39;s checksum address.&#34;&#34;&#34;
        if not is_address(address):
            raise TypeError(&#34;Invalid address provided: {}&#34;.format(address))
        return to_checksum_address(address)

    def normalize_tx_params(self, tx_params) -&gt; dict:
        &#34;&#34;&#34;Normalize and return the given transaction parameters.&#34;&#34;&#34;
        params = dict()
        return params

    def with_owner(self, addr: str) -&gt; &#34;ContractMethod&#34;:
        &#34;&#34;&#34;Set the calling owner address.

        Can also be changed through :meth:`TransactionBuilder.with_owner() &lt;tronpy.tron.TransactionBuilder.with_owner&gt;`.
        &#34;&#34;&#34;
        self._owner_address = addr
        return self

    def with_transfer(self, amount: int) -&gt; &#34;ContractMethod&#34;:
        &#34;&#34;&#34;Call a contract function with TRX transfer. ``amount`` in `SUN`.&#34;&#34;&#34;
        self.call_value = amount
        return self

    def with_asset_transfer(self, amount: int, token_id: int) -&gt; &#34;ContractMethod&#34;:
        &#34;&#34;&#34;Call a contract function with TRC10 token transfer.&#34;&#34;&#34;
        self.call_token_value = amount
        self.call_token_id = token_id
        return self

    def call(self, *args, **kwargs) -&gt; &#34;TransactionBuilder&#34;:
        &#34;&#34;&#34;Call the contract method.&#34;&#34;&#34;
        return self.__call__(*args, **kwargs)

    def trackEventReceipt(self, trnId: str):
        event = self._tron.get_event_transaction_id(trnId)
        print(&#34;=======debug event returns on this Transaction ID {}&#34;.format(trnId))
        print(event)
        print(&#34;=======end event report ========&#34;)

    def handle_url_response(self, r: dict) -&gt; any:
        ok, key, message = method_result_handler(r)
        if ok:
            print(&#34;transaction ID: {}&#34;.format(message))
            if len(key) &gt; 0:
                display = self.parse_output(key)
                self.debug_raw_io(key)
                return display
            else:
                return &#34;&#34;
        else:
            raise KeyError(&#39;Request returns Error - {} msg:{} txt:{}&#39;.format(key, message, self.parse_output(message)))

    def parse_output(self, raw: any) -&gt; any:
        if type(raw) is bytes:
            &#34;&#34;&#34;Parse contract result as result.&#34;&#34;&#34;

            parsed_result = decode_single(self.output_type, bytes.fromhex(raw))
            if len(self.outputs) == 1:
                return parsed_result[0]
            if len(self.outputs) == 0:
                return None
            return parsed_result

        elif type(raw) is str:
            &#34;&#34;&#34;Parse contract result as result.&#34;&#34;&#34;

            parsed_result = decode_single(self.output_type, bytes.fromhex(raw))
            if len(self.outputs) == 1:
                return parsed_result[0]
            if len(self.outputs) == 0:
                return None
            return parsed_result

        elif type(raw) is list:
            &#34;&#34;&#34;Parse contract result as result.&#34;&#34;&#34;

            parsed_result = []
            for k in raw:
                p = decode_single(self.output_type, bytes.fromhex(k))
                parsed_result.append(p)
            if len(self.outputs) &gt;= 1:
                self.debug_io(parsed_result)
                return parsed_result[0]
            if len(self.outputs) == 0:
                print(&#34;no returns.. &#34;)
                return None

            return None

        else:

            print(&#34;there is not type were found.. &#34;)
            print(self.output_type)
            return raw

    def debug_input_io(self, data_type, args):
        if self.debug:
            print(&#34;=======raw input ======== type-label: {}, type: {}&#34;.format(data_type, type(data_type)))
            print(args)
            print(&#34;=======end raw input ========&#34;)

    def debug_params(self, data):
        if self.debug:
            print(&#34;=======param input ========&#34;)
            print(data)
            print(&#34;=======end param input========&#34;)

    def debug_raw_io(self, data):
        if self.debug:
            print(&#34;=======raw output ========&#34;)
            print(data)
            print(&#34;=======end raw output ========&#34;)

    def debug_io(self, data):
        if self.debug:
            print(&#34;====testing output type&#34;)
            print(&#34;output type {}&#34;.format(type(data[0])))
            print(&#34;output type detail: {}&#34;.format(self.output_type))
            print(&#34;==end&#34;)

    def __call__(self, *args, **kwargs) -&gt; any:
        &#34;&#34;&#34;Call the contract method.&#34;&#34;&#34;
        parameters = []

        if args and kwargs:
            raise ValueError(&#34;do not mix positional arguments and keyword arguments&#34;)

        if len(self.inputs) == 0:
            if args or kwargs:
                raise TypeError(&#34;{} expected {} arguments&#34;.format(self.name, len(self.inputs)))
        elif args:
            if len(args) != len(self.inputs):
                raise TypeError(&#34;wrong number of arguments, require {} got {}&#34;.format(len(self.inputs), len(args)))
            self.debug_input_io(self.input_type, args)
            argpos = 0
            # vals = encode_single(self.input_type, args).hex()
            # self.debug_params(vals)
            for type_label in self.input_type_list:
                parameters.append(dict(
                    type=type_label,
                    value=args[argpos],
                ))
                argpos = argpos + 1

        elif kwargs:
            if len(kwargs) != len(self.inputs):
                raise TypeError(&#34;wrong number of arguments, require {} got {}&#34;.format(len(self.inputs), len(args)))
            args = []
            for arg in self.inputs:
                try:
                    args.append(kwargs[arg[&#34;name&#34;]])
                except KeyError:
                    raise TypeError(&#34;missing argument &#39;{}&#39;&#34;.format(arg[&#34;name&#34;]))
            # parameter = encode_single(self.input_type, args).hex()
        else:
            raise TypeError(&#34;wrong number of arguments, require {}&#34;.format(len(self.inputs)))

        paramdict = dict(
            contract_address=self.contract_address,
            function_selector=self.function_signature,
            issuer_address=self._owner_address,
            fee_limit=30000,
            call_value=0
        )

        if len(parameters) &gt; 0:
            paramdict[&#39;parameters&#39;] = parameters

        if self._abi.get(&#34;stateMutability&#34;, None).lower() in [&#34;view&#34;, &#34;pure&#34;]:
            # const call, contract ret
            ret = self.transaction_builder.trigger_smart_contract(paramdict)
            return self.handle_url_response(ret)
        else:
            ret = self.transaction_builder.trigger_smart_contract(paramdict)
            return self.handle_url_response(ret)

    @property
    def name(self) -&gt; str:
        return self._abi[&#34;name&#34;]

    @property
    def input_type(self) -&gt; str:
        return &#34;(&#34; + (&#34;,&#34;.join(self.__format_json_abi_type_entry(arg) for arg in self.inputs)) + &#34;)&#34;

    @property
    def input_type_list(self) -&gt; list:
        return self.input_type[1:len(self.input_type) - 1].split(&#34;,&#34;)

    @property
    def output_type(self) -&gt; str:
        return &#34;({})&#34;.format(&#34;,&#34;.join(self.__format_json_abi_type_entry(arg) for arg in self.outputs))

    def __format_json_abi_type_entry(self, entry) -&gt; str:
        if entry[&#39;type&#39;].startswith(&#39;tuple&#39;):
            surfix = entry[&#39;type&#39;][5:]
            if &#39;components&#39; not in entry:
                raise ValueError(&#34;ABIEncoderV2 used, ABI should be set by hand&#34;)
            return &#34;({}){}&#34;.format(
                &#34;,&#34;.join(self.__format_json_abi_type_entry(arg) for arg in entry[&#39;components&#39;]), surfix
            )
        else:
            return entry[&#39;type&#39;]

    @property
    def function_signature(self) -&gt; str:
        return self.name + self.input_type

    @property
    def function_signature_hash(self) -&gt; str:
        return keccak256(self.function_signature.encode())[:4].hex()

    @property
    def function_type(self) -&gt; str:
        types = &#34;, &#34;.join(arg[&#34;type&#34;] + &#34; &#34; + arg.get(&#34;name&#34;, &#34;&#34;) for arg in self.inputs)
        ret = &#34;function {}({})&#34;.format(self.name, types)
        if self._abi.get(&#34;stateMutability&#34;, None).lower() == &#34;view&#34;:
            ret += &#34; view&#34;
        elif self._abi.get(&#34;stateMutability&#34;, None).lower() == &#34;pure&#34;:
            ret += &#34; pure&#34;
        if self.outputs:
            ret += &#34; returns ({})&#34;.format(&#34;, &#34;.join(arg[&#34;type&#34;] + &#34; &#34; + arg.get(&#34;name&#34;, &#34;&#34;) for arg in self.outputs))
        return ret

    def as_shielded_trc20(self, contractaddr: str) -&gt; &#34;ShieldedTRC20&#34;:
        return ShieldedTRC20(self._contract, self._tron, contractaddr)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tronpytool.compile.basecore.ContractMethod.debug"><code class="name">var <span class="ident">debug</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="tronpytool.compile.basecore.ContractMethod.validate_and_checksum_address"><code class="name flex">
<span>def <span class="ident">validate_and_checksum_address</span></span>(<span>address: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Validate the given address, and return it's checksum address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_and_checksum_address(address: str):
    &#34;&#34;&#34;Validate the given address, and return it&#39;s checksum address.&#34;&#34;&#34;
    if not is_address(address):
        raise TypeError(&#34;Invalid address provided: {}&#34;.format(address))
    return to_checksum_address(address)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="tronpytool.compile.basecore.ContractMethod.function_signature"><code class="name">var <span class="ident">function_signature</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def function_signature(self) -&gt; str:
    return self.name + self.input_type</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.function_signature_hash"><code class="name">var <span class="ident">function_signature_hash</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def function_signature_hash(self) -&gt; str:
    return keccak256(self.function_signature.encode())[:4].hex()</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.function_type"><code class="name">var <span class="ident">function_type</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def function_type(self) -&gt; str:
    types = &#34;, &#34;.join(arg[&#34;type&#34;] + &#34; &#34; + arg.get(&#34;name&#34;, &#34;&#34;) for arg in self.inputs)
    ret = &#34;function {}({})&#34;.format(self.name, types)
    if self._abi.get(&#34;stateMutability&#34;, None).lower() == &#34;view&#34;:
        ret += &#34; view&#34;
    elif self._abi.get(&#34;stateMutability&#34;, None).lower() == &#34;pure&#34;:
        ret += &#34; pure&#34;
    if self.outputs:
        ret += &#34; returns ({})&#34;.format(&#34;, &#34;.join(arg[&#34;type&#34;] + &#34; &#34; + arg.get(&#34;name&#34;, &#34;&#34;) for arg in self.outputs))
    return ret</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.input_type"><code class="name">var <span class="ident">input_type</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def input_type(self) -&gt; str:
    return &#34;(&#34; + (&#34;,&#34;.join(self.__format_json_abi_type_entry(arg) for arg in self.inputs)) + &#34;)&#34;</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.input_type_list"><code class="name">var <span class="ident">input_type_list</span> : list</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def input_type_list(self) -&gt; list:
    return self.input_type[1:len(self.input_type) - 1].split(&#34;,&#34;)</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    return self._abi[&#34;name&#34;]</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.output_type"><code class="name">var <span class="ident">output_type</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def output_type(self) -&gt; str:
    return &#34;({})&#34;.format(&#34;,&#34;.join(self.__format_json_abi_type_entry(arg) for arg in self.outputs))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tronpytool.compile.basecore.ContractMethod.as_shielded_trc20"><code class="name flex">
<span>def <span class="ident">as_shielded_trc20</span></span>(<span>self, contractaddr: str) ‑> <a title="tronpytool.compile.basecore.ShieldedTRC20" href="#tronpytool.compile.basecore.ShieldedTRC20">ShieldedTRC20</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_shielded_trc20(self, contractaddr: str) -&gt; &#34;ShieldedTRC20&#34;:
    return ShieldedTRC20(self._contract, self._tron, contractaddr)</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.call"><code class="name flex">
<span>def <span class="ident">call</span></span>(<span>self, *args, **kwargs) ‑> <a title="tronpytool.transactionbuilder.TransactionBuilder" href="../transactionbuilder.html#tronpytool.transactionbuilder.TransactionBuilder">TransactionBuilder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Call the contract method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call(self, *args, **kwargs) -&gt; &#34;TransactionBuilder&#34;:
    &#34;&#34;&#34;Call the contract method.&#34;&#34;&#34;
    return self.__call__(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.debug_input_io"><code class="name flex">
<span>def <span class="ident">debug_input_io</span></span>(<span>self, data_type, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_input_io(self, data_type, args):
    if self.debug:
        print(&#34;=======raw input ======== type-label: {}, type: {}&#34;.format(data_type, type(data_type)))
        print(args)
        print(&#34;=======end raw input ========&#34;)</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.debug_io"><code class="name flex">
<span>def <span class="ident">debug_io</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_io(self, data):
    if self.debug:
        print(&#34;====testing output type&#34;)
        print(&#34;output type {}&#34;.format(type(data[0])))
        print(&#34;output type detail: {}&#34;.format(self.output_type))
        print(&#34;==end&#34;)</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.debug_params"><code class="name flex">
<span>def <span class="ident">debug_params</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_params(self, data):
    if self.debug:
        print(&#34;=======param input ========&#34;)
        print(data)
        print(&#34;=======end param input========&#34;)</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.debug_raw_io"><code class="name flex">
<span>def <span class="ident">debug_raw_io</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def debug_raw_io(self, data):
    if self.debug:
        print(&#34;=======raw output ========&#34;)
        print(data)
        print(&#34;=======end raw output ========&#34;)</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.handle_url_response"><code class="name flex">
<span>def <span class="ident">handle_url_response</span></span>(<span>self, r: dict) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_url_response(self, r: dict) -&gt; any:
    ok, key, message = method_result_handler(r)
    if ok:
        print(&#34;transaction ID: {}&#34;.format(message))
        if len(key) &gt; 0:
            display = self.parse_output(key)
            self.debug_raw_io(key)
            return display
        else:
            return &#34;&#34;
    else:
        raise KeyError(&#39;Request returns Error - {} msg:{} txt:{}&#39;.format(key, message, self.parse_output(message)))</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.normalize_tx_params"><code class="name flex">
<span>def <span class="ident">normalize_tx_params</span></span>(<span>self, tx_params) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize and return the given transaction parameters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_tx_params(self, tx_params) -&gt; dict:
    &#34;&#34;&#34;Normalize and return the given transaction parameters.&#34;&#34;&#34;
    params = dict()
    return params</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.parse_output"><code class="name flex">
<span>def <span class="ident">parse_output</span></span>(<span>self, raw: <built-in function any>) ‑> <built-in function any></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_output(self, raw: any) -&gt; any:
    if type(raw) is bytes:
        &#34;&#34;&#34;Parse contract result as result.&#34;&#34;&#34;

        parsed_result = decode_single(self.output_type, bytes.fromhex(raw))
        if len(self.outputs) == 1:
            return parsed_result[0]
        if len(self.outputs) == 0:
            return None
        return parsed_result

    elif type(raw) is str:
        &#34;&#34;&#34;Parse contract result as result.&#34;&#34;&#34;

        parsed_result = decode_single(self.output_type, bytes.fromhex(raw))
        if len(self.outputs) == 1:
            return parsed_result[0]
        if len(self.outputs) == 0:
            return None
        return parsed_result

    elif type(raw) is list:
        &#34;&#34;&#34;Parse contract result as result.&#34;&#34;&#34;

        parsed_result = []
        for k in raw:
            p = decode_single(self.output_type, bytes.fromhex(k))
            parsed_result.append(p)
        if len(self.outputs) &gt;= 1:
            self.debug_io(parsed_result)
            return parsed_result[0]
        if len(self.outputs) == 0:
            print(&#34;no returns.. &#34;)
            return None

        return None

    else:

        print(&#34;there is not type were found.. &#34;)
        print(self.output_type)
        return raw</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.setDebug"><code class="name flex">
<span>def <span class="ident">setDebug</span></span>(<span>self, b: bool) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setDebug(self, b: bool) -&gt; None:
    self.debug = b</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.trackEventReceipt"><code class="name flex">
<span>def <span class="ident">trackEventReceipt</span></span>(<span>self, trnId: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trackEventReceipt(self, trnId: str):
    event = self._tron.get_event_transaction_id(trnId)
    print(&#34;=======debug event returns on this Transaction ID {}&#34;.format(trnId))
    print(event)
    print(&#34;=======end event report ========&#34;)</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.with_asset_transfer"><code class="name flex">
<span>def <span class="ident">with_asset_transfer</span></span>(<span>self, amount: int, token_id: int) ‑> <a title="tronpytool.compile.basecore.ContractMethod" href="#tronpytool.compile.basecore.ContractMethod">ContractMethod</a></span>
</code></dt>
<dd>
<div class="desc"><p>Call a contract function with TRC10 token transfer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_asset_transfer(self, amount: int, token_id: int) -&gt; &#34;ContractMethod&#34;:
    &#34;&#34;&#34;Call a contract function with TRC10 token transfer.&#34;&#34;&#34;
    self.call_token_value = amount
    self.call_token_id = token_id
    return self</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.with_owner"><code class="name flex">
<span>def <span class="ident">with_owner</span></span>(<span>self, addr: str) ‑> <a title="tronpytool.compile.basecore.ContractMethod" href="#tronpytool.compile.basecore.ContractMethod">ContractMethod</a></span>
</code></dt>
<dd>
<div class="desc"><p>Set the calling owner address.</p>
<p>Can also be changed through :meth:<code>TransactionBuilder.with_owner() &lt;tronpy.tron.TransactionBuilder.with_owner&gt;</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_owner(self, addr: str) -&gt; &#34;ContractMethod&#34;:
    &#34;&#34;&#34;Set the calling owner address.

    Can also be changed through :meth:`TransactionBuilder.with_owner() &lt;tronpy.tron.TransactionBuilder.with_owner&gt;`.
    &#34;&#34;&#34;
    self._owner_address = addr
    return self</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ContractMethod.with_transfer"><code class="name flex">
<span>def <span class="ident">with_transfer</span></span>(<span>self, amount: int) ‑> <a title="tronpytool.compile.basecore.ContractMethod" href="#tronpytool.compile.basecore.ContractMethod">ContractMethod</a></span>
</code></dt>
<dd>
<div class="desc"><p>Call a contract function with TRX transfer. <code>amount</code> in <code>SUN</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def with_transfer(self, amount: int) -&gt; &#34;ContractMethod&#34;:
    &#34;&#34;&#34;Call a contract function with TRX transfer. ``amount`` in `SUN`.&#34;&#34;&#34;
    self.call_value = amount
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tronpytool.compile.basecore.ShieldedTRC20"><code class="flex name class">
<span>class <span class="ident">ShieldedTRC20</span></span>
<span>(</span><span>contract: <a title="tronpytool.contract.Contract" href="../contract.html#tronpytool.contract.Contract">Contract</a>, client: <a title="tronpytool.main.Tron" href="../main.html#tronpytool.main.Tron">Tron</a>, address: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Shielded TRC20 Wrapper.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ShieldedTRC20(object):
    &#34;&#34;&#34;Shielded TRC20 Wrapper.&#34;&#34;&#34;

    def __init__(self, contract: Contract, client: Tron, address: str):
        self.shielded = address
        &#34;&#34;&#34;The shielded TRC20 contract.&#34;&#34;&#34;
        self._client = client
        self._trx_module = client.trx
        self._contract = contract
        # lazy properties
        self._trc20 = None
        self._scale_factor = None

    @property
    def trc20(self) -&gt; Contract:
        &#34;&#34;&#34;The corresponding TRC20 contract.&#34;&#34;&#34;
        if self._trc20 is None:
            trc20_address = &#34;41&#34; + str(self.shielded)._bytecode[-52:-32].hex()
            self._trc20 = self._trx_module.get_contract(trc20_address)
        return self._trc20

    @property
    def scale_factor(self) -&gt; int:
        &#34;&#34;&#34;Scaling factor of the shielded contract.&#34;&#34;&#34;
        if self._scale_factor is None:
            self._scale_factor = self._contract.functions.scalingFactor()
        return self._scale_factor

    def get_rcm(self) -&gt; str:
        return self._client.manager.request(&#34;wallet/getrcm&#34;)[&#34;value&#34;]

    def mint(self, taddr: str, zaddr: str, amount: int, memo: str = &#34;&#34;) -&gt; &#34;TransactionBuilder&#34;:
        &#34;&#34;&#34;Mint, transfer from T-address to z-address.&#34;&#34;&#34;
        rcm = self.get_rcm()
        payload = {
            &#34;from_amount&#34;: str(amount),
            &#34;shielded_receives&#34;: {
                &#34;note&#34;: {
                    &#34;value&#34;: amount // self.scale_factor,
                    &#34;payment_address&#34;: zaddr,
                    &#34;rcm&#34;: rcm,
                    &#34;memo&#34;: memo.encode().hex(),
                }
            },
            &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self._contract.contract_address),
        }

        ret = self._client.manager.request(&#34;wallet/createshieldedcontractparameters&#34;, payload)
        self._client._handle_api_error(ret)
        parameter = ret[&#34;trigger_contract_input&#34;]
        function_signature = self._contract.functions.mint.function_signature_hash
        return self._trx_module._build_transaction(
            &#34;TriggerSmartContract&#34;,
            {
                &#34;owner_address&#34;: to_hex_address(taddr),
                &#34;contract_address&#34;: to_hex_address(self._contract.contract_address),
                &#34;data&#34;: function_signature + parameter,
            },
            method=self._contract.functions.mint,
        )

    def transfer(
            self, zkey: dict, notes: Union[list, dict], *to: Union[Tuple[str, int], Tuple[str, int, str]],
    ) -&gt; &#34;tronpy.tron.TransactionBuilder&#34;:
        &#34;&#34;&#34;Transfer from z-address to z-address.&#34;&#34;&#34;
        if isinstance(notes, (dict,)):
            notes = [notes]

        assert 1 &lt;= len(notes) &lt;= 2

        spends = []
        spend_amount = 0
        for note in notes:
            if note.get(&#34;is_spent&#34;, False):
                raise DoubleSpending
            alpha = self.get_rcm()
            root, path = self.get_path(note.get(&#34;position&#34;, 0))
            spends.append(
                {&#34;note&#34;: note[&#34;note&#34;], &#34;alpha&#34;: alpha, &#34;root&#34;: root, &#34;path&#34;: path, &#34;pos&#34;: note.get(&#34;position&#34;, 0)}
            )
            spend_amount += note[&#34;note&#34;][&#34;value&#34;]

        receives = []
        receive_amount = 0
        for recv in to:
            addr = recv[0]
            amount = recv[1]
            receive_amount += amount
            if len(recv) == 3:
                memo = recv[2]
            else:
                memo = &#34;&#34;

            rcm = self.get_rcm()

            receives.append(
                {&#34;note&#34;: {&#34;value&#34;: amount, &#34;payment_address&#34;: addr, &#34;rcm&#34;: rcm, &#34;memo&#34;: memo.encode().hex()}}
            )

        if spend_amount != receive_amount:
            raise ValueError(&#34;spend amount is not equal to receive amount&#34;)

        payload = {
            &#34;ask&#34;: zkey[&#34;ask&#34;],
            &#34;nsk&#34;: zkey[&#34;nsk&#34;],
            &#34;ovk&#34;: zkey[&#34;ovk&#34;],
            &#34;shielded_spends&#34;: spends,
            &#34;shielded_receives&#34;: receives,
            &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
        }
        ret = self._client.provider.make_request(&#34;wallet/createshieldedcontractparameters&#34;, payload)
        self._client._handle_api_error(ret)
        parameter = ret[&#34;trigger_contract_input&#34;]
        function_signature = self.shielded.functions.transfer.function_signature_hash
        return self._trx_module._build_transaction(
            &#34;TriggerSmartContract&#34;,
            {
                &#34;owner_address&#34;: &#34;0000000000000000000000000000000000000000&#34;,
                &#34;contract_address&#34;: to_hex_address(self.shielded.contract_address),
                &#34;data&#34;: function_signature + parameter,
            },
            method=self.shielded.functions.transfer,
        )

    def burn(
            self, zkey: dict, note: dict, *to: Union[Tuple[str, int], Tuple[str, int, str]]
    ) -&gt; &#34;tronpy.tron.TransactionBuilder&#34;:
        &#34;&#34;&#34;Burn, transfer from z-address to T-address.&#34;&#34;&#34;
        spends = []
        alpha = self.get_rcm()
        root, path = self.get_path(note.get(&#34;position&#34;, 0))
        if note.get(&#34;is_spent&#34;, False):
            raise DoubleSpending
        spends.append(
            {&#34;note&#34;: note[&#34;note&#34;], &#34;alpha&#34;: alpha, &#34;root&#34;: root, &#34;path&#34;: path, &#34;pos&#34;: note.get(&#34;position&#34;, 0)}
        )
        change_amount = 0
        receives = []
        to_addr = None
        to_amount = 0
        to_memo = &#39;&#39;
        if not to:
            raise ValueError(&#39;burn must have a output&#39;)
        for receive in to:
            addr = receive[0]
            amount = receive[1]
            if len(receive) == 3:
                memo = receive[2]
            else:
                memo = &#34;&#34;

            if addr.startswith(&#39;ztron1&#39;):
                change_amount += amount
                rcm = self.get_rcm()
                receives = [
                    {&#34;note&#34;: {&#34;value&#34;: amount, &#34;payment_address&#34;: addr, &#34;rcm&#34;: rcm, &#34;memo&#34;: memo.encode().hex()}}
                ]
            else:
                # assume T-address
                to_addr = addr
                to_amount = amount
                to_memo = memo

        if note[&#34;note&#34;][&#34;value&#34;] * self.scale_factor - change_amount * self.scale_factor != to_amount:
            raise ValueError(&#34;Balance amount is wrong&#34;)

        payload = {
            &#34;ask&#34;: zkey[&#34;ask&#34;],
            &#34;nsk&#34;: zkey[&#34;nsk&#34;],
            &#34;ovk&#34;: zkey[&#34;ovk&#34;],
            &#34;shielded_spends&#34;: spends,
            &#34;shielded_receives&#34;: receives,
            &#34;to_amount&#34;: str(to_amount),
            &#34;transparent_to_address&#34;: to_hex_address(to_addr),
            &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
        }

        ret = self._client.provider.make_request(&#34;wallet/createshieldedcontractparameters&#34;, payload)
        self._client._handle_api_error(ret)
        parameter = ret[&#34;trigger_contract_input&#34;]
        function_signature = self.shielded.functions.burn.function_signature_hash
        txn = self._trx_module._build_transaction(
            &#34;TriggerSmartContract&#34;,
            {
                &#34;owner_address&#34;: &#34;410000000000000000000000000000000000000000&#34;,
                &#34;contract_address&#34;: to_hex_address(self.shielded.contract_address),
                &#34;data&#34;: function_signature + parameter,
            },
            method=self.shielded.functions.burn,
        )
        if to_memo:
            txn = txn.memo(to_memo)
        return txn

    def _fix_notes(self, notes: list) -&gt; list:
        for note in notes:
            if &#34;position&#34; not in note:
                note[&#34;position&#34;] = 0
            if &#34;is_spent&#34; not in note:
                note[&#34;is_spent&#34;] = False
            # if &#34;memo&#34; in note[&#34;note&#34;]:
            #     note[&#34;note&#34;][&#34;memo&#34;] = bytes.fromhex(note[&#34;note&#34;][&#34;memo&#34;]).decode(&#34;utf8&#34;, &#39;ignore&#39;)
        return notes

    # use zkey pair from wallet/getnewshieldedaddress
    def scan_incoming_notes(self, zkey: dict, start_block_number: int, end_block_number: int = None) -&gt; list:
        &#34;&#34;&#34;Scan incoming notes using ivk, ak, nk.&#34;&#34;&#34;
        if end_block_number is None:
            end_block_number = start_block_number + 1000
        payload = {
            &#34;start_block_index&#34;: start_block_number,
            &#34;end_block_index&#34;: end_block_number,
            &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
            &#34;ivk&#34;: zkey[&#34;ivk&#34;],
            &#34;ak&#34;: zkey[&#34;ak&#34;],
            &#34;nk&#34;: zkey[&#34;nk&#34;],
        }
        ret = self._client.provider.make_request(&#34;wallet/scanshieldedtrc20notesbyivk&#34;, payload)
        self._client._handle_api_error(ret)
        return self._fix_notes(ret.get(&#34;noteTxs&#34;, []))

    def scan_outgoing_notes(
            self, zkey_or_ovk: Union[dict, str], start_block_number: int, end_block_number: int = None
    ) -&gt; list:
        &#34;&#34;&#34;Scan outgoing notes using ovk.&#34;&#34;&#34;
        if end_block_number is None:
            end_block_number = start_block_number + 1000

        ovk = zkey_or_ovk
        if isinstance(zkey_or_ovk, (dict,)):
            ovk = zkey_or_ovk[&#34;ovk&#34;]

        payload = {
            &#34;start_block_index&#34;: start_block_number,
            &#34;end_block_index&#34;: end_block_number,
            &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
            &#34;ovk&#34;: ovk,
        }
        ret = self._client.provider.make_request(&#34;wallet/scanshieldedtrc20notesbyovk&#34;, payload)
        self._client._handle_api_error(ret)
        return ret.get(&#34;noteTxs&#34;, [])

    # (root, path)
    def get_path(self, position: int = 0) -&gt; (str, str):
        root, path = self.shielded.functions.getPath(position)
        root = root.hex()
        path = &#34;&#34;.join(p.hex() for p in path)
        return (root, path)

    def is_note_spent(self, zkey: dict, note: dict) -&gt; bool:
        &#34;&#34;&#34;Is a note spent.&#34;&#34;&#34;
        payload = dict(note)
        payload[&#34;shielded_TRC20_contract_address&#34;] = to_hex_address(self.shielded.contract_address)
        if &#34;position&#34; not in note:
            payload[&#34;position&#34;] = 0
        payload[&#34;ak&#34;] = zkey[&#34;ak&#34;]
        payload[&#34;nk&#34;] = zkey[&#34;nk&#34;]

        ret = self._client.provider.make_request(&#34;wallet/isshieldedtrc20contractnotespent&#34;, payload)

        return ret.get(&#39;is_spent&#39;, None)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tronpytool.compile.basecore.ShieldedTRC20.scale_factor"><code class="name">var <span class="ident">scale_factor</span> : int</code></dt>
<dd>
<div class="desc"><p>Scaling factor of the shielded contract.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scale_factor(self) -&gt; int:
    &#34;&#34;&#34;Scaling factor of the shielded contract.&#34;&#34;&#34;
    if self._scale_factor is None:
        self._scale_factor = self._contract.functions.scalingFactor()
    return self._scale_factor</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ShieldedTRC20.shielded"><code class="name">var <span class="ident">shielded</span></code></dt>
<dd>
<div class="desc"><p>The shielded TRC20 contract.</p></div>
</dd>
<dt id="tronpytool.compile.basecore.ShieldedTRC20.trc20"><code class="name">var <span class="ident">trc20</span> : <a title="tronpytool.contract.Contract" href="../contract.html#tronpytool.contract.Contract">Contract</a></code></dt>
<dd>
<div class="desc"><p>The corresponding TRC20 contract.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trc20(self) -&gt; Contract:
    &#34;&#34;&#34;The corresponding TRC20 contract.&#34;&#34;&#34;
    if self._trc20 is None:
        trc20_address = &#34;41&#34; + str(self.shielded)._bytecode[-52:-32].hex()
        self._trc20 = self._trx_module.get_contract(trc20_address)
    return self._trc20</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tronpytool.compile.basecore.ShieldedTRC20.burn"><code class="name flex">
<span>def <span class="ident">burn</span></span>(<span>self, zkey: dict, note: dict, *to: Union[Tuple[str, int], Tuple[str, int, str]]) ‑> tronpy.tron.TransactionBuilder</span>
</code></dt>
<dd>
<div class="desc"><p>Burn, transfer from z-address to T-address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def burn(
        self, zkey: dict, note: dict, *to: Union[Tuple[str, int], Tuple[str, int, str]]
) -&gt; &#34;tronpy.tron.TransactionBuilder&#34;:
    &#34;&#34;&#34;Burn, transfer from z-address to T-address.&#34;&#34;&#34;
    spends = []
    alpha = self.get_rcm()
    root, path = self.get_path(note.get(&#34;position&#34;, 0))
    if note.get(&#34;is_spent&#34;, False):
        raise DoubleSpending
    spends.append(
        {&#34;note&#34;: note[&#34;note&#34;], &#34;alpha&#34;: alpha, &#34;root&#34;: root, &#34;path&#34;: path, &#34;pos&#34;: note.get(&#34;position&#34;, 0)}
    )
    change_amount = 0
    receives = []
    to_addr = None
    to_amount = 0
    to_memo = &#39;&#39;
    if not to:
        raise ValueError(&#39;burn must have a output&#39;)
    for receive in to:
        addr = receive[0]
        amount = receive[1]
        if len(receive) == 3:
            memo = receive[2]
        else:
            memo = &#34;&#34;

        if addr.startswith(&#39;ztron1&#39;):
            change_amount += amount
            rcm = self.get_rcm()
            receives = [
                {&#34;note&#34;: {&#34;value&#34;: amount, &#34;payment_address&#34;: addr, &#34;rcm&#34;: rcm, &#34;memo&#34;: memo.encode().hex()}}
            ]
        else:
            # assume T-address
            to_addr = addr
            to_amount = amount
            to_memo = memo

    if note[&#34;note&#34;][&#34;value&#34;] * self.scale_factor - change_amount * self.scale_factor != to_amount:
        raise ValueError(&#34;Balance amount is wrong&#34;)

    payload = {
        &#34;ask&#34;: zkey[&#34;ask&#34;],
        &#34;nsk&#34;: zkey[&#34;nsk&#34;],
        &#34;ovk&#34;: zkey[&#34;ovk&#34;],
        &#34;shielded_spends&#34;: spends,
        &#34;shielded_receives&#34;: receives,
        &#34;to_amount&#34;: str(to_amount),
        &#34;transparent_to_address&#34;: to_hex_address(to_addr),
        &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
    }

    ret = self._client.provider.make_request(&#34;wallet/createshieldedcontractparameters&#34;, payload)
    self._client._handle_api_error(ret)
    parameter = ret[&#34;trigger_contract_input&#34;]
    function_signature = self.shielded.functions.burn.function_signature_hash
    txn = self._trx_module._build_transaction(
        &#34;TriggerSmartContract&#34;,
        {
            &#34;owner_address&#34;: &#34;410000000000000000000000000000000000000000&#34;,
            &#34;contract_address&#34;: to_hex_address(self.shielded.contract_address),
            &#34;data&#34;: function_signature + parameter,
        },
        method=self.shielded.functions.burn,
    )
    if to_memo:
        txn = txn.memo(to_memo)
    return txn</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ShieldedTRC20.get_path"><code class="name flex">
<span>def <span class="ident">get_path</span></span>(<span>self, position: int = 0) ‑> (<class 'str'>, <class 'str'>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path(self, position: int = 0) -&gt; (str, str):
    root, path = self.shielded.functions.getPath(position)
    root = root.hex()
    path = &#34;&#34;.join(p.hex() for p in path)
    return (root, path)</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ShieldedTRC20.get_rcm"><code class="name flex">
<span>def <span class="ident">get_rcm</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_rcm(self) -&gt; str:
    return self._client.manager.request(&#34;wallet/getrcm&#34;)[&#34;value&#34;]</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ShieldedTRC20.is_note_spent"><code class="name flex">
<span>def <span class="ident">is_note_spent</span></span>(<span>self, zkey: dict, note: dict) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Is a note spent.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_note_spent(self, zkey: dict, note: dict) -&gt; bool:
    &#34;&#34;&#34;Is a note spent.&#34;&#34;&#34;
    payload = dict(note)
    payload[&#34;shielded_TRC20_contract_address&#34;] = to_hex_address(self.shielded.contract_address)
    if &#34;position&#34; not in note:
        payload[&#34;position&#34;] = 0
    payload[&#34;ak&#34;] = zkey[&#34;ak&#34;]
    payload[&#34;nk&#34;] = zkey[&#34;nk&#34;]

    ret = self._client.provider.make_request(&#34;wallet/isshieldedtrc20contractnotespent&#34;, payload)

    return ret.get(&#39;is_spent&#39;, None)</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ShieldedTRC20.mint"><code class="name flex">
<span>def <span class="ident">mint</span></span>(<span>self, taddr: str, zaddr: str, amount: int, memo: str = '') ‑> <a title="tronpytool.transactionbuilder.TransactionBuilder" href="../transactionbuilder.html#tronpytool.transactionbuilder.TransactionBuilder">TransactionBuilder</a></span>
</code></dt>
<dd>
<div class="desc"><p>Mint, transfer from T-address to z-address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mint(self, taddr: str, zaddr: str, amount: int, memo: str = &#34;&#34;) -&gt; &#34;TransactionBuilder&#34;:
    &#34;&#34;&#34;Mint, transfer from T-address to z-address.&#34;&#34;&#34;
    rcm = self.get_rcm()
    payload = {
        &#34;from_amount&#34;: str(amount),
        &#34;shielded_receives&#34;: {
            &#34;note&#34;: {
                &#34;value&#34;: amount // self.scale_factor,
                &#34;payment_address&#34;: zaddr,
                &#34;rcm&#34;: rcm,
                &#34;memo&#34;: memo.encode().hex(),
            }
        },
        &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self._contract.contract_address),
    }

    ret = self._client.manager.request(&#34;wallet/createshieldedcontractparameters&#34;, payload)
    self._client._handle_api_error(ret)
    parameter = ret[&#34;trigger_contract_input&#34;]
    function_signature = self._contract.functions.mint.function_signature_hash
    return self._trx_module._build_transaction(
        &#34;TriggerSmartContract&#34;,
        {
            &#34;owner_address&#34;: to_hex_address(taddr),
            &#34;contract_address&#34;: to_hex_address(self._contract.contract_address),
            &#34;data&#34;: function_signature + parameter,
        },
        method=self._contract.functions.mint,
    )</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ShieldedTRC20.scan_incoming_notes"><code class="name flex">
<span>def <span class="ident">scan_incoming_notes</span></span>(<span>self, zkey: dict, start_block_number: int, end_block_number: int = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Scan incoming notes using ivk, ak, nk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_incoming_notes(self, zkey: dict, start_block_number: int, end_block_number: int = None) -&gt; list:
    &#34;&#34;&#34;Scan incoming notes using ivk, ak, nk.&#34;&#34;&#34;
    if end_block_number is None:
        end_block_number = start_block_number + 1000
    payload = {
        &#34;start_block_index&#34;: start_block_number,
        &#34;end_block_index&#34;: end_block_number,
        &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
        &#34;ivk&#34;: zkey[&#34;ivk&#34;],
        &#34;ak&#34;: zkey[&#34;ak&#34;],
        &#34;nk&#34;: zkey[&#34;nk&#34;],
    }
    ret = self._client.provider.make_request(&#34;wallet/scanshieldedtrc20notesbyivk&#34;, payload)
    self._client._handle_api_error(ret)
    return self._fix_notes(ret.get(&#34;noteTxs&#34;, []))</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ShieldedTRC20.scan_outgoing_notes"><code class="name flex">
<span>def <span class="ident">scan_outgoing_notes</span></span>(<span>self, zkey_or_ovk: Union[dict, str], start_block_number: int, end_block_number: int = None) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>Scan outgoing notes using ovk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scan_outgoing_notes(
        self, zkey_or_ovk: Union[dict, str], start_block_number: int, end_block_number: int = None
) -&gt; list:
    &#34;&#34;&#34;Scan outgoing notes using ovk.&#34;&#34;&#34;
    if end_block_number is None:
        end_block_number = start_block_number + 1000

    ovk = zkey_or_ovk
    if isinstance(zkey_or_ovk, (dict,)):
        ovk = zkey_or_ovk[&#34;ovk&#34;]

    payload = {
        &#34;start_block_index&#34;: start_block_number,
        &#34;end_block_index&#34;: end_block_number,
        &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
        &#34;ovk&#34;: ovk,
    }
    ret = self._client.provider.make_request(&#34;wallet/scanshieldedtrc20notesbyovk&#34;, payload)
    self._client._handle_api_error(ret)
    return ret.get(&#34;noteTxs&#34;, [])</code></pre>
</details>
</dd>
<dt id="tronpytool.compile.basecore.ShieldedTRC20.transfer"><code class="name flex">
<span>def <span class="ident">transfer</span></span>(<span>self, zkey: dict, notes: Union[list, dict], *to: Union[Tuple[str, int], Tuple[str, int, str]]) ‑> tronpy.tron.TransactionBuilder</span>
</code></dt>
<dd>
<div class="desc"><p>Transfer from z-address to z-address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer(
        self, zkey: dict, notes: Union[list, dict], *to: Union[Tuple[str, int], Tuple[str, int, str]],
) -&gt; &#34;tronpy.tron.TransactionBuilder&#34;:
    &#34;&#34;&#34;Transfer from z-address to z-address.&#34;&#34;&#34;
    if isinstance(notes, (dict,)):
        notes = [notes]

    assert 1 &lt;= len(notes) &lt;= 2

    spends = []
    spend_amount = 0
    for note in notes:
        if note.get(&#34;is_spent&#34;, False):
            raise DoubleSpending
        alpha = self.get_rcm()
        root, path = self.get_path(note.get(&#34;position&#34;, 0))
        spends.append(
            {&#34;note&#34;: note[&#34;note&#34;], &#34;alpha&#34;: alpha, &#34;root&#34;: root, &#34;path&#34;: path, &#34;pos&#34;: note.get(&#34;position&#34;, 0)}
        )
        spend_amount += note[&#34;note&#34;][&#34;value&#34;]

    receives = []
    receive_amount = 0
    for recv in to:
        addr = recv[0]
        amount = recv[1]
        receive_amount += amount
        if len(recv) == 3:
            memo = recv[2]
        else:
            memo = &#34;&#34;

        rcm = self.get_rcm()

        receives.append(
            {&#34;note&#34;: {&#34;value&#34;: amount, &#34;payment_address&#34;: addr, &#34;rcm&#34;: rcm, &#34;memo&#34;: memo.encode().hex()}}
        )

    if spend_amount != receive_amount:
        raise ValueError(&#34;spend amount is not equal to receive amount&#34;)

    payload = {
        &#34;ask&#34;: zkey[&#34;ask&#34;],
        &#34;nsk&#34;: zkey[&#34;nsk&#34;],
        &#34;ovk&#34;: zkey[&#34;ovk&#34;],
        &#34;shielded_spends&#34;: spends,
        &#34;shielded_receives&#34;: receives,
        &#34;shielded_TRC20_contract_address&#34;: to_hex_address(self.shielded.contract_address),
    }
    ret = self._client.provider.make_request(&#34;wallet/createshieldedcontractparameters&#34;, payload)
    self._client._handle_api_error(ret)
    parameter = ret[&#34;trigger_contract_input&#34;]
    function_signature = self.shielded.functions.transfer.function_signature_hash
    return self._trx_module._build_transaction(
        &#34;TriggerSmartContract&#34;,
        {
            &#34;owner_address&#34;: &#34;0000000000000000000000000000000000000000&#34;,
            &#34;contract_address&#34;: to_hex_address(self.shielded.contract_address),
            &#34;data&#34;: function_signature + parameter,
        },
        method=self.shielded.functions.transfer,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tronpytool.compile.basecore.Validator"><code class="flex name class">
<span>class <span class="ident">Validator</span></span>
<span>(</span><span>web3_or_provider: <a title="tronpytool.main.Tron" href="../main.html#tronpytool.main.Tron">Tron</a>, contract_address: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for validating inputs to methods.</p>
<p>Initialize the instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Validator:
    &#34;&#34;&#34;Base class for validating inputs to methods.&#34;&#34;&#34;

    def __init__(
            self,
            web3_or_provider: Tron,
            contract_address: str,
    ):
        &#34;&#34;&#34;Initialize the instance.&#34;&#34;&#34;

    def assert_valid(
            self, method_name: str, parameter_name: str, argument_value: Any
    ):
        &#34;&#34;&#34;Raise an exception if method input is not valid.

        :param method_name: Name of the method whose input is to be validated.
        :param parameter_name: Name of the parameter whose input is to be
            validated.
        :param argument_value: Value of argument to parameter to be validated.
        &#34;&#34;&#34;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tronpytool.compile.basecore.Validator.assert_valid"><code class="name flex">
<span>def <span class="ident">assert_valid</span></span>(<span>self, method_name: str, parameter_name: str, argument_value: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Raise an exception if method input is not valid.</p>
<p>:param method_name: Name of the method whose input is to be validated.
:param parameter_name: Name of the parameter whose input is to be
validated.
:param argument_value: Value of argument to parameter to be validated.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def assert_valid(
        self, method_name: str, parameter_name: str, argument_value: Any
):
    &#34;&#34;&#34;Raise an exception if method input is not valid.

    :param method_name: Name of the method whose input is to be validated.
    :param parameter_name: Name of the parameter whose input is to be
        validated.
    :param argument_value: Value of argument to parameter to be validated.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tronpytool.compile" href="index.html">tronpytool.compile</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tronpytool.compile.basecore.ContractMethod" href="#tronpytool.compile.basecore.ContractMethod">ContractMethod</a></code></h4>
<ul class="">
<li><code><a title="tronpytool.compile.basecore.ContractMethod.as_shielded_trc20" href="#tronpytool.compile.basecore.ContractMethod.as_shielded_trc20">as_shielded_trc20</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.call" href="#tronpytool.compile.basecore.ContractMethod.call">call</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.debug" href="#tronpytool.compile.basecore.ContractMethod.debug">debug</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.debug_input_io" href="#tronpytool.compile.basecore.ContractMethod.debug_input_io">debug_input_io</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.debug_io" href="#tronpytool.compile.basecore.ContractMethod.debug_io">debug_io</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.debug_params" href="#tronpytool.compile.basecore.ContractMethod.debug_params">debug_params</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.debug_raw_io" href="#tronpytool.compile.basecore.ContractMethod.debug_raw_io">debug_raw_io</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.function_signature" href="#tronpytool.compile.basecore.ContractMethod.function_signature">function_signature</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.function_signature_hash" href="#tronpytool.compile.basecore.ContractMethod.function_signature_hash">function_signature_hash</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.function_type" href="#tronpytool.compile.basecore.ContractMethod.function_type">function_type</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.handle_url_response" href="#tronpytool.compile.basecore.ContractMethod.handle_url_response">handle_url_response</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.input_type" href="#tronpytool.compile.basecore.ContractMethod.input_type">input_type</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.input_type_list" href="#tronpytool.compile.basecore.ContractMethod.input_type_list">input_type_list</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.name" href="#tronpytool.compile.basecore.ContractMethod.name">name</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.normalize_tx_params" href="#tronpytool.compile.basecore.ContractMethod.normalize_tx_params">normalize_tx_params</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.output_type" href="#tronpytool.compile.basecore.ContractMethod.output_type">output_type</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.parse_output" href="#tronpytool.compile.basecore.ContractMethod.parse_output">parse_output</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.setDebug" href="#tronpytool.compile.basecore.ContractMethod.setDebug">setDebug</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.trackEventReceipt" href="#tronpytool.compile.basecore.ContractMethod.trackEventReceipt">trackEventReceipt</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.validate_and_checksum_address" href="#tronpytool.compile.basecore.ContractMethod.validate_and_checksum_address">validate_and_checksum_address</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.with_asset_transfer" href="#tronpytool.compile.basecore.ContractMethod.with_asset_transfer">with_asset_transfer</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.with_owner" href="#tronpytool.compile.basecore.ContractMethod.with_owner">with_owner</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ContractMethod.with_transfer" href="#tronpytool.compile.basecore.ContractMethod.with_transfer">with_transfer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tronpytool.compile.basecore.ShieldedTRC20" href="#tronpytool.compile.basecore.ShieldedTRC20">ShieldedTRC20</a></code></h4>
<ul class="two-column">
<li><code><a title="tronpytool.compile.basecore.ShieldedTRC20.burn" href="#tronpytool.compile.basecore.ShieldedTRC20.burn">burn</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ShieldedTRC20.get_path" href="#tronpytool.compile.basecore.ShieldedTRC20.get_path">get_path</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ShieldedTRC20.get_rcm" href="#tronpytool.compile.basecore.ShieldedTRC20.get_rcm">get_rcm</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ShieldedTRC20.is_note_spent" href="#tronpytool.compile.basecore.ShieldedTRC20.is_note_spent">is_note_spent</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ShieldedTRC20.mint" href="#tronpytool.compile.basecore.ShieldedTRC20.mint">mint</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ShieldedTRC20.scale_factor" href="#tronpytool.compile.basecore.ShieldedTRC20.scale_factor">scale_factor</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ShieldedTRC20.scan_incoming_notes" href="#tronpytool.compile.basecore.ShieldedTRC20.scan_incoming_notes">scan_incoming_notes</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ShieldedTRC20.scan_outgoing_notes" href="#tronpytool.compile.basecore.ShieldedTRC20.scan_outgoing_notes">scan_outgoing_notes</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ShieldedTRC20.shielded" href="#tronpytool.compile.basecore.ShieldedTRC20.shielded">shielded</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ShieldedTRC20.transfer" href="#tronpytool.compile.basecore.ShieldedTRC20.transfer">transfer</a></code></li>
<li><code><a title="tronpytool.compile.basecore.ShieldedTRC20.trc20" href="#tronpytool.compile.basecore.ShieldedTRC20.trc20">trc20</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tronpytool.compile.basecore.Validator" href="#tronpytool.compile.basecore.Validator">Validator</a></code></h4>
<ul class="">
<li><code><a title="tronpytool.compile.basecore.Validator.assert_valid" href="#tronpytool.compile.basecore.Validator.assert_valid">assert_valid</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>